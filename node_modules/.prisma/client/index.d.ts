
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Club
 * 
 */
export type Club = $Result.DefaultSelection<Prisma.$ClubPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model PRProfile
 * 
 */
export type PRProfile = $Result.DefaultSelection<Prisma.$PRProfilePayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model List
 * 
 */
export type List = $Result.DefaultSelection<Prisma.$ListPayload>
/**
 * Model Guest
 * 
 */
export type Guest = $Result.DefaultSelection<Prisma.$GuestPayload>
/**
 * Model ListEntry
 * 
 */
export type ListEntry = $Result.DefaultSelection<Prisma.$ListEntryPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model CheckIn
 * 
 */
export type CheckIn = $Result.DefaultSelection<Prisma.$CheckInPayload>
/**
 * Model InviteLink
 * 
 */
export type InviteLink = $Result.DefaultSelection<Prisma.$InviteLinkPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Consumption
 * 
 */
export type Consumption = $Result.DefaultSelection<Prisma.$ConsumptionPayload>
/**
 * Model FunnelTracking
 * 
 */
export type FunnelTracking = $Result.DefaultSelection<Prisma.$FunnelTrackingPayload>
/**
 * Model EventFeedback
 * 
 */
export type EventFeedback = $Result.DefaultSelection<Prisma.$EventFeedbackPayload>
/**
 * Model SecurityNote
 * 
 */
export type SecurityNote = $Result.DefaultSelection<Prisma.$SecurityNotePayload>
/**
 * Model CustomerPreferences
 * 
 */
export type CustomerPreferences = $Result.DefaultSelection<Prisma.$CustomerPreferencesPayload>
/**
 * Model OrganizationProfile
 * 
 */
export type OrganizationProfile = $Result.DefaultSelection<Prisma.$OrganizationProfilePayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model ArtistProfile
 * 
 */
export type ArtistProfile = $Result.DefaultSelection<Prisma.$ArtistProfilePayload>
/**
 * Model Performance
 * 
 */
export type Performance = $Result.DefaultSelection<Prisma.$PerformancePayload>
/**
 * Model ArtistMedia
 * 
 */
export type ArtistMedia = $Result.DefaultSelection<Prisma.$ArtistMediaPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model UserFollow
 * 
 */
export type UserFollow = $Result.DefaultSelection<Prisma.$UserFollowPayload>
/**
 * Model FeedItem
 * 
 */
export type FeedItem = $Result.DefaultSelection<Prisma.$FeedItemPayload>
/**
 * Model FeedLike
 * 
 */
export type FeedLike = $Result.DefaultSelection<Prisma.$FeedLikePayload>
/**
 * Model FeedComment
 * 
 */
export type FeedComment = $Result.DefaultSelection<Prisma.$FeedCommentPayload>
/**
 * Model IdentityVerification
 * 
 */
export type IdentityVerification = $Result.DefaultSelection<Prisma.$IdentityVerificationPayload>
/**
 * Model UserPhone
 * 
 */
export type UserPhone = $Result.DefaultSelection<Prisma.$UserPhonePayload>
/**
 * Model UserConsent
 * 
 */
export type UserConsent = $Result.DefaultSelection<Prisma.$UserConsentPayload>
/**
 * Model OnboardingProgress
 * 
 */
export type OnboardingProgress = $Result.DefaultSelection<Prisma.$OnboardingProgressPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClubType: {
  DISCOTECA: 'DISCOTECA',
  PUB: 'PUB',
  LIDO: 'LIDO',
  ALTRO: 'ALTRO'
};

export type ClubType = (typeof ClubType)[keyof typeof ClubType]


export const UserRole: {
  ADMIN: 'ADMIN',
  ORGANIZER: 'ORGANIZER',
  DJ: 'DJ',
  VOCALIST: 'VOCALIST',
  ARTIST: 'ARTIST',
  PR: 'PR',
  STAFF: 'STAFF',
  USER: 'USER',
  SECURITY: 'SECURITY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const EventStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  CANCELLED: 'CANCELLED',
  CLOSED: 'CLOSED'
};

export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus]


export const Gender: {
  F: 'F',
  M: 'M',
  NB: 'NB',
  UNK: 'UNK'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ListType: {
  PR: 'PR',
  GUEST: 'GUEST',
  STAFF: 'STAFF'
};

export type ListType = (typeof ListType)[keyof typeof ListType]


export const CreatedVia: {
  MANUAL: 'MANUAL',
  IMPORT: 'IMPORT',
  LINK: 'LINK'
};

export type CreatedVia = (typeof CreatedVia)[keyof typeof CreatedVia]


export const EntryStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  REJECTED: 'REJECTED'
};

export type EntryStatus = (typeof EntryStatus)[keyof typeof EntryStatus]


export const TicketType: {
  FREE: 'FREE',
  LIST: 'LIST',
  PAID: 'PAID'
};

export type TicketType = (typeof TicketType)[keyof typeof TicketType]


export const TicketStatus: {
  NEW: 'NEW',
  USED: 'USED',
  CANCELLED: 'CANCELLED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const Gate: {
  MAIN: 'MAIN',
  VIP: 'VIP',
  STAFF: 'STAFF'
};

export type Gate = (typeof Gate)[keyof typeof Gate]


export const BookingMethod: {
  INSTAGRAM: 'INSTAGRAM',
  WHATSAPP: 'WHATSAPP',
  WEBSITE: 'WEBSITE',
  APP: 'APP',
  PHONE: 'PHONE',
  MANUAL: 'MANUAL'
};

export type BookingMethod = (typeof BookingMethod)[keyof typeof BookingMethod]


export const CustomerSegment: {
  NEW: 'NEW',
  OCCASIONAL: 'OCCASIONAL',
  REGULAR: 'REGULAR',
  VIP: 'VIP',
  DORMANT: 'DORMANT'
};

export type CustomerSegment = (typeof CustomerSegment)[keyof typeof CustomerSegment]


export const ArtistType: {
  DJ: 'DJ',
  VOCALIST: 'VOCALIST',
  PRODUCER: 'PRODUCER',
  LIVE_BAND: 'LIVE_BAND',
  OTHER: 'OTHER'
};

export type ArtistType = (typeof ArtistType)[keyof typeof ArtistType]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  LINK: 'LINK'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const FeedItemType: {
  POST: 'POST',
  EVENT_ANNOUNCEMENT: 'EVENT_ANNOUNCEMENT',
  PHOTO: 'PHOTO',
  VIDEO: 'VIDEO',
  CHECK_IN: 'CHECK_IN'
};

export type FeedItemType = (typeof FeedItemType)[keyof typeof FeedItemType]


export const Visibility: {
  PUBLIC: 'PUBLIC',
  FOLLOWERS_ONLY: 'FOLLOWERS_ONLY',
  PRIVATE: 'PRIVATE'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const DocumentType: {
  ID_CARD: 'ID_CARD',
  PASSPORT: 'PASSPORT',
  DRIVER_LICENSE: 'DRIVER_LICENSE'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const VerificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]

}

export type ClubType = $Enums.ClubType

export const ClubType: typeof $Enums.ClubType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type EventStatus = $Enums.EventStatus

export const EventStatus: typeof $Enums.EventStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ListType = $Enums.ListType

export const ListType: typeof $Enums.ListType

export type CreatedVia = $Enums.CreatedVia

export const CreatedVia: typeof $Enums.CreatedVia

export type EntryStatus = $Enums.EntryStatus

export const EntryStatus: typeof $Enums.EntryStatus

export type TicketType = $Enums.TicketType

export const TicketType: typeof $Enums.TicketType

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type Gate = $Enums.Gate

export const Gate: typeof $Enums.Gate

export type BookingMethod = $Enums.BookingMethod

export const BookingMethod: typeof $Enums.BookingMethod

export type CustomerSegment = $Enums.CustomerSegment

export const CustomerSegment: typeof $Enums.CustomerSegment

export type ArtistType = $Enums.ArtistType

export const ArtistType: typeof $Enums.ArtistType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type FeedItemType = $Enums.FeedItemType

export const FeedItemType: typeof $Enums.FeedItemType

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.club`: Exposes CRUD operations for the **Club** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clubs
    * const clubs = await prisma.club.findMany()
    * ```
    */
  get club(): Prisma.ClubDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pRProfile`: Exposes CRUD operations for the **PRProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRProfiles
    * const pRProfiles = await prisma.pRProfile.findMany()
    * ```
    */
  get pRProfile(): Prisma.PRProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.list`: Exposes CRUD operations for the **List** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.list.findMany()
    * ```
    */
  get list(): Prisma.ListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **Guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): Prisma.GuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listEntry`: Exposes CRUD operations for the **ListEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListEntries
    * const listEntries = await prisma.listEntry.findMany()
    * ```
    */
  get listEntry(): Prisma.ListEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkIn`: Exposes CRUD operations for the **CheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckIns
    * const checkIns = await prisma.checkIn.findMany()
    * ```
    */
  get checkIn(): Prisma.CheckInDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inviteLink`: Exposes CRUD operations for the **InviteLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InviteLinks
    * const inviteLinks = await prisma.inviteLink.findMany()
    * ```
    */
  get inviteLink(): Prisma.InviteLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consumption`: Exposes CRUD operations for the **Consumption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consumptions
    * const consumptions = await prisma.consumption.findMany()
    * ```
    */
  get consumption(): Prisma.ConsumptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnelTracking`: Exposes CRUD operations for the **FunnelTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunnelTrackings
    * const funnelTrackings = await prisma.funnelTracking.findMany()
    * ```
    */
  get funnelTracking(): Prisma.FunnelTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventFeedback`: Exposes CRUD operations for the **EventFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventFeedbacks
    * const eventFeedbacks = await prisma.eventFeedback.findMany()
    * ```
    */
  get eventFeedback(): Prisma.EventFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityNote`: Exposes CRUD operations for the **SecurityNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityNotes
    * const securityNotes = await prisma.securityNote.findMany()
    * ```
    */
  get securityNote(): Prisma.SecurityNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPreferences`: Exposes CRUD operations for the **CustomerPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPreferences
    * const customerPreferences = await prisma.customerPreferences.findMany()
    * ```
    */
  get customerPreferences(): Prisma.CustomerPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationProfile`: Exposes CRUD operations for the **OrganizationProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationProfiles
    * const organizationProfiles = await prisma.organizationProfile.findMany()
    * ```
    */
  get organizationProfile(): Prisma.OrganizationProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artistProfile`: Exposes CRUD operations for the **ArtistProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtistProfiles
    * const artistProfiles = await prisma.artistProfile.findMany()
    * ```
    */
  get artistProfile(): Prisma.ArtistProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performance`: Exposes CRUD operations for the **Performance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Performances
    * const performances = await prisma.performance.findMany()
    * ```
    */
  get performance(): Prisma.PerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artistMedia`: Exposes CRUD operations for the **ArtistMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtistMedias
    * const artistMedias = await prisma.artistMedia.findMany()
    * ```
    */
  get artistMedia(): Prisma.ArtistMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFollow`: Exposes CRUD operations for the **UserFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFollows
    * const userFollows = await prisma.userFollow.findMany()
    * ```
    */
  get userFollow(): Prisma.UserFollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedItem`: Exposes CRUD operations for the **FeedItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedItems
    * const feedItems = await prisma.feedItem.findMany()
    * ```
    */
  get feedItem(): Prisma.FeedItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedLike`: Exposes CRUD operations for the **FeedLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedLikes
    * const feedLikes = await prisma.feedLike.findMany()
    * ```
    */
  get feedLike(): Prisma.FeedLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedComment`: Exposes CRUD operations for the **FeedComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedComments
    * const feedComments = await prisma.feedComment.findMany()
    * ```
    */
  get feedComment(): Prisma.FeedCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identityVerification`: Exposes CRUD operations for the **IdentityVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdentityVerifications
    * const identityVerifications = await prisma.identityVerification.findMany()
    * ```
    */
  get identityVerification(): Prisma.IdentityVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhone`: Exposes CRUD operations for the **UserPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhones
    * const userPhones = await prisma.userPhone.findMany()
    * ```
    */
  get userPhone(): Prisma.UserPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userConsent`: Exposes CRUD operations for the **UserConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConsents
    * const userConsents = await prisma.userConsent.findMany()
    * ```
    */
  get userConsent(): Prisma.UserConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.onboardingProgress`: Exposes CRUD operations for the **OnboardingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingProgresses
    * const onboardingProgresses = await prisma.onboardingProgress.findMany()
    * ```
    */
  get onboardingProgress(): Prisma.OnboardingProgressDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Club: 'Club',
    Venue: 'Venue',
    Event: 'Event',
    PRProfile: 'PRProfile',
    Assignment: 'Assignment',
    List: 'List',
    Guest: 'Guest',
    ListEntry: 'ListEntry',
    Ticket: 'Ticket',
    CheckIn: 'CheckIn',
    InviteLink: 'InviteLink',
    AuditLog: 'AuditLog',
    Consumption: 'Consumption',
    FunnelTracking: 'FunnelTracking',
    EventFeedback: 'EventFeedback',
    SecurityNote: 'SecurityNote',
    CustomerPreferences: 'CustomerPreferences',
    OrganizationProfile: 'OrganizationProfile',
    OrganizationMember: 'OrganizationMember',
    ArtistProfile: 'ArtistProfile',
    Performance: 'Performance',
    ArtistMedia: 'ArtistMedia',
    UserProfile: 'UserProfile',
    UserFollow: 'UserFollow',
    FeedItem: 'FeedItem',
    FeedLike: 'FeedLike',
    FeedComment: 'FeedComment',
    IdentityVerification: 'IdentityVerification',
    UserPhone: 'UserPhone',
    UserConsent: 'UserConsent',
    OnboardingProgress: 'OnboardingProgress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "user" | "verificationToken" | "club" | "venue" | "event" | "pRProfile" | "assignment" | "list" | "guest" | "listEntry" | "ticket" | "checkIn" | "inviteLink" | "auditLog" | "consumption" | "funnelTracking" | "eventFeedback" | "securityNote" | "customerPreferences" | "organizationProfile" | "organizationMember" | "artistProfile" | "performance" | "artistMedia" | "userProfile" | "userFollow" | "feedItem" | "feedLike" | "feedComment" | "identityVerification" | "userPhone" | "userConsent" | "onboardingProgress"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Club: {
        payload: Prisma.$ClubPayload<ExtArgs>
        fields: Prisma.ClubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findFirst: {
            args: Prisma.ClubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findMany: {
            args: Prisma.ClubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          create: {
            args: Prisma.ClubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          createMany: {
            args: Prisma.ClubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          delete: {
            args: Prisma.ClubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          update: {
            args: Prisma.ClubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          deleteMany: {
            args: Prisma.ClubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          upsert: {
            args: Prisma.ClubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          aggregate: {
            args: Prisma.ClubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClub>
          }
          groupBy: {
            args: Prisma.ClubGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubCountArgs<ExtArgs>
            result: $Utils.Optional<ClubCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      PRProfile: {
        payload: Prisma.$PRProfilePayload<ExtArgs>
        fields: Prisma.PRProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          findFirst: {
            args: Prisma.PRProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          findMany: {
            args: Prisma.PRProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>[]
          }
          create: {
            args: Prisma.PRProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          createMany: {
            args: Prisma.PRProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PRProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>[]
          }
          delete: {
            args: Prisma.PRProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          update: {
            args: Prisma.PRProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          deleteMany: {
            args: Prisma.PRProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PRProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>[]
          }
          upsert: {
            args: Prisma.PRProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRProfilePayload>
          }
          aggregate: {
            args: Prisma.PRProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRProfile>
          }
          groupBy: {
            args: Prisma.PRProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PRProfileCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      List: {
        payload: Prisma.$ListPayload<ExtArgs>
        fields: Prisma.ListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findFirst: {
            args: Prisma.ListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          findMany: {
            args: Prisma.ListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          create: {
            args: Prisma.ListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          createMany: {
            args: Prisma.ListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          delete: {
            args: Prisma.ListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          update: {
            args: Prisma.ListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          deleteMany: {
            args: Prisma.ListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>[]
          }
          upsert: {
            args: Prisma.ListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListPayload>
          }
          aggregate: {
            args: Prisma.ListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateList>
          }
          groupBy: {
            args: Prisma.ListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListCountArgs<ExtArgs>
            result: $Utils.Optional<ListCountAggregateOutputType> | number
          }
        }
      }
      Guest: {
        payload: Prisma.$GuestPayload<ExtArgs>
        fields: Prisma.GuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findFirst: {
            args: Prisma.GuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findMany: {
            args: Prisma.GuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          create: {
            args: Prisma.GuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          createMany: {
            args: Prisma.GuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          delete: {
            args: Prisma.GuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          update: {
            args: Prisma.GuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          deleteMany: {
            args: Prisma.GuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          upsert: {
            args: Prisma.GuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          aggregate: {
            args: Prisma.GuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuest>
          }
          groupBy: {
            args: Prisma.GuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuestCountArgs<ExtArgs>
            result: $Utils.Optional<GuestCountAggregateOutputType> | number
          }
        }
      }
      ListEntry: {
        payload: Prisma.$ListEntryPayload<ExtArgs>
        fields: Prisma.ListEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          findFirst: {
            args: Prisma.ListEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          findMany: {
            args: Prisma.ListEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          create: {
            args: Prisma.ListEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          createMany: {
            args: Prisma.ListEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          delete: {
            args: Prisma.ListEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          update: {
            args: Prisma.ListEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          deleteMany: {
            args: Prisma.ListEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>[]
          }
          upsert: {
            args: Prisma.ListEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListEntryPayload>
          }
          aggregate: {
            args: Prisma.ListEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListEntry>
          }
          groupBy: {
            args: Prisma.ListEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ListEntryCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      CheckIn: {
        payload: Prisma.$CheckInPayload<ExtArgs>
        fields: Prisma.CheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findFirst: {
            args: Prisma.CheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findMany: {
            args: Prisma.CheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          create: {
            args: Prisma.CheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          createMany: {
            args: Prisma.CheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          delete: {
            args: Prisma.CheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          update: {
            args: Prisma.CheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          deleteMany: {
            args: Prisma.CheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CheckInUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          upsert: {
            args: Prisma.CheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          aggregate: {
            args: Prisma.CheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckIn>
          }
          groupBy: {
            args: Prisma.CheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckInCountArgs<ExtArgs>
            result: $Utils.Optional<CheckInCountAggregateOutputType> | number
          }
        }
      }
      InviteLink: {
        payload: Prisma.$InviteLinkPayload<ExtArgs>
        fields: Prisma.InviteLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          findFirst: {
            args: Prisma.InviteLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          findMany: {
            args: Prisma.InviteLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>[]
          }
          create: {
            args: Prisma.InviteLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          createMany: {
            args: Prisma.InviteLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>[]
          }
          delete: {
            args: Prisma.InviteLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          update: {
            args: Prisma.InviteLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          deleteMany: {
            args: Prisma.InviteLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InviteLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>[]
          }
          upsert: {
            args: Prisma.InviteLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteLinkPayload>
          }
          aggregate: {
            args: Prisma.InviteLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInviteLink>
          }
          groupBy: {
            args: Prisma.InviteLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteLinkCountArgs<ExtArgs>
            result: $Utils.Optional<InviteLinkCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Consumption: {
        payload: Prisma.$ConsumptionPayload<ExtArgs>
        fields: Prisma.ConsumptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsumptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsumptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          findFirst: {
            args: Prisma.ConsumptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsumptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          findMany: {
            args: Prisma.ConsumptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>[]
          }
          create: {
            args: Prisma.ConsumptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          createMany: {
            args: Prisma.ConsumptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsumptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>[]
          }
          delete: {
            args: Prisma.ConsumptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          update: {
            args: Prisma.ConsumptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          deleteMany: {
            args: Prisma.ConsumptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsumptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsumptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>[]
          }
          upsert: {
            args: Prisma.ConsumptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionPayload>
          }
          aggregate: {
            args: Prisma.ConsumptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsumption>
          }
          groupBy: {
            args: Prisma.ConsumptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsumptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsumptionCountArgs<ExtArgs>
            result: $Utils.Optional<ConsumptionCountAggregateOutputType> | number
          }
        }
      }
      FunnelTracking: {
        payload: Prisma.$FunnelTrackingPayload<ExtArgs>
        fields: Prisma.FunnelTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          findFirst: {
            args: Prisma.FunnelTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          findMany: {
            args: Prisma.FunnelTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>[]
          }
          create: {
            args: Prisma.FunnelTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          createMany: {
            args: Prisma.FunnelTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>[]
          }
          delete: {
            args: Prisma.FunnelTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          update: {
            args: Prisma.FunnelTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          deleteMany: {
            args: Prisma.FunnelTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FunnelTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>[]
          }
          upsert: {
            args: Prisma.FunnelTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelTrackingPayload>
          }
          aggregate: {
            args: Prisma.FunnelTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnelTracking>
          }
          groupBy: {
            args: Prisma.FunnelTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelTrackingCountAggregateOutputType> | number
          }
        }
      }
      EventFeedback: {
        payload: Prisma.$EventFeedbackPayload<ExtArgs>
        fields: Prisma.EventFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          findFirst: {
            args: Prisma.EventFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          findMany: {
            args: Prisma.EventFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>[]
          }
          create: {
            args: Prisma.EventFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          createMany: {
            args: Prisma.EventFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>[]
          }
          delete: {
            args: Prisma.EventFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          update: {
            args: Prisma.EventFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.EventFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.EventFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventFeedbackPayload>
          }
          aggregate: {
            args: Prisma.EventFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventFeedback>
          }
          groupBy: {
            args: Prisma.EventFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<EventFeedbackCountAggregateOutputType> | number
          }
        }
      }
      SecurityNote: {
        payload: Prisma.$SecurityNotePayload<ExtArgs>
        fields: Prisma.SecurityNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          findFirst: {
            args: Prisma.SecurityNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          findMany: {
            args: Prisma.SecurityNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>[]
          }
          create: {
            args: Prisma.SecurityNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          createMany: {
            args: Prisma.SecurityNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>[]
          }
          delete: {
            args: Prisma.SecurityNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          update: {
            args: Prisma.SecurityNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          deleteMany: {
            args: Prisma.SecurityNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>[]
          }
          upsert: {
            args: Prisma.SecurityNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityNotePayload>
          }
          aggregate: {
            args: Prisma.SecurityNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityNote>
          }
          groupBy: {
            args: Prisma.SecurityNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityNoteCountAggregateOutputType> | number
          }
        }
      }
      CustomerPreferences: {
        payload: Prisma.$CustomerPreferencesPayload<ExtArgs>
        fields: Prisma.CustomerPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          findFirst: {
            args: Prisma.CustomerPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          findMany: {
            args: Prisma.CustomerPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>[]
          }
          create: {
            args: Prisma.CustomerPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          createMany: {
            args: Prisma.CustomerPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>[]
          }
          delete: {
            args: Prisma.CustomerPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          update: {
            args: Prisma.CustomerPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPreferencesPayload>
          }
          aggregate: {
            args: Prisma.CustomerPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPreferences>
          }
          groupBy: {
            args: Prisma.CustomerPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPreferencesCountAggregateOutputType> | number
          }
        }
      }
      OrganizationProfile: {
        payload: Prisma.$OrganizationProfilePayload<ExtArgs>
        fields: Prisma.OrganizationProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          findFirst: {
            args: Prisma.OrganizationProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          findMany: {
            args: Prisma.OrganizationProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>[]
          }
          create: {
            args: Prisma.OrganizationProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          createMany: {
            args: Prisma.OrganizationProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>[]
          }
          delete: {
            args: Prisma.OrganizationProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          update: {
            args: Prisma.OrganizationProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          deleteMany: {
            args: Prisma.OrganizationProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>[]
          }
          upsert: {
            args: Prisma.OrganizationProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationProfilePayload>
          }
          aggregate: {
            args: Prisma.OrganizationProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationProfile>
          }
          groupBy: {
            args: Prisma.OrganizationProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationProfileCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationProfileCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      ArtistProfile: {
        payload: Prisma.$ArtistProfilePayload<ExtArgs>
        fields: Prisma.ArtistProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          findFirst: {
            args: Prisma.ArtistProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          findMany: {
            args: Prisma.ArtistProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>[]
          }
          create: {
            args: Prisma.ArtistProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          createMany: {
            args: Prisma.ArtistProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>[]
          }
          delete: {
            args: Prisma.ArtistProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          update: {
            args: Prisma.ArtistProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          deleteMany: {
            args: Prisma.ArtistProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>[]
          }
          upsert: {
            args: Prisma.ArtistProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistProfilePayload>
          }
          aggregate: {
            args: Prisma.ArtistProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtistProfile>
          }
          groupBy: {
            args: Prisma.ArtistProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistProfileCountAggregateOutputType> | number
          }
        }
      }
      Performance: {
        payload: Prisma.$PerformancePayload<ExtArgs>
        fields: Prisma.PerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          findFirst: {
            args: Prisma.PerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          findMany: {
            args: Prisma.PerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>[]
          }
          create: {
            args: Prisma.PerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          createMany: {
            args: Prisma.PerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>[]
          }
          delete: {
            args: Prisma.PerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          update: {
            args: Prisma.PerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          deleteMany: {
            args: Prisma.PerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>[]
          }
          upsert: {
            args: Prisma.PerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePayload>
          }
          aggregate: {
            args: Prisma.PerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformance>
          }
          groupBy: {
            args: Prisma.PerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCountAggregateOutputType> | number
          }
        }
      }
      ArtistMedia: {
        payload: Prisma.$ArtistMediaPayload<ExtArgs>
        fields: Prisma.ArtistMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          findFirst: {
            args: Prisma.ArtistMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          findMany: {
            args: Prisma.ArtistMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>[]
          }
          create: {
            args: Prisma.ArtistMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          createMany: {
            args: Prisma.ArtistMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>[]
          }
          delete: {
            args: Prisma.ArtistMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          update: {
            args: Prisma.ArtistMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          deleteMany: {
            args: Prisma.ArtistMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>[]
          }
          upsert: {
            args: Prisma.ArtistMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistMediaPayload>
          }
          aggregate: {
            args: Prisma.ArtistMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtistMedia>
          }
          groupBy: {
            args: Prisma.ArtistMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistMediaCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      UserFollow: {
        payload: Prisma.$UserFollowPayload<ExtArgs>
        fields: Prisma.UserFollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findFirst: {
            args: Prisma.UserFollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findMany: {
            args: Prisma.UserFollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          create: {
            args: Prisma.UserFollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          createMany: {
            args: Prisma.UserFollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          delete: {
            args: Prisma.UserFollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          update: {
            args: Prisma.UserFollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          deleteMany: {
            args: Prisma.UserFollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          upsert: {
            args: Prisma.UserFollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          aggregate: {
            args: Prisma.UserFollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFollow>
          }
          groupBy: {
            args: Prisma.UserFollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFollowCountArgs<ExtArgs>
            result: $Utils.Optional<UserFollowCountAggregateOutputType> | number
          }
        }
      }
      FeedItem: {
        payload: Prisma.$FeedItemPayload<ExtArgs>
        fields: Prisma.FeedItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          findFirst: {
            args: Prisma.FeedItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          findMany: {
            args: Prisma.FeedItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>[]
          }
          create: {
            args: Prisma.FeedItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          createMany: {
            args: Prisma.FeedItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>[]
          }
          delete: {
            args: Prisma.FeedItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          update: {
            args: Prisma.FeedItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          deleteMany: {
            args: Prisma.FeedItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>[]
          }
          upsert: {
            args: Prisma.FeedItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedItemPayload>
          }
          aggregate: {
            args: Prisma.FeedItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedItem>
          }
          groupBy: {
            args: Prisma.FeedItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedItemCountArgs<ExtArgs>
            result: $Utils.Optional<FeedItemCountAggregateOutputType> | number
          }
        }
      }
      FeedLike: {
        payload: Prisma.$FeedLikePayload<ExtArgs>
        fields: Prisma.FeedLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          findFirst: {
            args: Prisma.FeedLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          findMany: {
            args: Prisma.FeedLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>[]
          }
          create: {
            args: Prisma.FeedLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          createMany: {
            args: Prisma.FeedLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>[]
          }
          delete: {
            args: Prisma.FeedLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          update: {
            args: Prisma.FeedLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          deleteMany: {
            args: Prisma.FeedLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>[]
          }
          upsert: {
            args: Prisma.FeedLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedLikePayload>
          }
          aggregate: {
            args: Prisma.FeedLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedLike>
          }
          groupBy: {
            args: Prisma.FeedLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedLikeCountArgs<ExtArgs>
            result: $Utils.Optional<FeedLikeCountAggregateOutputType> | number
          }
        }
      }
      FeedComment: {
        payload: Prisma.$FeedCommentPayload<ExtArgs>
        fields: Prisma.FeedCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          findFirst: {
            args: Prisma.FeedCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          findMany: {
            args: Prisma.FeedCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>[]
          }
          create: {
            args: Prisma.FeedCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          createMany: {
            args: Prisma.FeedCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>[]
          }
          delete: {
            args: Prisma.FeedCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          update: {
            args: Prisma.FeedCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          deleteMany: {
            args: Prisma.FeedCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>[]
          }
          upsert: {
            args: Prisma.FeedCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedCommentPayload>
          }
          aggregate: {
            args: Prisma.FeedCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedComment>
          }
          groupBy: {
            args: Prisma.FeedCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedCommentCountArgs<ExtArgs>
            result: $Utils.Optional<FeedCommentCountAggregateOutputType> | number
          }
        }
      }
      IdentityVerification: {
        payload: Prisma.$IdentityVerificationPayload<ExtArgs>
        fields: Prisma.IdentityVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentityVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentityVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          findFirst: {
            args: Prisma.IdentityVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentityVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          findMany: {
            args: Prisma.IdentityVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>[]
          }
          create: {
            args: Prisma.IdentityVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          createMany: {
            args: Prisma.IdentityVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentityVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>[]
          }
          delete: {
            args: Prisma.IdentityVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          update: {
            args: Prisma.IdentityVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          deleteMany: {
            args: Prisma.IdentityVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentityVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdentityVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>[]
          }
          upsert: {
            args: Prisma.IdentityVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityVerificationPayload>
          }
          aggregate: {
            args: Prisma.IdentityVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentityVerification>
          }
          groupBy: {
            args: Prisma.IdentityVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentityVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentityVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<IdentityVerificationCountAggregateOutputType> | number
          }
        }
      }
      UserPhone: {
        payload: Prisma.$UserPhonePayload<ExtArgs>
        fields: Prisma.UserPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findFirst: {
            args: Prisma.UserPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findMany: {
            args: Prisma.UserPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          create: {
            args: Prisma.UserPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          createMany: {
            args: Prisma.UserPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          delete: {
            args: Prisma.UserPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          update: {
            args: Prisma.UserPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          deleteMany: {
            args: Prisma.UserPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPhoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          upsert: {
            args: Prisma.UserPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          aggregate: {
            args: Prisma.UserPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhone>
          }
          groupBy: {
            args: Prisma.UserPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneCountAggregateOutputType> | number
          }
        }
      }
      UserConsent: {
        payload: Prisma.$UserConsentPayload<ExtArgs>
        fields: Prisma.UserConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findFirst: {
            args: Prisma.UserConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findMany: {
            args: Prisma.UserConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          create: {
            args: Prisma.UserConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          createMany: {
            args: Prisma.UserConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          delete: {
            args: Prisma.UserConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          update: {
            args: Prisma.UserConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          deleteMany: {
            args: Prisma.UserConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          upsert: {
            args: Prisma.UserConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          aggregate: {
            args: Prisma.UserConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConsent>
          }
          groupBy: {
            args: Prisma.UserConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConsentCountArgs<ExtArgs>
            result: $Utils.Optional<UserConsentCountAggregateOutputType> | number
          }
        }
      }
      OnboardingProgress: {
        payload: Prisma.$OnboardingProgressPayload<ExtArgs>
        fields: Prisma.OnboardingProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findFirst: {
            args: Prisma.OnboardingProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findMany: {
            args: Prisma.OnboardingProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          create: {
            args: Prisma.OnboardingProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          createMany: {
            args: Prisma.OnboardingProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          delete: {
            args: Prisma.OnboardingProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          update: {
            args: Prisma.OnboardingProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OnboardingProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          upsert: {
            args: Prisma.OnboardingProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          aggregate: {
            args: Prisma.OnboardingProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingProgress>
          }
          groupBy: {
            args: Prisma.OnboardingProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingProgressCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    user?: UserOmit
    verificationToken?: VerificationTokenOmit
    club?: ClubOmit
    venue?: VenueOmit
    event?: EventOmit
    pRProfile?: PRProfileOmit
    assignment?: AssignmentOmit
    list?: ListOmit
    guest?: GuestOmit
    listEntry?: ListEntryOmit
    ticket?: TicketOmit
    checkIn?: CheckInOmit
    inviteLink?: InviteLinkOmit
    auditLog?: AuditLogOmit
    consumption?: ConsumptionOmit
    funnelTracking?: FunnelTrackingOmit
    eventFeedback?: EventFeedbackOmit
    securityNote?: SecurityNoteOmit
    customerPreferences?: CustomerPreferencesOmit
    organizationProfile?: OrganizationProfileOmit
    organizationMember?: OrganizationMemberOmit
    artistProfile?: ArtistProfileOmit
    performance?: PerformanceOmit
    artistMedia?: ArtistMediaOmit
    userProfile?: UserProfileOmit
    userFollow?: UserFollowOmit
    feedItem?: FeedItemOmit
    feedLike?: FeedLikeOmit
    feedComment?: FeedCommentOmit
    identityVerification?: IdentityVerificationOmit
    userPhone?: UserPhoneOmit
    userConsent?: UserConsentOmit
    onboardingProgress?: OnboardingProgressOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    auditLogs: number
    checkins: number
    eventsCreated: number
    inviteLinks: number
    listEntries: number
    securityReports: number
    ticketsIssued: number
    ticketsOwned: number
    clubsOwned: number
    feedItems: number
    feedLikes: number
    feedComments: number
    followedBy: number
    following: number
    identityVerifications: number
    reviewedVerifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    checkins?: boolean | UserCountOutputTypeCountCheckinsArgs
    eventsCreated?: boolean | UserCountOutputTypeCountEventsCreatedArgs
    inviteLinks?: boolean | UserCountOutputTypeCountInviteLinksArgs
    listEntries?: boolean | UserCountOutputTypeCountListEntriesArgs
    securityReports?: boolean | UserCountOutputTypeCountSecurityReportsArgs
    ticketsIssued?: boolean | UserCountOutputTypeCountTicketsIssuedArgs
    ticketsOwned?: boolean | UserCountOutputTypeCountTicketsOwnedArgs
    clubsOwned?: boolean | UserCountOutputTypeCountClubsOwnedArgs
    feedItems?: boolean | UserCountOutputTypeCountFeedItemsArgs
    feedLikes?: boolean | UserCountOutputTypeCountFeedLikesArgs
    feedComments?: boolean | UserCountOutputTypeCountFeedCommentsArgs
    followedBy?: boolean | UserCountOutputTypeCountFollowedByArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    identityVerifications?: boolean | UserCountOutputTypeCountIdentityVerificationsArgs
    reviewedVerifications?: boolean | UserCountOutputTypeCountReviewedVerificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSecurityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsIssuedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClubsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIdentityVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityVerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityVerificationWhereInput
  }


  /**
   * Count Type ClubCountOutputType
   */

  export type ClubCountOutputType = {
    venues: number
  }

  export type ClubCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venues?: boolean | ClubCountOutputTypeCountVenuesArgs
  }

  // Custom InputTypes
  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubCountOutputType
     */
    select?: ClubCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    events: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | VenueCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    assignments: number
    consumptions: number
    feedbacks: number
    funnelTracking: number
    inviteLinks: number
    lists: number
    securityNotes: number
    tickets: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | EventCountOutputTypeCountAssignmentsArgs
    consumptions?: boolean | EventCountOutputTypeCountConsumptionsArgs
    feedbacks?: boolean | EventCountOutputTypeCountFeedbacksArgs
    funnelTracking?: boolean | EventCountOutputTypeCountFunnelTrackingArgs
    inviteLinks?: boolean | EventCountOutputTypeCountInviteLinksArgs
    lists?: boolean | EventCountOutputTypeCountListsArgs
    securityNotes?: boolean | EventCountOutputTypeCountSecurityNotesArgs
    tickets?: boolean | EventCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountConsumptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsumptionWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventFeedbackWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountFunnelTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelTrackingWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSecurityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityNoteWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type PRProfileCountOutputType
   */

  export type PRProfileCountOutputType = {
    assignments: number
    inviteLinks: number
  }

  export type PRProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | PRProfileCountOutputTypeCountAssignmentsArgs
    inviteLinks?: boolean | PRProfileCountOutputTypeCountInviteLinksArgs
  }

  // Custom InputTypes
  /**
   * PRProfileCountOutputType without action
   */
  export type PRProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfileCountOutputType
     */
    select?: PRProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PRProfileCountOutputType without action
   */
  export type PRProfileCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * PRProfileCountOutputType without action
   */
  export type PRProfileCountOutputTypeCountInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
  }


  /**
   * Count Type ListCountOutputType
   */

  export type ListCountOutputType = {
    entries: number
  }

  export type ListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | ListCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListCountOutputType
     */
    select?: ListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListCountOutputType without action
   */
  export type ListCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
  }


  /**
   * Count Type GuestCountOutputType
   */

  export type GuestCountOutputType = {
    feedbacks: number
    listEntries: number
    securityNotes: number
    tickets: number
  }

  export type GuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | GuestCountOutputTypeCountFeedbacksArgs
    listEntries?: boolean | GuestCountOutputTypeCountListEntriesArgs
    securityNotes?: boolean | GuestCountOutputTypeCountSecurityNotesArgs
    tickets?: boolean | GuestCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestCountOutputType
     */
    select?: GuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventFeedbackWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountListEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountSecurityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityNoteWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type ListEntryCountOutputType
   */

  export type ListEntryCountOutputType = {
    tickets: number
  }

  export type ListEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | ListEntryCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ListEntryCountOutputType without action
   */
  export type ListEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntryCountOutputType
     */
    select?: ListEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListEntryCountOutputType without action
   */
  export type ListEntryCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    checkins: number
    consumptions: number
    feedbacks: number
    securityNotes: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | TicketCountOutputTypeCountCheckinsArgs
    consumptions?: boolean | TicketCountOutputTypeCountConsumptionsArgs
    feedbacks?: boolean | TicketCountOutputTypeCountFeedbacksArgs
    securityNotes?: boolean | TicketCountOutputTypeCountSecurityNotesArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountConsumptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsumptionWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventFeedbackWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountSecurityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityNoteWhereInput
  }


  /**
   * Count Type OrganizationProfileCountOutputType
   */

  export type OrganizationProfileCountOutputType = {
    teamMembers: number
  }

  export type OrganizationProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | OrganizationProfileCountOutputTypeCountTeamMembersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationProfileCountOutputType without action
   */
  export type OrganizationProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfileCountOutputType
     */
    select?: OrganizationProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationProfileCountOutputType without action
   */
  export type OrganizationProfileCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }


  /**
   * Count Type ArtistProfileCountOutputType
   */

  export type ArtistProfileCountOutputType = {
    performances: number
    mediaGallery: number
  }

  export type ArtistProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performances?: boolean | ArtistProfileCountOutputTypeCountPerformancesArgs
    mediaGallery?: boolean | ArtistProfileCountOutputTypeCountMediaGalleryArgs
  }

  // Custom InputTypes
  /**
   * ArtistProfileCountOutputType without action
   */
  export type ArtistProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfileCountOutputType
     */
    select?: ArtistProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtistProfileCountOutputType without action
   */
  export type ArtistProfileCountOutputTypeCountPerformancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceWhereInput
  }

  /**
   * ArtistProfileCountOutputType without action
   */
  export type ArtistProfileCountOutputTypeCountMediaGalleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistMediaWhereInput
  }


  /**
   * Count Type FeedItemCountOutputType
   */

  export type FeedItemCountOutputType = {
    likes: number
    comments: number
  }

  export type FeedItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | FeedItemCountOutputTypeCountLikesArgs
    comments?: boolean | FeedItemCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * FeedItemCountOutputType without action
   */
  export type FeedItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItemCountOutputType
     */
    select?: FeedItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeedItemCountOutputType without action
   */
  export type FeedItemCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedLikeWhereInput
  }

  /**
   * FeedItemCountOutputType without action
   */
  export type FeedItemCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    username: string | null
    displayName: string | null
    birthDate: Date | null
    age: number | null
    ageVerified: boolean | null
    ageConsent: boolean | null
    identityVerified: boolean | null
    identityVerifiedAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    username: string | null
    displayName: string | null
    birthDate: Date | null
    age: number | null
    ageVerified: boolean | null
    ageConsent: boolean | null
    identityVerified: boolean | null
    identityVerifiedAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    passwordHash: number
    role: number
    phone: number
    firstName: number
    lastName: number
    middleName: number
    username: number
    displayName: number
    birthDate: number
    age: number
    ageVerified: number
    ageConsent: number
    identityVerified: number
    identityVerifiedAt: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    age?: true
  }

  export type UserSumAggregateInputType = {
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    role?: true
    phone?: true
    firstName?: true
    lastName?: true
    middleName?: true
    username?: true
    displayName?: true
    birthDate?: true
    age?: true
    ageVerified?: true
    ageConsent?: true
    identityVerified?: true
    identityVerifiedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    role?: true
    phone?: true
    firstName?: true
    lastName?: true
    middleName?: true
    username?: true
    displayName?: true
    birthDate?: true
    age?: true
    ageVerified?: true
    ageConsent?: true
    identityVerified?: true
    identityVerifiedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    role?: true
    phone?: true
    firstName?: true
    lastName?: true
    middleName?: true
    username?: true
    displayName?: true
    birthDate?: true
    age?: true
    ageVerified?: true
    ageConsent?: true
    identityVerified?: true
    identityVerifiedAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    passwordHash: string | null
    role: $Enums.UserRole
    phone: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    username: string | null
    displayName: string | null
    birthDate: Date | null
    age: number | null
    ageVerified: boolean
    ageConsent: boolean
    identityVerified: boolean
    identityVerifiedAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    username?: boolean
    displayName?: boolean
    birthDate?: boolean
    age?: boolean
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    checkins?: boolean | User$checkinsArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    inviteLinks?: boolean | User$inviteLinksArgs<ExtArgs>
    listEntries?: boolean | User$listEntriesArgs<ExtArgs>
    prProfile?: boolean | User$prProfileArgs<ExtArgs>
    securityReports?: boolean | User$securityReportsArgs<ExtArgs>
    ticketsIssued?: boolean | User$ticketsIssuedArgs<ExtArgs>
    ticketsOwned?: boolean | User$ticketsOwnedArgs<ExtArgs>
    clubsOwned?: boolean | User$clubsOwnedArgs<ExtArgs>
    organizationProfile?: boolean | User$organizationProfileArgs<ExtArgs>
    artistProfile?: boolean | User$artistProfileArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    feedItems?: boolean | User$feedItemsArgs<ExtArgs>
    feedLikes?: boolean | User$feedLikesArgs<ExtArgs>
    feedComments?: boolean | User$feedCommentsArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    identityVerifications?: boolean | User$identityVerificationsArgs<ExtArgs>
    reviewedVerifications?: boolean | User$reviewedVerificationsArgs<ExtArgs>
    phoneVerification?: boolean | User$phoneVerificationArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    onboardingProgress?: boolean | User$onboardingProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    username?: boolean
    displayName?: boolean
    birthDate?: boolean
    age?: boolean
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    username?: boolean
    displayName?: boolean
    birthDate?: boolean
    age?: boolean
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    role?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    username?: boolean
    displayName?: boolean
    birthDate?: boolean
    age?: boolean
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "passwordHash" | "role" | "phone" | "firstName" | "lastName" | "middleName" | "username" | "displayName" | "birthDate" | "age" | "ageVerified" | "ageConsent" | "identityVerified" | "identityVerifiedAt" | "resetToken" | "resetTokenExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    checkins?: boolean | User$checkinsArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    inviteLinks?: boolean | User$inviteLinksArgs<ExtArgs>
    listEntries?: boolean | User$listEntriesArgs<ExtArgs>
    prProfile?: boolean | User$prProfileArgs<ExtArgs>
    securityReports?: boolean | User$securityReportsArgs<ExtArgs>
    ticketsIssued?: boolean | User$ticketsIssuedArgs<ExtArgs>
    ticketsOwned?: boolean | User$ticketsOwnedArgs<ExtArgs>
    clubsOwned?: boolean | User$clubsOwnedArgs<ExtArgs>
    organizationProfile?: boolean | User$organizationProfileArgs<ExtArgs>
    artistProfile?: boolean | User$artistProfileArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    feedItems?: boolean | User$feedItemsArgs<ExtArgs>
    feedLikes?: boolean | User$feedLikesArgs<ExtArgs>
    feedComments?: boolean | User$feedCommentsArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    identityVerifications?: boolean | User$identityVerificationsArgs<ExtArgs>
    reviewedVerifications?: boolean | User$reviewedVerificationsArgs<ExtArgs>
    phoneVerification?: boolean | User$phoneVerificationArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    onboardingProgress?: boolean | User$onboardingProgressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      checkins: Prisma.$CheckInPayload<ExtArgs>[]
      eventsCreated: Prisma.$EventPayload<ExtArgs>[]
      inviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
      listEntries: Prisma.$ListEntryPayload<ExtArgs>[]
      prProfile: Prisma.$PRProfilePayload<ExtArgs> | null
      securityReports: Prisma.$SecurityNotePayload<ExtArgs>[]
      ticketsIssued: Prisma.$TicketPayload<ExtArgs>[]
      ticketsOwned: Prisma.$TicketPayload<ExtArgs>[]
      clubsOwned: Prisma.$ClubPayload<ExtArgs>[]
      organizationProfile: Prisma.$OrganizationProfilePayload<ExtArgs> | null
      artistProfile: Prisma.$ArtistProfilePayload<ExtArgs> | null
      userProfile: Prisma.$UserProfilePayload<ExtArgs> | null
      feedItems: Prisma.$FeedItemPayload<ExtArgs>[]
      feedLikes: Prisma.$FeedLikePayload<ExtArgs>[]
      feedComments: Prisma.$FeedCommentPayload<ExtArgs>[]
      followedBy: Prisma.$UserFollowPayload<ExtArgs>[]
      following: Prisma.$UserFollowPayload<ExtArgs>[]
      identityVerifications: Prisma.$IdentityVerificationPayload<ExtArgs>[]
      reviewedVerifications: Prisma.$IdentityVerificationPayload<ExtArgs>[]
      phoneVerification: Prisma.$UserPhonePayload<ExtArgs> | null
      consents: Prisma.$UserConsentPayload<ExtArgs> | null
      onboardingProgress: Prisma.$OnboardingProgressPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      passwordHash: string | null
      role: $Enums.UserRole
      phone: string | null
      firstName: string | null
      lastName: string | null
      middleName: string | null
      username: string | null
      displayName: string | null
      birthDate: Date | null
      age: number | null
      ageVerified: boolean
      ageConsent: boolean
      identityVerified: boolean
      identityVerifiedAt: Date | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkins<T extends User$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, User$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventsCreated<T extends User$eventsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviteLinks<T extends User$inviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$inviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listEntries<T extends User$listEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$listEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prProfile<T extends User$prProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$prProfileArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    securityReports<T extends User$securityReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$securityReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketsIssued<T extends User$ticketsIssuedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsIssuedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketsOwned<T extends User$ticketsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clubsOwned<T extends User$clubsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, User$clubsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizationProfile<T extends User$organizationProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationProfileArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    artistProfile<T extends User$artistProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$artistProfileArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends User$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$userProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedItems<T extends User$feedItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedLikes<T extends User$feedLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$feedLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedComments<T extends User$feedCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followedBy<T extends User$followedByArgs<ExtArgs> = {}>(args?: Subset<T, User$followedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    identityVerifications<T extends User$identityVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$identityVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedVerifications<T extends User$reviewedVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phoneVerification<T extends User$phoneVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$phoneVerificationArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    consents<T extends User$consentsArgs<ExtArgs> = {}>(args?: Subset<T, User$consentsArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    onboardingProgress<T extends User$onboardingProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingProgressArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly phone: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly age: FieldRef<"User", 'Int'>
    readonly ageVerified: FieldRef<"User", 'Boolean'>
    readonly ageConsent: FieldRef<"User", 'Boolean'>
    readonly identityVerified: FieldRef<"User", 'Boolean'>
    readonly identityVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.checkins
   */
  export type User$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * User.eventsCreated
   */
  export type User$eventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.inviteLinks
   */
  export type User$inviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * User.listEntries
   */
  export type User$listEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    cursor?: ListEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * User.prProfile
   */
  export type User$prProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    where?: PRProfileWhereInput
  }

  /**
   * User.securityReports
   */
  export type User$securityReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    where?: SecurityNoteWhereInput
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    cursor?: SecurityNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * User.ticketsIssued
   */
  export type User$ticketsIssuedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketsOwned
   */
  export type User$ticketsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.clubsOwned
   */
  export type User$clubsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    cursor?: ClubWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * User.organizationProfile
   */
  export type User$organizationProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    where?: OrganizationProfileWhereInput
  }

  /**
   * User.artistProfile
   */
  export type User$artistProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    where?: ArtistProfileWhereInput
  }

  /**
   * User.userProfile
   */
  export type User$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.feedItems
   */
  export type User$feedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    where?: FeedItemWhereInput
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    cursor?: FeedItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * User.feedLikes
   */
  export type User$feedLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    where?: FeedLikeWhereInput
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    cursor?: FeedLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedLikeScalarFieldEnum | FeedLikeScalarFieldEnum[]
  }

  /**
   * User.feedComments
   */
  export type User$feedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    where?: FeedCommentWhereInput
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    cursor?: FeedCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedCommentScalarFieldEnum | FeedCommentScalarFieldEnum[]
  }

  /**
   * User.followedBy
   */
  export type User$followedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.identityVerifications
   */
  export type User$identityVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    where?: IdentityVerificationWhereInput
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    cursor?: IdentityVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentityVerificationScalarFieldEnum | IdentityVerificationScalarFieldEnum[]
  }

  /**
   * User.reviewedVerifications
   */
  export type User$reviewedVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    where?: IdentityVerificationWhereInput
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    cursor?: IdentityVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentityVerificationScalarFieldEnum | IdentityVerificationScalarFieldEnum[]
  }

  /**
   * User.phoneVerification
   */
  export type User$phoneVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    where?: UserPhoneWhereInput
  }

  /**
   * User.consents
   */
  export type User$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    where?: UserConsentWhereInput
  }

  /**
   * User.onboardingProgress
   */
  export type User$onboardingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    where?: OnboardingProgressWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Club
   */

  export type AggregateClub = {
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  export type ClubMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ClubType | null
    description: string | null
    logo: string | null
    coverImage: string | null
    website: string | null
    phone: string | null
    email: string | null
    instagram: string | null
    facebook: string | null
    openingHours: string | null
    priceRange: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ClubType | null
    description: string | null
    logo: string | null
    coverImage: string | null
    website: string | null
    phone: string | null
    email: string | null
    instagram: string | null
    facebook: string | null
    openingHours: string | null
    priceRange: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    logo: number
    coverImage: number
    gallery: number
    website: number
    phone: number
    email: number
    instagram: number
    facebook: number
    openingHours: number
    priceRange: number
    amenities: number
    musicGenres: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClubMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    logo?: true
    coverImage?: true
    website?: true
    phone?: true
    email?: true
    instagram?: true
    facebook?: true
    openingHours?: true
    priceRange?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    logo?: true
    coverImage?: true
    website?: true
    phone?: true
    email?: true
    instagram?: true
    facebook?: true
    openingHours?: true
    priceRange?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    logo?: true
    coverImage?: true
    gallery?: true
    website?: true
    phone?: true
    email?: true
    instagram?: true
    facebook?: true
    openingHours?: true
    priceRange?: true
    amenities?: true
    musicGenres?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Club to aggregate.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clubs
    **/
    _count?: true | ClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubMaxAggregateInputType
  }

  export type GetClubAggregateType<T extends ClubAggregateArgs> = {
        [P in keyof T & keyof AggregateClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClub[P]>
      : GetScalarType<T[P], AggregateClub[P]>
  }




  export type ClubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithAggregationInput | ClubOrderByWithAggregationInput[]
    by: ClubScalarFieldEnum[] | ClubScalarFieldEnum
    having?: ClubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubCountAggregateInputType | true
    _min?: ClubMinAggregateInputType
    _max?: ClubMaxAggregateInputType
  }

  export type ClubGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ClubType
    description: string | null
    logo: string | null
    coverImage: string | null
    gallery: string[]
    website: string | null
    phone: string | null
    email: string | null
    instagram: string | null
    facebook: string | null
    openingHours: string | null
    priceRange: string | null
    amenities: string[]
    musicGenres: string[]
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  type GetClubGroupByPayload<T extends ClubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubGroupByOutputType[P]>
            : GetScalarType<T[P], ClubGroupByOutputType[P]>
        }
      >
    >


  export type ClubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    gallery?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    instagram?: boolean
    facebook?: boolean
    openingHours?: boolean
    priceRange?: boolean
    amenities?: boolean
    musicGenres?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    venues?: boolean | Club$venuesArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    gallery?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    instagram?: boolean
    facebook?: boolean
    openingHours?: boolean
    priceRange?: boolean
    amenities?: boolean
    musicGenres?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    gallery?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    instagram?: boolean
    facebook?: boolean
    openingHours?: boolean
    priceRange?: boolean
    amenities?: boolean
    musicGenres?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    logo?: boolean
    coverImage?: boolean
    gallery?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    instagram?: boolean
    facebook?: boolean
    openingHours?: boolean
    priceRange?: boolean
    amenities?: boolean
    musicGenres?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClubOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "logo" | "coverImage" | "gallery" | "website" | "phone" | "email" | "instagram" | "facebook" | "openingHours" | "priceRange" | "amenities" | "musicGenres" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["club"]>
  export type ClubInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    venues?: boolean | Club$venuesArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClubIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Club"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      venues: Prisma.$VenuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ClubType
      description: string | null
      logo: string | null
      coverImage: string | null
      gallery: string[]
      website: string | null
      phone: string | null
      email: string | null
      instagram: string | null
      facebook: string | null
      openingHours: string | null
      priceRange: string | null
      amenities: string[]
      musicGenres: string[]
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["club"]>
    composites: {}
  }

  type ClubGetPayload<S extends boolean | null | undefined | ClubDefaultArgs> = $Result.GetResult<Prisma.$ClubPayload, S>

  type ClubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubCountAggregateInputType | true
    }

  export interface ClubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Club'], meta: { name: 'Club' } }
    /**
     * Find zero or one Club that matches the filter.
     * @param {ClubFindUniqueArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubFindUniqueArgs>(args: SelectSubset<T, ClubFindUniqueArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Club that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubFindUniqueOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubFindFirstArgs>(args?: SelectSubset<T, ClubFindFirstArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clubs
     * const clubs = await prisma.club.findMany()
     * 
     * // Get first 10 Clubs
     * const clubs = await prisma.club.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubWithIdOnly = await prisma.club.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubFindManyArgs>(args?: SelectSubset<T, ClubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Club.
     * @param {ClubCreateArgs} args - Arguments to create a Club.
     * @example
     * // Create one Club
     * const Club = await prisma.club.create({
     *   data: {
     *     // ... data to create a Club
     *   }
     * })
     * 
     */
    create<T extends ClubCreateArgs>(args: SelectSubset<T, ClubCreateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clubs.
     * @param {ClubCreateManyArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubCreateManyArgs>(args?: SelectSubset<T, ClubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clubs and returns the data saved in the database.
     * @param {ClubCreateManyAndReturnArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clubs and only return the `id`
     * const clubWithIdOnly = await prisma.club.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Club.
     * @param {ClubDeleteArgs} args - Arguments to delete one Club.
     * @example
     * // Delete one Club
     * const Club = await prisma.club.delete({
     *   where: {
     *     // ... filter to delete one Club
     *   }
     * })
     * 
     */
    delete<T extends ClubDeleteArgs>(args: SelectSubset<T, ClubDeleteArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Club.
     * @param {ClubUpdateArgs} args - Arguments to update one Club.
     * @example
     * // Update one Club
     * const club = await prisma.club.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubUpdateArgs>(args: SelectSubset<T, ClubUpdateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clubs.
     * @param {ClubDeleteManyArgs} args - Arguments to filter Clubs to delete.
     * @example
     * // Delete a few Clubs
     * const { count } = await prisma.club.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubDeleteManyArgs>(args?: SelectSubset<T, ClubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubUpdateManyArgs>(args: SelectSubset<T, ClubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs and returns the data updated in the database.
     * @param {ClubUpdateManyAndReturnArgs} args - Arguments to update many Clubs.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clubs and only return the `id`
     * const clubWithIdOnly = await prisma.club.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Club.
     * @param {ClubUpsertArgs} args - Arguments to update or create a Club.
     * @example
     * // Update or create a Club
     * const club = await prisma.club.upsert({
     *   create: {
     *     // ... data to create a Club
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Club we want to update
     *   }
     * })
     */
    upsert<T extends ClubUpsertArgs>(args: SelectSubset<T, ClubUpsertArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubCountArgs} args - Arguments to filter Clubs to count.
     * @example
     * // Count the number of Clubs
     * const count = await prisma.club.count({
     *   where: {
     *     // ... the filter for the Clubs we want to count
     *   }
     * })
    **/
    count<T extends ClubCountArgs>(
      args?: Subset<T, ClubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubAggregateArgs>(args: Subset<T, ClubAggregateArgs>): Prisma.PrismaPromise<GetClubAggregateType<T>>

    /**
     * Group by Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubGroupByArgs['orderBy'] }
        : { orderBy?: ClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Club model
   */
  readonly fields: ClubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Club.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venues<T extends Club$venuesArgs<ExtArgs> = {}>(args?: Subset<T, Club$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Club model
   */
  interface ClubFieldRefs {
    readonly id: FieldRef<"Club", 'String'>
    readonly name: FieldRef<"Club", 'String'>
    readonly type: FieldRef<"Club", 'ClubType'>
    readonly description: FieldRef<"Club", 'String'>
    readonly logo: FieldRef<"Club", 'String'>
    readonly coverImage: FieldRef<"Club", 'String'>
    readonly gallery: FieldRef<"Club", 'String[]'>
    readonly website: FieldRef<"Club", 'String'>
    readonly phone: FieldRef<"Club", 'String'>
    readonly email: FieldRef<"Club", 'String'>
    readonly instagram: FieldRef<"Club", 'String'>
    readonly facebook: FieldRef<"Club", 'String'>
    readonly openingHours: FieldRef<"Club", 'String'>
    readonly priceRange: FieldRef<"Club", 'String'>
    readonly amenities: FieldRef<"Club", 'String[]'>
    readonly musicGenres: FieldRef<"Club", 'String[]'>
    readonly ownerId: FieldRef<"Club", 'String'>
    readonly createdAt: FieldRef<"Club", 'DateTime'>
    readonly updatedAt: FieldRef<"Club", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Club findUnique
   */
  export type ClubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findUniqueOrThrow
   */
  export type ClubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findFirst
   */
  export type ClubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findFirstOrThrow
   */
  export type ClubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findMany
   */
  export type ClubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Clubs to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club create
   */
  export type ClubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to create a Club.
     */
    data: XOR<ClubCreateInput, ClubUncheckedCreateInput>
  }

  /**
   * Club createMany
   */
  export type ClubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Club createManyAndReturn
   */
  export type ClubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club update
   */
  export type ClubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to update a Club.
     */
    data: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
    /**
     * Choose, which Club to update.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club updateMany
   */
  export type ClubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
  }

  /**
   * Club updateManyAndReturn
   */
  export type ClubUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club upsert
   */
  export type ClubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The filter to search for the Club to update in case it exists.
     */
    where: ClubWhereUniqueInput
    /**
     * In case the Club found by the `where` argument doesn't exist, create a new Club with this data.
     */
    create: XOR<ClubCreateInput, ClubUncheckedCreateInput>
    /**
     * In case the Club was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
  }

  /**
   * Club delete
   */
  export type ClubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter which Club to delete.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club deleteMany
   */
  export type ClubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clubs to delete
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to delete.
     */
    limit?: number
  }

  /**
   * Club.venues
   */
  export type Club$venuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Club without action
   */
  export type ClubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    capacity: number | null
  }

  export type VenueSumAggregateOutputType = {
    capacity: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    address: string | null
    city: string | null
    capacity: number | null
    whatsappNumber: string | null
    telegramHandle: string | null
    clubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    address: string | null
    city: string | null
    capacity: number | null
    whatsappNumber: string | null
    telegramHandle: string | null
    clubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    address: number
    city: number
    capacity: number
    whatsappNumber: number
    telegramHandle: number
    clubId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    capacity?: true
  }

  export type VenueSumAggregateInputType = {
    capacity?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    capacity?: true
    whatsappNumber?: true
    telegramHandle?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    capacity?: true
    whatsappNumber?: true
    telegramHandle?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    address?: true
    city?: true
    capacity?: true
    whatsappNumber?: true
    telegramHandle?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    address: string
    city: string
    capacity: number | null
    whatsappNumber: string | null
    telegramHandle: string | null
    clubId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    capacity?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | Venue$clubArgs<ExtArgs>
    events?: boolean | Venue$eventsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    capacity?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | Venue$clubArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    capacity?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | Venue$clubArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    city?: boolean
    capacity?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "address" | "city" | "capacity" | "whatsappNumber" | "telegramHandle" | "clubId" | "createdAt" | "updatedAt", ExtArgs["result"]["venue"]>
  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | Venue$clubArgs<ExtArgs>
    events?: boolean | Venue$eventsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | Venue$clubArgs<ExtArgs>
  }
  export type VenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | Venue$clubArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      club: Prisma.$ClubPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      address: string
      city: string
      capacity: number | null
      whatsappNumber: string | null
      telegramHandle: string | null
      clubId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Venues and returns the data saved in the database.
     * @param {VenueCreateManyAndReturnArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues and returns the data updated in the database.
     * @param {VenueUpdateManyAndReturnArgs} args - Arguments to update many Venues.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenueUpdateManyAndReturnArgs>(args: SelectSubset<T, VenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club<T extends Venue$clubArgs<ExtArgs> = {}>(args?: Subset<T, Venue$clubArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends Venue$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'String'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly slug: FieldRef<"Venue", 'String'>
    readonly address: FieldRef<"Venue", 'String'>
    readonly city: FieldRef<"Venue", 'String'>
    readonly capacity: FieldRef<"Venue", 'Int'>
    readonly whatsappNumber: FieldRef<"Venue", 'String'>
    readonly telegramHandle: FieldRef<"Venue", 'String'>
    readonly clubId: FieldRef<"Venue", 'String'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly updatedAt: FieldRef<"Venue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue createManyAndReturn
   */
  export type VenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue updateManyAndReturn
   */
  export type VenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to delete.
     */
    limit?: number
  }

  /**
   * Venue.club
   */
  export type Venue$clubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
  }

  /**
   * Venue.events
   */
  export type Venue$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    minAge: number | null
  }

  export type EventSumAggregateOutputType = {
    minAge: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coverUrl: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.EventStatus | null
    minAge: number | null
    dressCode: string | null
    venueId: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    coverUrl: string | null
    dateStart: Date | null
    dateEnd: Date | null
    status: $Enums.EventStatus | null
    minAge: number | null
    dressCode: string | null
    venueId: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    coverUrl: number
    dateStart: number
    dateEnd: number
    status: number
    minAge: number
    dressCode: number
    venueId: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    minAge?: true
  }

  export type EventSumAggregateInputType = {
    minAge?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverUrl?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    minAge?: true
    dressCode?: true
    venueId?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverUrl?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    minAge?: true
    dressCode?: true
    venueId?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    coverUrl?: true
    dateStart?: true
    dateEnd?: true
    status?: true
    minAge?: true
    dressCode?: true
    venueId?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    coverUrl: string | null
    dateStart: Date
    dateEnd: Date | null
    status: $Enums.EventStatus
    minAge: number | null
    dressCode: string | null
    venueId: string
    createdByUserId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coverUrl?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    minAge?: boolean
    dressCode?: boolean
    venueId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | Event$assignmentsArgs<ExtArgs>
    consumptions?: boolean | Event$consumptionsArgs<ExtArgs>
    feedbacks?: boolean | Event$feedbacksArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    funnelTracking?: boolean | Event$funnelTrackingArgs<ExtArgs>
    inviteLinks?: boolean | Event$inviteLinksArgs<ExtArgs>
    lists?: boolean | Event$listsArgs<ExtArgs>
    securityNotes?: boolean | Event$securityNotesArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coverUrl?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    minAge?: boolean
    dressCode?: boolean
    venueId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    coverUrl?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    minAge?: boolean
    dressCode?: boolean
    venueId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    coverUrl?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    status?: boolean
    minAge?: boolean
    dressCode?: boolean
    venueId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "coverUrl" | "dateStart" | "dateEnd" | "status" | "minAge" | "dressCode" | "venueId" | "createdByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Event$assignmentsArgs<ExtArgs>
    consumptions?: boolean | Event$consumptionsArgs<ExtArgs>
    feedbacks?: boolean | Event$feedbacksArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    funnelTracking?: boolean | Event$funnelTrackingArgs<ExtArgs>
    inviteLinks?: boolean | Event$inviteLinksArgs<ExtArgs>
    lists?: boolean | Event$listsArgs<ExtArgs>
    securityNotes?: boolean | Event$securityNotesArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      consumptions: Prisma.$ConsumptionPayload<ExtArgs>[]
      feedbacks: Prisma.$EventFeedbackPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
      funnelTracking: Prisma.$FunnelTrackingPayload<ExtArgs>[]
      inviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
      lists: Prisma.$ListPayload<ExtArgs>[]
      securityNotes: Prisma.$SecurityNotePayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      coverUrl: string | null
      dateStart: Date
      dateEnd: Date | null
      status: $Enums.EventStatus
      minAge: number | null
      dressCode: string | null
      venueId: string
      createdByUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Event$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Event$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consumptions<T extends Event$consumptionsArgs<ExtArgs> = {}>(args?: Subset<T, Event$consumptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Event$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Event$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    funnelTracking<T extends Event$funnelTrackingArgs<ExtArgs> = {}>(args?: Subset<T, Event$funnelTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviteLinks<T extends Event$inviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, Event$inviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lists<T extends Event$listsArgs<ExtArgs> = {}>(args?: Subset<T, Event$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityNotes<T extends Event$securityNotesArgs<ExtArgs> = {}>(args?: Subset<T, Event$securityNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Event$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Event$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly coverUrl: FieldRef<"Event", 'String'>
    readonly dateStart: FieldRef<"Event", 'DateTime'>
    readonly dateEnd: FieldRef<"Event", 'DateTime'>
    readonly status: FieldRef<"Event", 'EventStatus'>
    readonly minAge: FieldRef<"Event", 'Int'>
    readonly dressCode: FieldRef<"Event", 'String'>
    readonly venueId: FieldRef<"Event", 'String'>
    readonly createdByUserId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.assignments
   */
  export type Event$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Event.consumptions
   */
  export type Event$consumptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    where?: ConsumptionWhereInput
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    cursor?: ConsumptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsumptionScalarFieldEnum | ConsumptionScalarFieldEnum[]
  }

  /**
   * Event.feedbacks
   */
  export type Event$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    where?: EventFeedbackWhereInput
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    cursor?: EventFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * Event.funnelTracking
   */
  export type Event$funnelTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    where?: FunnelTrackingWhereInput
    orderBy?: FunnelTrackingOrderByWithRelationInput | FunnelTrackingOrderByWithRelationInput[]
    cursor?: FunnelTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelTrackingScalarFieldEnum | FunnelTrackingScalarFieldEnum[]
  }

  /**
   * Event.inviteLinks
   */
  export type Event$inviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * Event.lists
   */
  export type Event$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    where?: ListWhereInput
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    cursor?: ListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * Event.securityNotes
   */
  export type Event$securityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    where?: SecurityNoteWhereInput
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    cursor?: SecurityNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * Event.tickets
   */
  export type Event$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model PRProfile
   */

  export type AggregatePRProfile = {
    _count: PRProfileCountAggregateOutputType | null
    _min: PRProfileMinAggregateOutputType | null
    _max: PRProfileMaxAggregateOutputType | null
  }

  export type PRProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    referralCode: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PRProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    referralCode: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PRProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    referralCode: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PRProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    referralCode?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PRProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    referralCode?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PRProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    referralCode?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PRProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRProfile to aggregate.
     */
    where?: PRProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRProfiles to fetch.
     */
    orderBy?: PRProfileOrderByWithRelationInput | PRProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRProfiles
    **/
    _count?: true | PRProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRProfileMaxAggregateInputType
  }

  export type GetPRProfileAggregateType<T extends PRProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePRProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRProfile[P]>
      : GetScalarType<T[P], AggregatePRProfile[P]>
  }




  export type PRProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRProfileWhereInput
    orderBy?: PRProfileOrderByWithAggregationInput | PRProfileOrderByWithAggregationInput[]
    by: PRProfileScalarFieldEnum[] | PRProfileScalarFieldEnum
    having?: PRProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRProfileCountAggregateInputType | true
    _min?: PRProfileMinAggregateInputType
    _max?: PRProfileMaxAggregateInputType
  }

  export type PRProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string | null
    referralCode: string
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: PRProfileCountAggregateOutputType | null
    _min: PRProfileMinAggregateOutputType | null
    _max: PRProfileMaxAggregateOutputType | null
  }

  type GetPRProfileGroupByPayload<T extends PRProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PRProfileGroupByOutputType[P]>
        }
      >
    >


  export type PRProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    referralCode?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | PRProfile$assignmentsArgs<ExtArgs>
    inviteLinks?: boolean | PRProfile$inviteLinksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PRProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRProfile"]>

  export type PRProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    referralCode?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRProfile"]>

  export type PRProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    referralCode?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRProfile"]>

  export type PRProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    referralCode?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PRProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "displayName" | "referralCode" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["pRProfile"]>
  export type PRProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | PRProfile$assignmentsArgs<ExtArgs>
    inviteLinks?: boolean | PRProfile$inviteLinksArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PRProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PRProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PRProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PRProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRProfile"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      inviteLinks: Prisma.$InviteLinkPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string | null
      referralCode: string
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pRProfile"]>
    composites: {}
  }

  type PRProfileGetPayload<S extends boolean | null | undefined | PRProfileDefaultArgs> = $Result.GetResult<Prisma.$PRProfilePayload, S>

  type PRProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PRProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PRProfileCountAggregateInputType | true
    }

  export interface PRProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRProfile'], meta: { name: 'PRProfile' } }
    /**
     * Find zero or one PRProfile that matches the filter.
     * @param {PRProfileFindUniqueArgs} args - Arguments to find a PRProfile
     * @example
     * // Get one PRProfile
     * const pRProfile = await prisma.pRProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRProfileFindUniqueArgs>(args: SelectSubset<T, PRProfileFindUniqueArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PRProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PRProfileFindUniqueOrThrowArgs} args - Arguments to find a PRProfile
     * @example
     * // Get one PRProfile
     * const pRProfile = await prisma.pRProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PRProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileFindFirstArgs} args - Arguments to find a PRProfile
     * @example
     * // Get one PRProfile
     * const pRProfile = await prisma.pRProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRProfileFindFirstArgs>(args?: SelectSubset<T, PRProfileFindFirstArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PRProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileFindFirstOrThrowArgs} args - Arguments to find a PRProfile
     * @example
     * // Get one PRProfile
     * const pRProfile = await prisma.pRProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PRProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PRProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRProfiles
     * const pRProfiles = await prisma.pRProfile.findMany()
     * 
     * // Get first 10 PRProfiles
     * const pRProfiles = await prisma.pRProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRProfileWithIdOnly = await prisma.pRProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PRProfileFindManyArgs>(args?: SelectSubset<T, PRProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PRProfile.
     * @param {PRProfileCreateArgs} args - Arguments to create a PRProfile.
     * @example
     * // Create one PRProfile
     * const PRProfile = await prisma.pRProfile.create({
     *   data: {
     *     // ... data to create a PRProfile
     *   }
     * })
     * 
     */
    create<T extends PRProfileCreateArgs>(args: SelectSubset<T, PRProfileCreateArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PRProfiles.
     * @param {PRProfileCreateManyArgs} args - Arguments to create many PRProfiles.
     * @example
     * // Create many PRProfiles
     * const pRProfile = await prisma.pRProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRProfileCreateManyArgs>(args?: SelectSubset<T, PRProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PRProfiles and returns the data saved in the database.
     * @param {PRProfileCreateManyAndReturnArgs} args - Arguments to create many PRProfiles.
     * @example
     * // Create many PRProfiles
     * const pRProfile = await prisma.pRProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PRProfiles and only return the `id`
     * const pRProfileWithIdOnly = await prisma.pRProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PRProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PRProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PRProfile.
     * @param {PRProfileDeleteArgs} args - Arguments to delete one PRProfile.
     * @example
     * // Delete one PRProfile
     * const PRProfile = await prisma.pRProfile.delete({
     *   where: {
     *     // ... filter to delete one PRProfile
     *   }
     * })
     * 
     */
    delete<T extends PRProfileDeleteArgs>(args: SelectSubset<T, PRProfileDeleteArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PRProfile.
     * @param {PRProfileUpdateArgs} args - Arguments to update one PRProfile.
     * @example
     * // Update one PRProfile
     * const pRProfile = await prisma.pRProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRProfileUpdateArgs>(args: SelectSubset<T, PRProfileUpdateArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PRProfiles.
     * @param {PRProfileDeleteManyArgs} args - Arguments to filter PRProfiles to delete.
     * @example
     * // Delete a few PRProfiles
     * const { count } = await prisma.pRProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRProfileDeleteManyArgs>(args?: SelectSubset<T, PRProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRProfiles
     * const pRProfile = await prisma.pRProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRProfileUpdateManyArgs>(args: SelectSubset<T, PRProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRProfiles and returns the data updated in the database.
     * @param {PRProfileUpdateManyAndReturnArgs} args - Arguments to update many PRProfiles.
     * @example
     * // Update many PRProfiles
     * const pRProfile = await prisma.pRProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PRProfiles and only return the `id`
     * const pRProfileWithIdOnly = await prisma.pRProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PRProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, PRProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PRProfile.
     * @param {PRProfileUpsertArgs} args - Arguments to update or create a PRProfile.
     * @example
     * // Update or create a PRProfile
     * const pRProfile = await prisma.pRProfile.upsert({
     *   create: {
     *     // ... data to create a PRProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRProfile we want to update
     *   }
     * })
     */
    upsert<T extends PRProfileUpsertArgs>(args: SelectSubset<T, PRProfileUpsertArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PRProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileCountArgs} args - Arguments to filter PRProfiles to count.
     * @example
     * // Count the number of PRProfiles
     * const count = await prisma.pRProfile.count({
     *   where: {
     *     // ... the filter for the PRProfiles we want to count
     *   }
     * })
    **/
    count<T extends PRProfileCountArgs>(
      args?: Subset<T, PRProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRProfileAggregateArgs>(args: Subset<T, PRProfileAggregateArgs>): Prisma.PrismaPromise<GetPRProfileAggregateType<T>>

    /**
     * Group by PRProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRProfileGroupByArgs['orderBy'] }
        : { orderBy?: PRProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRProfile model
   */
  readonly fields: PRProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends PRProfile$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, PRProfile$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviteLinks<T extends PRProfile$inviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, PRProfile$inviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRProfile model
   */
  interface PRProfileFieldRefs {
    readonly id: FieldRef<"PRProfile", 'String'>
    readonly userId: FieldRef<"PRProfile", 'String'>
    readonly displayName: FieldRef<"PRProfile", 'String'>
    readonly referralCode: FieldRef<"PRProfile", 'String'>
    readonly phone: FieldRef<"PRProfile", 'String'>
    readonly createdAt: FieldRef<"PRProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"PRProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PRProfile findUnique
   */
  export type PRProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter, which PRProfile to fetch.
     */
    where: PRProfileWhereUniqueInput
  }

  /**
   * PRProfile findUniqueOrThrow
   */
  export type PRProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter, which PRProfile to fetch.
     */
    where: PRProfileWhereUniqueInput
  }

  /**
   * PRProfile findFirst
   */
  export type PRProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter, which PRProfile to fetch.
     */
    where?: PRProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRProfiles to fetch.
     */
    orderBy?: PRProfileOrderByWithRelationInput | PRProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRProfiles.
     */
    cursor?: PRProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRProfiles.
     */
    distinct?: PRProfileScalarFieldEnum | PRProfileScalarFieldEnum[]
  }

  /**
   * PRProfile findFirstOrThrow
   */
  export type PRProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter, which PRProfile to fetch.
     */
    where?: PRProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRProfiles to fetch.
     */
    orderBy?: PRProfileOrderByWithRelationInput | PRProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRProfiles.
     */
    cursor?: PRProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRProfiles.
     */
    distinct?: PRProfileScalarFieldEnum | PRProfileScalarFieldEnum[]
  }

  /**
   * PRProfile findMany
   */
  export type PRProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter, which PRProfiles to fetch.
     */
    where?: PRProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRProfiles to fetch.
     */
    orderBy?: PRProfileOrderByWithRelationInput | PRProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRProfiles.
     */
    cursor?: PRProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRProfiles.
     */
    skip?: number
    distinct?: PRProfileScalarFieldEnum | PRProfileScalarFieldEnum[]
  }

  /**
   * PRProfile create
   */
  export type PRProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a PRProfile.
     */
    data: XOR<PRProfileCreateInput, PRProfileUncheckedCreateInput>
  }

  /**
   * PRProfile createMany
   */
  export type PRProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRProfiles.
     */
    data: PRProfileCreateManyInput | PRProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRProfile createManyAndReturn
   */
  export type PRProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * The data used to create many PRProfiles.
     */
    data: PRProfileCreateManyInput | PRProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PRProfile update
   */
  export type PRProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a PRProfile.
     */
    data: XOR<PRProfileUpdateInput, PRProfileUncheckedUpdateInput>
    /**
     * Choose, which PRProfile to update.
     */
    where: PRProfileWhereUniqueInput
  }

  /**
   * PRProfile updateMany
   */
  export type PRProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRProfiles.
     */
    data: XOR<PRProfileUpdateManyMutationInput, PRProfileUncheckedUpdateManyInput>
    /**
     * Filter which PRProfiles to update
     */
    where?: PRProfileWhereInput
    /**
     * Limit how many PRProfiles to update.
     */
    limit?: number
  }

  /**
   * PRProfile updateManyAndReturn
   */
  export type PRProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * The data used to update PRProfiles.
     */
    data: XOR<PRProfileUpdateManyMutationInput, PRProfileUncheckedUpdateManyInput>
    /**
     * Filter which PRProfiles to update
     */
    where?: PRProfileWhereInput
    /**
     * Limit how many PRProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PRProfile upsert
   */
  export type PRProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the PRProfile to update in case it exists.
     */
    where: PRProfileWhereUniqueInput
    /**
     * In case the PRProfile found by the `where` argument doesn't exist, create a new PRProfile with this data.
     */
    create: XOR<PRProfileCreateInput, PRProfileUncheckedCreateInput>
    /**
     * In case the PRProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRProfileUpdateInput, PRProfileUncheckedUpdateInput>
  }

  /**
   * PRProfile delete
   */
  export type PRProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    /**
     * Filter which PRProfile to delete.
     */
    where: PRProfileWhereUniqueInput
  }

  /**
   * PRProfile deleteMany
   */
  export type PRProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRProfiles to delete
     */
    where?: PRProfileWhereInput
    /**
     * Limit how many PRProfiles to delete.
     */
    limit?: number
  }

  /**
   * PRProfile.assignments
   */
  export type PRProfile$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * PRProfile.inviteLinks
   */
  export type PRProfile$inviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    cursor?: InviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * PRProfile without action
   */
  export type PRProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    prProfileId: string | null
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    prProfileId: string | null
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    eventId: number
    prProfileId: number
    quotaTotal: number
    quotaFemale: number
    quotaMale: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
  }

  export type AssignmentSumAggregateInputType = {
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    eventId?: true
    prProfileId?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    eventId?: true
    prProfileId?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    eventId?: true
    prProfileId?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    eventId: string
    prProfileId: string
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date
    updatedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    prProfileId?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    prProfileId?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    prProfileId?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    eventId?: boolean
    prProfileId?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "prProfileId" | "quotaTotal" | "quotaFemale" | "quotaMale" | "createdAt" | "updatedAt", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | PRProfileDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      prProfile: Prisma.$PRProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      prProfileId: string
      quotaTotal: number | null
      quotaFemale: number | null
      quotaMale: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prProfile<T extends PRProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PRProfileDefaultArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly eventId: FieldRef<"Assignment", 'String'>
    readonly prProfileId: FieldRef<"Assignment", 'String'>
    readonly quotaTotal: FieldRef<"Assignment", 'Int'>
    readonly quotaFemale: FieldRef<"Assignment", 'Int'>
    readonly quotaMale: FieldRef<"Assignment", 'Int'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model List
   */

  export type AggregateList = {
    _count: ListCountAggregateOutputType | null
    _avg: ListAvgAggregateOutputType | null
    _sum: ListSumAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  export type ListAvgAggregateOutputType = {
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
  }

  export type ListSumAggregateOutputType = {
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
  }

  export type ListMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    type: $Enums.ListType | null
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    type: $Enums.ListType | null
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    type: number
    quotaTotal: number
    quotaFemale: number
    quotaMale: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListAvgAggregateInputType = {
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
  }

  export type ListSumAggregateInputType = {
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
  }

  export type ListMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    type?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    type?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    type?: true
    quotaTotal?: true
    quotaFemale?: true
    quotaMale?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which List to aggregate.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lists
    **/
    _count?: true | ListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListMaxAggregateInputType
  }

  export type GetListAggregateType<T extends ListAggregateArgs> = {
        [P in keyof T & keyof AggregateList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateList[P]>
      : GetScalarType<T[P], AggregateList[P]>
  }




  export type ListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListWhereInput
    orderBy?: ListOrderByWithAggregationInput | ListOrderByWithAggregationInput[]
    by: ListScalarFieldEnum[] | ListScalarFieldEnum
    having?: ListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListCountAggregateInputType | true
    _avg?: ListAvgAggregateInputType
    _sum?: ListSumAggregateInputType
    _min?: ListMinAggregateInputType
    _max?: ListMaxAggregateInputType
  }

  export type ListGroupByOutputType = {
    id: string
    eventId: string
    name: string
    type: $Enums.ListType
    quotaTotal: number | null
    quotaFemale: number | null
    quotaMale: number | null
    createdAt: Date
    updatedAt: Date
    _count: ListCountAggregateOutputType | null
    _avg: ListAvgAggregateOutputType | null
    _sum: ListSumAggregateOutputType | null
    _min: ListMinAggregateOutputType | null
    _max: ListMaxAggregateOutputType | null
  }

  type GetListGroupByPayload<T extends ListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListGroupByOutputType[P]>
            : GetScalarType<T[P], ListGroupByOutputType[P]>
        }
      >
    >


  export type ListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    type?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entries?: boolean | List$entriesArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    type?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    type?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["list"]>

  export type ListSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    type?: boolean
    quotaTotal?: boolean
    quotaFemale?: boolean
    quotaMale?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "type" | "quotaTotal" | "quotaFemale" | "quotaMale" | "createdAt" | "updatedAt", ExtArgs["result"]["list"]>
  export type ListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | List$entriesArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    _count?: boolean | ListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type ListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $ListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "List"
    objects: {
      entries: Prisma.$ListEntryPayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      type: $Enums.ListType
      quotaTotal: number | null
      quotaFemale: number | null
      quotaMale: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["list"]>
    composites: {}
  }

  type ListGetPayload<S extends boolean | null | undefined | ListDefaultArgs> = $Result.GetResult<Prisma.$ListPayload, S>

  type ListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListCountAggregateInputType | true
    }

  export interface ListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['List'], meta: { name: 'List' } }
    /**
     * Find zero or one List that matches the filter.
     * @param {ListFindUniqueArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListFindUniqueArgs>(args: SelectSubset<T, ListFindUniqueArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one List that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListFindUniqueOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListFindUniqueOrThrowArgs>(args: SelectSubset<T, ListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListFindFirstArgs>(args?: SelectSubset<T, ListFindFirstArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first List that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindFirstOrThrowArgs} args - Arguments to find a List
     * @example
     * // Get one List
     * const list = await prisma.list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListFindFirstOrThrowArgs>(args?: SelectSubset<T, ListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lists
     * const lists = await prisma.list.findMany()
     * 
     * // Get first 10 Lists
     * const lists = await prisma.list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listWithIdOnly = await prisma.list.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListFindManyArgs>(args?: SelectSubset<T, ListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a List.
     * @param {ListCreateArgs} args - Arguments to create a List.
     * @example
     * // Create one List
     * const List = await prisma.list.create({
     *   data: {
     *     // ... data to create a List
     *   }
     * })
     * 
     */
    create<T extends ListCreateArgs>(args: SelectSubset<T, ListCreateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lists.
     * @param {ListCreateManyArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListCreateManyArgs>(args?: SelectSubset<T, ListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lists and returns the data saved in the database.
     * @param {ListCreateManyAndReturnArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const list = await prisma.list.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListCreateManyAndReturnArgs>(args?: SelectSubset<T, ListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a List.
     * @param {ListDeleteArgs} args - Arguments to delete one List.
     * @example
     * // Delete one List
     * const List = await prisma.list.delete({
     *   where: {
     *     // ... filter to delete one List
     *   }
     * })
     * 
     */
    delete<T extends ListDeleteArgs>(args: SelectSubset<T, ListDeleteArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one List.
     * @param {ListUpdateArgs} args - Arguments to update one List.
     * @example
     * // Update one List
     * const list = await prisma.list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListUpdateArgs>(args: SelectSubset<T, ListUpdateArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lists.
     * @param {ListDeleteManyArgs} args - Arguments to filter Lists to delete.
     * @example
     * // Delete a few Lists
     * const { count } = await prisma.list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListDeleteManyArgs>(args?: SelectSubset<T, ListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListUpdateManyArgs>(args: SelectSubset<T, ListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists and returns the data updated in the database.
     * @param {ListUpdateManyAndReturnArgs} args - Arguments to update many Lists.
     * @example
     * // Update many Lists
     * const list = await prisma.list.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lists and only return the `id`
     * const listWithIdOnly = await prisma.list.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListUpdateManyAndReturnArgs>(args: SelectSubset<T, ListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one List.
     * @param {ListUpsertArgs} args - Arguments to update or create a List.
     * @example
     * // Update or create a List
     * const list = await prisma.list.upsert({
     *   create: {
     *     // ... data to create a List
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the List we want to update
     *   }
     * })
     */
    upsert<T extends ListUpsertArgs>(args: SelectSubset<T, ListUpsertArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListCountArgs} args - Arguments to filter Lists to count.
     * @example
     * // Count the number of Lists
     * const count = await prisma.list.count({
     *   where: {
     *     // ... the filter for the Lists we want to count
     *   }
     * })
    **/
    count<T extends ListCountArgs>(
      args?: Subset<T, ListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListAggregateArgs>(args: Subset<T, ListAggregateArgs>): Prisma.PrismaPromise<GetListAggregateType<T>>

    /**
     * Group by List.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListGroupByArgs['orderBy'] }
        : { orderBy?: ListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the List model
   */
  readonly fields: ListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for List.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends List$entriesArgs<ExtArgs> = {}>(args?: Subset<T, List$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the List model
   */
  interface ListFieldRefs {
    readonly id: FieldRef<"List", 'String'>
    readonly eventId: FieldRef<"List", 'String'>
    readonly name: FieldRef<"List", 'String'>
    readonly type: FieldRef<"List", 'ListType'>
    readonly quotaTotal: FieldRef<"List", 'Int'>
    readonly quotaFemale: FieldRef<"List", 'Int'>
    readonly quotaMale: FieldRef<"List", 'Int'>
    readonly createdAt: FieldRef<"List", 'DateTime'>
    readonly updatedAt: FieldRef<"List", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * List findUnique
   */
  export type ListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findUniqueOrThrow
   */
  export type ListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List findFirst
   */
  export type ListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findFirstOrThrow
   */
  export type ListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which List to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lists.
     */
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List findMany
   */
  export type ListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter, which Lists to fetch.
     */
    where?: ListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lists to fetch.
     */
    orderBy?: ListOrderByWithRelationInput | ListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lists.
     */
    cursor?: ListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lists.
     */
    skip?: number
    distinct?: ListScalarFieldEnum | ListScalarFieldEnum[]
  }

  /**
   * List create
   */
  export type ListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to create a List.
     */
    data: XOR<ListCreateInput, ListUncheckedCreateInput>
  }

  /**
   * List createMany
   */
  export type ListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * List createManyAndReturn
   */
  export type ListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to create many Lists.
     */
    data: ListCreateManyInput | ListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * List update
   */
  export type ListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The data needed to update a List.
     */
    data: XOR<ListUpdateInput, ListUncheckedUpdateInput>
    /**
     * Choose, which List to update.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List updateMany
   */
  export type ListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
  }

  /**
   * List updateManyAndReturn
   */
  export type ListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * The data used to update Lists.
     */
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyInput>
    /**
     * Filter which Lists to update
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * List upsert
   */
  export type ListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * The filter to search for the List to update in case it exists.
     */
    where: ListWhereUniqueInput
    /**
     * In case the List found by the `where` argument doesn't exist, create a new List with this data.
     */
    create: XOR<ListCreateInput, ListUncheckedCreateInput>
    /**
     * In case the List was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListUpdateInput, ListUncheckedUpdateInput>
  }

  /**
   * List delete
   */
  export type ListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
    /**
     * Filter which List to delete.
     */
    where: ListWhereUniqueInput
  }

  /**
   * List deleteMany
   */
  export type ListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lists to delete
     */
    where?: ListWhereInput
    /**
     * Limit how many Lists to delete.
     */
    limit?: number
  }

  /**
   * List.entries
   */
  export type List$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    cursor?: ListEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * List without action
   */
  export type ListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the List
     */
    select?: ListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the List
     */
    omit?: ListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListInclude<ExtArgs> | null
  }


  /**
   * Model Guest
   */

  export type AggregateGuest = {
    _count: GuestCountAggregateOutputType | null
    _avg: GuestAvgAggregateOutputType | null
    _sum: GuestSumAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  export type GuestAvgAggregateOutputType = {
    totalEvents: number | null
    averageGroupSize: number | null
  }

  export type GuestSumAggregateOutputType = {
    totalEvents: number | null
    averageGroupSize: number | null
  }

  export type GuestMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    nickname: string | null
    birthDate: Date | null
    city: string | null
    occupation: string | null
    instagram: string | null
    telegramChatId: string | null
    whatsappPhone: string | null
    totalEvents: number | null
    lastEventDate: Date | null
    customerSegment: $Enums.CustomerSegment | null
    preferredDays: string | null
    averageArrivalTime: string | null
    prefersTable: boolean | null
    averageGroupSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    nickname: string | null
    birthDate: Date | null
    city: string | null
    occupation: string | null
    instagram: string | null
    telegramChatId: string | null
    whatsappPhone: string | null
    totalEvents: number | null
    lastEventDate: Date | null
    customerSegment: $Enums.CustomerSegment | null
    preferredDays: string | null
    averageArrivalTime: string | null
    prefersTable: boolean | null
    averageGroupSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phone: number
    email: number
    nickname: number
    birthDate: number
    city: number
    occupation: number
    instagram: number
    telegramChatId: number
    whatsappPhone: number
    totalEvents: number
    lastEventDate: number
    customerSegment: number
    preferredDays: number
    averageArrivalTime: number
    prefersTable: number
    averageGroupSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuestAvgAggregateInputType = {
    totalEvents?: true
    averageGroupSize?: true
  }

  export type GuestSumAggregateInputType = {
    totalEvents?: true
    averageGroupSize?: true
  }

  export type GuestMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    nickname?: true
    birthDate?: true
    city?: true
    occupation?: true
    instagram?: true
    telegramChatId?: true
    whatsappPhone?: true
    totalEvents?: true
    lastEventDate?: true
    customerSegment?: true
    preferredDays?: true
    averageArrivalTime?: true
    prefersTable?: true
    averageGroupSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    nickname?: true
    birthDate?: true
    city?: true
    occupation?: true
    instagram?: true
    telegramChatId?: true
    whatsappPhone?: true
    totalEvents?: true
    lastEventDate?: true
    customerSegment?: true
    preferredDays?: true
    averageArrivalTime?: true
    prefersTable?: true
    averageGroupSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    nickname?: true
    birthDate?: true
    city?: true
    occupation?: true
    instagram?: true
    telegramChatId?: true
    whatsappPhone?: true
    totalEvents?: true
    lastEventDate?: true
    customerSegment?: true
    preferredDays?: true
    averageArrivalTime?: true
    prefersTable?: true
    averageGroupSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guest to aggregate.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guests
    **/
    _count?: true | GuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestMaxAggregateInputType
  }

  export type GetGuestAggregateType<T extends GuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuest[P]>
      : GetScalarType<T[P], AggregateGuest[P]>
  }




  export type GuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestWhereInput
    orderBy?: GuestOrderByWithAggregationInput | GuestOrderByWithAggregationInput[]
    by: GuestScalarFieldEnum[] | GuestScalarFieldEnum
    having?: GuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestCountAggregateInputType | true
    _avg?: GuestAvgAggregateInputType
    _sum?: GuestSumAggregateInputType
    _min?: GuestMinAggregateInputType
    _max?: GuestMaxAggregateInputType
  }

  export type GuestGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    phone: string | null
    email: string | null
    nickname: string | null
    birthDate: Date | null
    city: string | null
    occupation: string | null
    instagram: string | null
    telegramChatId: string | null
    whatsappPhone: string | null
    totalEvents: number
    lastEventDate: Date | null
    customerSegment: $Enums.CustomerSegment
    preferredDays: string | null
    averageArrivalTime: string | null
    prefersTable: boolean
    averageGroupSize: number
    createdAt: Date
    updatedAt: Date
    _count: GuestCountAggregateOutputType | null
    _avg: GuestAvgAggregateOutputType | null
    _sum: GuestSumAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  type GetGuestGroupByPayload<T extends GuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuestGroupByOutputType[P]>
        }
      >
    >


  export type GuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    nickname?: boolean
    birthDate?: boolean
    city?: boolean
    occupation?: boolean
    instagram?: boolean
    telegramChatId?: boolean
    whatsappPhone?: boolean
    totalEvents?: boolean
    lastEventDate?: boolean
    customerSegment?: boolean
    preferredDays?: boolean
    averageArrivalTime?: boolean
    prefersTable?: boolean
    averageGroupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preferences?: boolean | Guest$preferencesArgs<ExtArgs>
    feedbacks?: boolean | Guest$feedbacksArgs<ExtArgs>
    listEntries?: boolean | Guest$listEntriesArgs<ExtArgs>
    securityNotes?: boolean | Guest$securityNotesArgs<ExtArgs>
    tickets?: boolean | Guest$ticketsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    nickname?: boolean
    birthDate?: boolean
    city?: boolean
    occupation?: boolean
    instagram?: boolean
    telegramChatId?: boolean
    whatsappPhone?: boolean
    totalEvents?: boolean
    lastEventDate?: boolean
    customerSegment?: boolean
    preferredDays?: boolean
    averageArrivalTime?: boolean
    prefersTable?: boolean
    averageGroupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    nickname?: boolean
    birthDate?: boolean
    city?: boolean
    occupation?: boolean
    instagram?: boolean
    telegramChatId?: boolean
    whatsappPhone?: boolean
    totalEvents?: boolean
    lastEventDate?: boolean
    customerSegment?: boolean
    preferredDays?: boolean
    averageArrivalTime?: boolean
    prefersTable?: boolean
    averageGroupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    nickname?: boolean
    birthDate?: boolean
    city?: boolean
    occupation?: boolean
    instagram?: boolean
    telegramChatId?: boolean
    whatsappPhone?: boolean
    totalEvents?: boolean
    lastEventDate?: boolean
    customerSegment?: boolean
    preferredDays?: boolean
    averageArrivalTime?: boolean
    prefersTable?: boolean
    averageGroupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "phone" | "email" | "nickname" | "birthDate" | "city" | "occupation" | "instagram" | "telegramChatId" | "whatsappPhone" | "totalEvents" | "lastEventDate" | "customerSegment" | "preferredDays" | "averageArrivalTime" | "prefersTable" | "averageGroupSize" | "createdAt" | "updatedAt", ExtArgs["result"]["guest"]>
  export type GuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferences?: boolean | Guest$preferencesArgs<ExtArgs>
    feedbacks?: boolean | Guest$feedbacksArgs<ExtArgs>
    listEntries?: boolean | Guest$listEntriesArgs<ExtArgs>
    securityNotes?: boolean | Guest$securityNotesArgs<ExtArgs>
    tickets?: boolean | Guest$ticketsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guest"
    objects: {
      preferences: Prisma.$CustomerPreferencesPayload<ExtArgs> | null
      feedbacks: Prisma.$EventFeedbackPayload<ExtArgs>[]
      listEntries: Prisma.$ListEntryPayload<ExtArgs>[]
      securityNotes: Prisma.$SecurityNotePayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      phone: string | null
      email: string | null
      nickname: string | null
      birthDate: Date | null
      city: string | null
      occupation: string | null
      instagram: string | null
      telegramChatId: string | null
      whatsappPhone: string | null
      totalEvents: number
      lastEventDate: Date | null
      customerSegment: $Enums.CustomerSegment
      preferredDays: string | null
      averageArrivalTime: string | null
      prefersTable: boolean
      averageGroupSize: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guest"]>
    composites: {}
  }

  type GuestGetPayload<S extends boolean | null | undefined | GuestDefaultArgs> = $Result.GetResult<Prisma.$GuestPayload, S>

  type GuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestCountAggregateInputType | true
    }

  export interface GuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guest'], meta: { name: 'Guest' } }
    /**
     * Find zero or one Guest that matches the filter.
     * @param {GuestFindUniqueArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestFindUniqueArgs>(args: SelectSubset<T, GuestFindUniqueArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuestFindUniqueOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestFindFirstArgs>(args?: SelectSubset<T, GuestFindFirstArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guests
     * const guests = await prisma.guest.findMany()
     * 
     * // Get first 10 Guests
     * const guests = await prisma.guest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestFindManyArgs>(args?: SelectSubset<T, GuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guest.
     * @param {GuestCreateArgs} args - Arguments to create a Guest.
     * @example
     * // Create one Guest
     * const Guest = await prisma.guest.create({
     *   data: {
     *     // ... data to create a Guest
     *   }
     * })
     * 
     */
    create<T extends GuestCreateArgs>(args: SelectSubset<T, GuestCreateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guests.
     * @param {GuestCreateManyArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestCreateManyArgs>(args?: SelectSubset<T, GuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guests and returns the data saved in the database.
     * @param {GuestCreateManyAndReturnArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuestCreateManyAndReturnArgs>(args?: SelectSubset<T, GuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guest.
     * @param {GuestDeleteArgs} args - Arguments to delete one Guest.
     * @example
     * // Delete one Guest
     * const Guest = await prisma.guest.delete({
     *   where: {
     *     // ... filter to delete one Guest
     *   }
     * })
     * 
     */
    delete<T extends GuestDeleteArgs>(args: SelectSubset<T, GuestDeleteArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guest.
     * @param {GuestUpdateArgs} args - Arguments to update one Guest.
     * @example
     * // Update one Guest
     * const guest = await prisma.guest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestUpdateArgs>(args: SelectSubset<T, GuestUpdateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guests.
     * @param {GuestDeleteManyArgs} args - Arguments to filter Guests to delete.
     * @example
     * // Delete a few Guests
     * const { count } = await prisma.guest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestDeleteManyArgs>(args?: SelectSubset<T, GuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestUpdateManyArgs>(args: SelectSubset<T, GuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests and returns the data updated in the database.
     * @param {GuestUpdateManyAndReturnArgs} args - Arguments to update many Guests.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuestUpdateManyAndReturnArgs>(args: SelectSubset<T, GuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guest.
     * @param {GuestUpsertArgs} args - Arguments to update or create a Guest.
     * @example
     * // Update or create a Guest
     * const guest = await prisma.guest.upsert({
     *   create: {
     *     // ... data to create a Guest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guest we want to update
     *   }
     * })
     */
    upsert<T extends GuestUpsertArgs>(args: SelectSubset<T, GuestUpsertArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestCountArgs} args - Arguments to filter Guests to count.
     * @example
     * // Count the number of Guests
     * const count = await prisma.guest.count({
     *   where: {
     *     // ... the filter for the Guests we want to count
     *   }
     * })
    **/
    count<T extends GuestCountArgs>(
      args?: Subset<T, GuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestAggregateArgs>(args: Subset<T, GuestAggregateArgs>): Prisma.PrismaPromise<GetGuestAggregateType<T>>

    /**
     * Group by Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestGroupByArgs['orderBy'] }
        : { orderBy?: GuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guest model
   */
  readonly fields: GuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preferences<T extends Guest$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, Guest$preferencesArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedbacks<T extends Guest$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Guest$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listEntries<T extends Guest$listEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Guest$listEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityNotes<T extends Guest$securityNotesArgs<ExtArgs> = {}>(args?: Subset<T, Guest$securityNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Guest$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Guest$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guest model
   */
  interface GuestFieldRefs {
    readonly id: FieldRef<"Guest", 'String'>
    readonly firstName: FieldRef<"Guest", 'String'>
    readonly lastName: FieldRef<"Guest", 'String'>
    readonly phone: FieldRef<"Guest", 'String'>
    readonly email: FieldRef<"Guest", 'String'>
    readonly nickname: FieldRef<"Guest", 'String'>
    readonly birthDate: FieldRef<"Guest", 'DateTime'>
    readonly city: FieldRef<"Guest", 'String'>
    readonly occupation: FieldRef<"Guest", 'String'>
    readonly instagram: FieldRef<"Guest", 'String'>
    readonly telegramChatId: FieldRef<"Guest", 'String'>
    readonly whatsappPhone: FieldRef<"Guest", 'String'>
    readonly totalEvents: FieldRef<"Guest", 'Int'>
    readonly lastEventDate: FieldRef<"Guest", 'DateTime'>
    readonly customerSegment: FieldRef<"Guest", 'CustomerSegment'>
    readonly preferredDays: FieldRef<"Guest", 'String'>
    readonly averageArrivalTime: FieldRef<"Guest", 'String'>
    readonly prefersTable: FieldRef<"Guest", 'Boolean'>
    readonly averageGroupSize: FieldRef<"Guest", 'Int'>
    readonly createdAt: FieldRef<"Guest", 'DateTime'>
    readonly updatedAt: FieldRef<"Guest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guest findUnique
   */
  export type GuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findUniqueOrThrow
   */
  export type GuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findFirst
   */
  export type GuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findFirstOrThrow
   */
  export type GuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findMany
   */
  export type GuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guests to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest create
   */
  export type GuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Guest.
     */
    data: XOR<GuestCreateInput, GuestUncheckedCreateInput>
  }

  /**
   * Guest createMany
   */
  export type GuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guest createManyAndReturn
   */
  export type GuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guest update
   */
  export type GuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Guest.
     */
    data: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
    /**
     * Choose, which Guest to update.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest updateMany
   */
  export type GuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
    /**
     * Limit how many Guests to update.
     */
    limit?: number
  }

  /**
   * Guest updateManyAndReturn
   */
  export type GuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
    /**
     * Limit how many Guests to update.
     */
    limit?: number
  }

  /**
   * Guest upsert
   */
  export type GuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Guest to update in case it exists.
     */
    where: GuestWhereUniqueInput
    /**
     * In case the Guest found by the `where` argument doesn't exist, create a new Guest with this data.
     */
    create: XOR<GuestCreateInput, GuestUncheckedCreateInput>
    /**
     * In case the Guest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
  }

  /**
   * Guest delete
   */
  export type GuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter which Guest to delete.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest deleteMany
   */
  export type GuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guests to delete
     */
    where?: GuestWhereInput
    /**
     * Limit how many Guests to delete.
     */
    limit?: number
  }

  /**
   * Guest.preferences
   */
  export type Guest$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    where?: CustomerPreferencesWhereInput
  }

  /**
   * Guest.feedbacks
   */
  export type Guest$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    where?: EventFeedbackWhereInput
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    cursor?: EventFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * Guest.listEntries
   */
  export type Guest$listEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    cursor?: ListEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * Guest.securityNotes
   */
  export type Guest$securityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    where?: SecurityNoteWhereInput
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    cursor?: SecurityNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * Guest.tickets
   */
  export type Guest$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Guest without action
   */
  export type GuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
  }


  /**
   * Model ListEntry
   */

  export type AggregateListEntry = {
    _count: ListEntryCountAggregateOutputType | null
    _avg: ListEntryAvgAggregateOutputType | null
    _sum: ListEntrySumAggregateOutputType | null
    _min: ListEntryMinAggregateOutputType | null
    _max: ListEntryMaxAggregateOutputType | null
  }

  export type ListEntryAvgAggregateOutputType = {
    groupSize: number | null
  }

  export type ListEntrySumAggregateOutputType = {
    groupSize: number | null
  }

  export type ListEntryMinAggregateOutputType = {
    id: string | null
    listId: string | null
    guestId: string | null
    addedByUserId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    gender: $Enums.Gender | null
    note: string | null
    createdVia: $Enums.CreatedVia | null
    status: $Enums.EntryStatus | null
    plusOne: boolean | null
    bookingMethod: $Enums.BookingMethod | null
    referralSource: string | null
    groupSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListEntryMaxAggregateOutputType = {
    id: string | null
    listId: string | null
    guestId: string | null
    addedByUserId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    gender: $Enums.Gender | null
    note: string | null
    createdVia: $Enums.CreatedVia | null
    status: $Enums.EntryStatus | null
    plusOne: boolean | null
    bookingMethod: $Enums.BookingMethod | null
    referralSource: string | null
    groupSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListEntryCountAggregateOutputType = {
    id: number
    listId: number
    guestId: number
    addedByUserId: number
    firstName: number
    lastName: number
    phone: number
    email: number
    gender: number
    note: number
    createdVia: number
    status: number
    plusOne: number
    bookingMethod: number
    referralSource: number
    groupSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListEntryAvgAggregateInputType = {
    groupSize?: true
  }

  export type ListEntrySumAggregateInputType = {
    groupSize?: true
  }

  export type ListEntryMinAggregateInputType = {
    id?: true
    listId?: true
    guestId?: true
    addedByUserId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    gender?: true
    note?: true
    createdVia?: true
    status?: true
    plusOne?: true
    bookingMethod?: true
    referralSource?: true
    groupSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListEntryMaxAggregateInputType = {
    id?: true
    listId?: true
    guestId?: true
    addedByUserId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    gender?: true
    note?: true
    createdVia?: true
    status?: true
    plusOne?: true
    bookingMethod?: true
    referralSource?: true
    groupSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListEntryCountAggregateInputType = {
    id?: true
    listId?: true
    guestId?: true
    addedByUserId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    gender?: true
    note?: true
    createdVia?: true
    status?: true
    plusOne?: true
    bookingMethod?: true
    referralSource?: true
    groupSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListEntry to aggregate.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListEntries
    **/
    _count?: true | ListEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListEntryMaxAggregateInputType
  }

  export type GetListEntryAggregateType<T extends ListEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateListEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListEntry[P]>
      : GetScalarType<T[P], AggregateListEntry[P]>
  }




  export type ListEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListEntryWhereInput
    orderBy?: ListEntryOrderByWithAggregationInput | ListEntryOrderByWithAggregationInput[]
    by: ListEntryScalarFieldEnum[] | ListEntryScalarFieldEnum
    having?: ListEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListEntryCountAggregateInputType | true
    _avg?: ListEntryAvgAggregateInputType
    _sum?: ListEntrySumAggregateInputType
    _min?: ListEntryMinAggregateInputType
    _max?: ListEntryMaxAggregateInputType
  }

  export type ListEntryGroupByOutputType = {
    id: string
    listId: string
    guestId: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone: string | null
    email: string | null
    gender: $Enums.Gender
    note: string | null
    createdVia: $Enums.CreatedVia
    status: $Enums.EntryStatus
    plusOne: boolean
    bookingMethod: $Enums.BookingMethod
    referralSource: string | null
    groupSize: number
    createdAt: Date
    updatedAt: Date
    _count: ListEntryCountAggregateOutputType | null
    _avg: ListEntryAvgAggregateOutputType | null
    _sum: ListEntrySumAggregateOutputType | null
    _min: ListEntryMinAggregateOutputType | null
    _max: ListEntryMaxAggregateOutputType | null
  }

  type GetListEntryGroupByPayload<T extends ListEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ListEntryGroupByOutputType[P]>
        }
      >
    >


  export type ListEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    guestId?: boolean
    addedByUserId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    note?: boolean
    createdVia?: boolean
    status?: boolean
    plusOne?: boolean
    bookingMethod?: boolean
    referralSource?: boolean
    groupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
    tickets?: boolean | ListEntry$ticketsArgs<ExtArgs>
    _count?: boolean | ListEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    guestId?: boolean
    addedByUserId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    note?: boolean
    createdVia?: boolean
    status?: boolean
    plusOne?: boolean
    bookingMethod?: boolean
    referralSource?: boolean
    groupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listId?: boolean
    guestId?: boolean
    addedByUserId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    note?: boolean
    createdVia?: boolean
    status?: boolean
    plusOne?: boolean
    bookingMethod?: boolean
    referralSource?: boolean
    groupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listEntry"]>

  export type ListEntrySelectScalar = {
    id?: boolean
    listId?: boolean
    guestId?: boolean
    addedByUserId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    note?: boolean
    createdVia?: boolean
    status?: boolean
    plusOne?: boolean
    bookingMethod?: boolean
    referralSource?: boolean
    groupSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ListEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listId" | "guestId" | "addedByUserId" | "firstName" | "lastName" | "phone" | "email" | "gender" | "note" | "createdVia" | "status" | "plusOne" | "bookingMethod" | "referralSource" | "groupSize" | "createdAt" | "updatedAt", ExtArgs["result"]["listEntry"]>
  export type ListEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
    tickets?: boolean | ListEntry$ticketsArgs<ExtArgs>
    _count?: boolean | ListEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
  }
  export type ListEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    guest?: boolean | ListEntry$guestArgs<ExtArgs>
    list?: boolean | ListDefaultArgs<ExtArgs>
  }

  export type $ListEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListEntry"
    objects: {
      addedBy: Prisma.$UserPayload<ExtArgs>
      guest: Prisma.$GuestPayload<ExtArgs> | null
      list: Prisma.$ListPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listId: string
      guestId: string | null
      addedByUserId: string
      firstName: string
      lastName: string
      phone: string | null
      email: string | null
      gender: $Enums.Gender
      note: string | null
      createdVia: $Enums.CreatedVia
      status: $Enums.EntryStatus
      plusOne: boolean
      bookingMethod: $Enums.BookingMethod
      referralSource: string | null
      groupSize: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["listEntry"]>
    composites: {}
  }

  type ListEntryGetPayload<S extends boolean | null | undefined | ListEntryDefaultArgs> = $Result.GetResult<Prisma.$ListEntryPayload, S>

  type ListEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListEntryCountAggregateInputType | true
    }

  export interface ListEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListEntry'], meta: { name: 'ListEntry' } }
    /**
     * Find zero or one ListEntry that matches the filter.
     * @param {ListEntryFindUniqueArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListEntryFindUniqueArgs>(args: SelectSubset<T, ListEntryFindUniqueArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListEntryFindUniqueOrThrowArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ListEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindFirstArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListEntryFindFirstArgs>(args?: SelectSubset<T, ListEntryFindFirstArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindFirstOrThrowArgs} args - Arguments to find a ListEntry
     * @example
     * // Get one ListEntry
     * const listEntry = await prisma.listEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ListEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListEntries
     * const listEntries = await prisma.listEntry.findMany()
     * 
     * // Get first 10 ListEntries
     * const listEntries = await prisma.listEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListEntryFindManyArgs>(args?: SelectSubset<T, ListEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListEntry.
     * @param {ListEntryCreateArgs} args - Arguments to create a ListEntry.
     * @example
     * // Create one ListEntry
     * const ListEntry = await prisma.listEntry.create({
     *   data: {
     *     // ... data to create a ListEntry
     *   }
     * })
     * 
     */
    create<T extends ListEntryCreateArgs>(args: SelectSubset<T, ListEntryCreateArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListEntries.
     * @param {ListEntryCreateManyArgs} args - Arguments to create many ListEntries.
     * @example
     * // Create many ListEntries
     * const listEntry = await prisma.listEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListEntryCreateManyArgs>(args?: SelectSubset<T, ListEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListEntries and returns the data saved in the database.
     * @param {ListEntryCreateManyAndReturnArgs} args - Arguments to create many ListEntries.
     * @example
     * // Create many ListEntries
     * const listEntry = await prisma.listEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListEntries and only return the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ListEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListEntry.
     * @param {ListEntryDeleteArgs} args - Arguments to delete one ListEntry.
     * @example
     * // Delete one ListEntry
     * const ListEntry = await prisma.listEntry.delete({
     *   where: {
     *     // ... filter to delete one ListEntry
     *   }
     * })
     * 
     */
    delete<T extends ListEntryDeleteArgs>(args: SelectSubset<T, ListEntryDeleteArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListEntry.
     * @param {ListEntryUpdateArgs} args - Arguments to update one ListEntry.
     * @example
     * // Update one ListEntry
     * const listEntry = await prisma.listEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListEntryUpdateArgs>(args: SelectSubset<T, ListEntryUpdateArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListEntries.
     * @param {ListEntryDeleteManyArgs} args - Arguments to filter ListEntries to delete.
     * @example
     * // Delete a few ListEntries
     * const { count } = await prisma.listEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListEntryDeleteManyArgs>(args?: SelectSubset<T, ListEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListEntries
     * const listEntry = await prisma.listEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListEntryUpdateManyArgs>(args: SelectSubset<T, ListEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListEntries and returns the data updated in the database.
     * @param {ListEntryUpdateManyAndReturnArgs} args - Arguments to update many ListEntries.
     * @example
     * // Update many ListEntries
     * const listEntry = await prisma.listEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListEntries and only return the `id`
     * const listEntryWithIdOnly = await prisma.listEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ListEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListEntry.
     * @param {ListEntryUpsertArgs} args - Arguments to update or create a ListEntry.
     * @example
     * // Update or create a ListEntry
     * const listEntry = await prisma.listEntry.upsert({
     *   create: {
     *     // ... data to create a ListEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListEntry we want to update
     *   }
     * })
     */
    upsert<T extends ListEntryUpsertArgs>(args: SelectSubset<T, ListEntryUpsertArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryCountArgs} args - Arguments to filter ListEntries to count.
     * @example
     * // Count the number of ListEntries
     * const count = await prisma.listEntry.count({
     *   where: {
     *     // ... the filter for the ListEntries we want to count
     *   }
     * })
    **/
    count<T extends ListEntryCountArgs>(
      args?: Subset<T, ListEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListEntryAggregateArgs>(args: Subset<T, ListEntryAggregateArgs>): Prisma.PrismaPromise<GetListEntryAggregateType<T>>

    /**
     * Group by ListEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListEntryGroupByArgs['orderBy'] }
        : { orderBy?: ListEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListEntry model
   */
  readonly fields: ListEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guest<T extends ListEntry$guestArgs<ExtArgs> = {}>(args?: Subset<T, ListEntry$guestArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    list<T extends ListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListDefaultArgs<ExtArgs>>): Prisma__ListClient<$Result.GetResult<Prisma.$ListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends ListEntry$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, ListEntry$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListEntry model
   */
  interface ListEntryFieldRefs {
    readonly id: FieldRef<"ListEntry", 'String'>
    readonly listId: FieldRef<"ListEntry", 'String'>
    readonly guestId: FieldRef<"ListEntry", 'String'>
    readonly addedByUserId: FieldRef<"ListEntry", 'String'>
    readonly firstName: FieldRef<"ListEntry", 'String'>
    readonly lastName: FieldRef<"ListEntry", 'String'>
    readonly phone: FieldRef<"ListEntry", 'String'>
    readonly email: FieldRef<"ListEntry", 'String'>
    readonly gender: FieldRef<"ListEntry", 'Gender'>
    readonly note: FieldRef<"ListEntry", 'String'>
    readonly createdVia: FieldRef<"ListEntry", 'CreatedVia'>
    readonly status: FieldRef<"ListEntry", 'EntryStatus'>
    readonly plusOne: FieldRef<"ListEntry", 'Boolean'>
    readonly bookingMethod: FieldRef<"ListEntry", 'BookingMethod'>
    readonly referralSource: FieldRef<"ListEntry", 'String'>
    readonly groupSize: FieldRef<"ListEntry", 'Int'>
    readonly createdAt: FieldRef<"ListEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"ListEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListEntry findUnique
   */
  export type ListEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry findUniqueOrThrow
   */
  export type ListEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry findFirst
   */
  export type ListEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListEntries.
     */
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry findFirstOrThrow
   */
  export type ListEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntry to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListEntries.
     */
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry findMany
   */
  export type ListEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter, which ListEntries to fetch.
     */
    where?: ListEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListEntries to fetch.
     */
    orderBy?: ListEntryOrderByWithRelationInput | ListEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListEntries.
     */
    cursor?: ListEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListEntries.
     */
    skip?: number
    distinct?: ListEntryScalarFieldEnum | ListEntryScalarFieldEnum[]
  }

  /**
   * ListEntry create
   */
  export type ListEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ListEntry.
     */
    data: XOR<ListEntryCreateInput, ListEntryUncheckedCreateInput>
  }

  /**
   * ListEntry createMany
   */
  export type ListEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListEntries.
     */
    data: ListEntryCreateManyInput | ListEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListEntry createManyAndReturn
   */
  export type ListEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ListEntries.
     */
    data: ListEntryCreateManyInput | ListEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListEntry update
   */
  export type ListEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ListEntry.
     */
    data: XOR<ListEntryUpdateInput, ListEntryUncheckedUpdateInput>
    /**
     * Choose, which ListEntry to update.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry updateMany
   */
  export type ListEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListEntries.
     */
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyInput>
    /**
     * Filter which ListEntries to update
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to update.
     */
    limit?: number
  }

  /**
   * ListEntry updateManyAndReturn
   */
  export type ListEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * The data used to update ListEntries.
     */
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyInput>
    /**
     * Filter which ListEntries to update
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListEntry upsert
   */
  export type ListEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ListEntry to update in case it exists.
     */
    where: ListEntryWhereUniqueInput
    /**
     * In case the ListEntry found by the `where` argument doesn't exist, create a new ListEntry with this data.
     */
    create: XOR<ListEntryCreateInput, ListEntryUncheckedCreateInput>
    /**
     * In case the ListEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListEntryUpdateInput, ListEntryUncheckedUpdateInput>
  }

  /**
   * ListEntry delete
   */
  export type ListEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    /**
     * Filter which ListEntry to delete.
     */
    where: ListEntryWhereUniqueInput
  }

  /**
   * ListEntry deleteMany
   */
  export type ListEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListEntries to delete
     */
    where?: ListEntryWhereInput
    /**
     * Limit how many ListEntries to delete.
     */
    limit?: number
  }

  /**
   * ListEntry.guest
   */
  export type ListEntry$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
  }

  /**
   * ListEntry.tickets
   */
  export type ListEntry$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * ListEntry without action
   */
  export type ListEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    price: number | null
  }

  export type TicketSumAggregateOutputType = {
    price: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    guestId: string | null
    listEntryId: string | null
    issuedByUserId: string | null
    type: $Enums.TicketType | null
    price: number | null
    currency: string | null
    code: string | null
    qrData: string | null
    status: $Enums.TicketStatus | null
    issuedAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    guestId: string | null
    listEntryId: string | null
    issuedByUserId: string | null
    type: $Enums.TicketType | null
    price: number | null
    currency: string | null
    code: string | null
    qrData: string | null
    status: $Enums.TicketStatus | null
    issuedAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    guestId: number
    listEntryId: number
    issuedByUserId: number
    type: number
    price: number
    currency: number
    code: number
    qrData: number
    status: number
    issuedAt: number
    updatedAt: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    price?: true
  }

  export type TicketSumAggregateInputType = {
    price?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    guestId?: true
    listEntryId?: true
    issuedByUserId?: true
    type?: true
    price?: true
    currency?: true
    code?: true
    qrData?: true
    status?: true
    issuedAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    guestId?: true
    listEntryId?: true
    issuedByUserId?: true
    type?: true
    price?: true
    currency?: true
    code?: true
    qrData?: true
    status?: true
    issuedAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    guestId?: true
    listEntryId?: true
    issuedByUserId?: true
    type?: true
    price?: true
    currency?: true
    code?: true
    qrData?: true
    status?: true
    issuedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    eventId: string
    userId: string | null
    guestId: string | null
    listEntryId: string | null
    issuedByUserId: string | null
    type: $Enums.TicketType
    price: number | null
    currency: string | null
    code: string
    qrData: string
    status: $Enums.TicketStatus
    issuedAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    guestId?: boolean
    listEntryId?: boolean
    issuedByUserId?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    code?: boolean
    qrData?: boolean
    status?: boolean
    issuedAt?: boolean
    updatedAt?: boolean
    checkins?: boolean | Ticket$checkinsArgs<ExtArgs>
    consumptions?: boolean | Ticket$consumptionsArgs<ExtArgs>
    feedbacks?: boolean | Ticket$feedbacksArgs<ExtArgs>
    securityNotes?: boolean | Ticket$securityNotesArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    guestId?: boolean
    listEntryId?: boolean
    issuedByUserId?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    code?: boolean
    qrData?: boolean
    status?: boolean
    issuedAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    guestId?: boolean
    listEntryId?: boolean
    issuedByUserId?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    code?: boolean
    qrData?: boolean
    status?: boolean
    issuedAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    guestId?: boolean
    listEntryId?: boolean
    issuedByUserId?: boolean
    type?: boolean
    price?: boolean
    currency?: boolean
    code?: boolean
    qrData?: boolean
    status?: boolean
    issuedAt?: boolean
    updatedAt?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "guestId" | "listEntryId" | "issuedByUserId" | "type" | "price" | "currency" | "code" | "qrData" | "status" | "issuedAt" | "updatedAt", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | Ticket$checkinsArgs<ExtArgs>
    consumptions?: boolean | Ticket$consumptionsArgs<ExtArgs>
    feedbacks?: boolean | Ticket$feedbacksArgs<ExtArgs>
    securityNotes?: boolean | Ticket$securityNotesArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | Ticket$guestArgs<ExtArgs>
    issuedBy?: boolean | Ticket$issuedByArgs<ExtArgs>
    listEntry?: boolean | Ticket$listEntryArgs<ExtArgs>
    user?: boolean | Ticket$userArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      checkins: Prisma.$CheckInPayload<ExtArgs>[]
      consumptions: Prisma.$ConsumptionPayload<ExtArgs>[]
      feedbacks: Prisma.$EventFeedbackPayload<ExtArgs>[]
      securityNotes: Prisma.$SecurityNotePayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs>
      guest: Prisma.$GuestPayload<ExtArgs> | null
      issuedBy: Prisma.$UserPayload<ExtArgs> | null
      listEntry: Prisma.$ListEntryPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string | null
      guestId: string | null
      listEntryId: string | null
      issuedByUserId: string | null
      type: $Enums.TicketType
      price: number | null
      currency: string | null
      code: string
      qrData: string
      status: $Enums.TicketStatus
      issuedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkins<T extends Ticket$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consumptions<T extends Ticket$consumptionsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$consumptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Ticket$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    securityNotes<T extends Ticket$securityNotesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$securityNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guest<T extends Ticket$guestArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$guestArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    issuedBy<T extends Ticket$issuedByArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$issuedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    listEntry<T extends Ticket$listEntryArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$listEntryArgs<ExtArgs>>): Prisma__ListEntryClient<$Result.GetResult<Prisma.$ListEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Ticket$userArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly eventId: FieldRef<"Ticket", 'String'>
    readonly userId: FieldRef<"Ticket", 'String'>
    readonly guestId: FieldRef<"Ticket", 'String'>
    readonly listEntryId: FieldRef<"Ticket", 'String'>
    readonly issuedByUserId: FieldRef<"Ticket", 'String'>
    readonly type: FieldRef<"Ticket", 'TicketType'>
    readonly price: FieldRef<"Ticket", 'Float'>
    readonly currency: FieldRef<"Ticket", 'String'>
    readonly code: FieldRef<"Ticket", 'String'>
    readonly qrData: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly issuedAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.checkins
   */
  export type Ticket$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * Ticket.consumptions
   */
  export type Ticket$consumptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    where?: ConsumptionWhereInput
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    cursor?: ConsumptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsumptionScalarFieldEnum | ConsumptionScalarFieldEnum[]
  }

  /**
   * Ticket.feedbacks
   */
  export type Ticket$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    where?: EventFeedbackWhereInput
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    cursor?: EventFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * Ticket.securityNotes
   */
  export type Ticket$securityNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    where?: SecurityNoteWhereInput
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    cursor?: SecurityNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * Ticket.guest
   */
  export type Ticket$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
  }

  /**
   * Ticket.issuedBy
   */
  export type Ticket$issuedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.listEntry
   */
  export type Ticket$listEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListEntry
     */
    select?: ListEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListEntry
     */
    omit?: ListEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListEntryInclude<ExtArgs> | null
    where?: ListEntryWhereInput
  }

  /**
   * Ticket.user
   */
  export type Ticket$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model CheckIn
   */

  export type AggregateCheckIn = {
    _count: CheckInCountAggregateOutputType | null
    _avg: CheckInAvgAggregateOutputType | null
    _sum: CheckInSumAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  export type CheckInAvgAggregateOutputType = {
    groupSize: number | null
  }

  export type CheckInSumAggregateOutputType = {
    groupSize: number | null
  }

  export type CheckInMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    scannedByUserId: string | null
    scannedAt: Date | null
    gate: $Enums.Gate | null
    ok: boolean | null
    notes: string | null
    arrivalTime: string | null
    groupSize: number | null
  }

  export type CheckInMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    scannedByUserId: string | null
    scannedAt: Date | null
    gate: $Enums.Gate | null
    ok: boolean | null
    notes: string | null
    arrivalTime: string | null
    groupSize: number | null
  }

  export type CheckInCountAggregateOutputType = {
    id: number
    ticketId: number
    scannedByUserId: number
    scannedAt: number
    gate: number
    ok: number
    notes: number
    arrivalTime: number
    groupSize: number
    _all: number
  }


  export type CheckInAvgAggregateInputType = {
    groupSize?: true
  }

  export type CheckInSumAggregateInputType = {
    groupSize?: true
  }

  export type CheckInMinAggregateInputType = {
    id?: true
    ticketId?: true
    scannedByUserId?: true
    scannedAt?: true
    gate?: true
    ok?: true
    notes?: true
    arrivalTime?: true
    groupSize?: true
  }

  export type CheckInMaxAggregateInputType = {
    id?: true
    ticketId?: true
    scannedByUserId?: true
    scannedAt?: true
    gate?: true
    ok?: true
    notes?: true
    arrivalTime?: true
    groupSize?: true
  }

  export type CheckInCountAggregateInputType = {
    id?: true
    ticketId?: true
    scannedByUserId?: true
    scannedAt?: true
    gate?: true
    ok?: true
    notes?: true
    arrivalTime?: true
    groupSize?: true
    _all?: true
  }

  export type CheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIn to aggregate.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckIns
    **/
    _count?: true | CheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckInAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckInSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckInMaxAggregateInputType
  }

  export type GetCheckInAggregateType<T extends CheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckIn[P]>
      : GetScalarType<T[P], AggregateCheckIn[P]>
  }




  export type CheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithAggregationInput | CheckInOrderByWithAggregationInput[]
    by: CheckInScalarFieldEnum[] | CheckInScalarFieldEnum
    having?: CheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckInCountAggregateInputType | true
    _avg?: CheckInAvgAggregateInputType
    _sum?: CheckInSumAggregateInputType
    _min?: CheckInMinAggregateInputType
    _max?: CheckInMaxAggregateInputType
  }

  export type CheckInGroupByOutputType = {
    id: string
    ticketId: string
    scannedByUserId: string
    scannedAt: Date
    gate: $Enums.Gate
    ok: boolean
    notes: string | null
    arrivalTime: string | null
    groupSize: number
    _count: CheckInCountAggregateOutputType | null
    _avg: CheckInAvgAggregateOutputType | null
    _sum: CheckInSumAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  type GetCheckInGroupByPayload<T extends CheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckInGroupByOutputType[P]>
            : GetScalarType<T[P], CheckInGroupByOutputType[P]>
        }
      >
    >


  export type CheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    scannedByUserId?: boolean
    scannedAt?: boolean
    gate?: boolean
    ok?: boolean
    notes?: boolean
    arrivalTime?: boolean
    groupSize?: boolean
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    scannedByUserId?: boolean
    scannedAt?: boolean
    gate?: boolean
    ok?: boolean
    notes?: boolean
    arrivalTime?: boolean
    groupSize?: boolean
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    scannedByUserId?: boolean
    scannedAt?: boolean
    gate?: boolean
    ok?: boolean
    notes?: boolean
    arrivalTime?: boolean
    groupSize?: boolean
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectScalar = {
    id?: boolean
    ticketId?: boolean
    scannedByUserId?: boolean
    scannedAt?: boolean
    gate?: boolean
    ok?: boolean
    notes?: boolean
    arrivalTime?: boolean
    groupSize?: boolean
  }

  export type CheckInOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "scannedByUserId" | "scannedAt" | "gate" | "ok" | "notes" | "arrivalTime" | "groupSize", ExtArgs["result"]["checkIn"]>
  export type CheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type CheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type CheckInIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scannedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $CheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckIn"
    objects: {
      scannedBy: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      scannedByUserId: string
      scannedAt: Date
      gate: $Enums.Gate
      ok: boolean
      notes: string | null
      arrivalTime: string | null
      groupSize: number
    }, ExtArgs["result"]["checkIn"]>
    composites: {}
  }

  type CheckInGetPayload<S extends boolean | null | undefined | CheckInDefaultArgs> = $Result.GetResult<Prisma.$CheckInPayload, S>

  type CheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckInFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckInCountAggregateInputType | true
    }

  export interface CheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckIn'], meta: { name: 'CheckIn' } }
    /**
     * Find zero or one CheckIn that matches the filter.
     * @param {CheckInFindUniqueArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckInFindUniqueArgs>(args: SelectSubset<T, CheckInFindUniqueArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CheckIn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckInFindUniqueOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckInFindFirstArgs>(args?: SelectSubset<T, CheckInFindFirstArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckIns
     * const checkIns = await prisma.checkIn.findMany()
     * 
     * // Get first 10 CheckIns
     * const checkIns = await prisma.checkIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkInWithIdOnly = await prisma.checkIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckInFindManyArgs>(args?: SelectSubset<T, CheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CheckIn.
     * @param {CheckInCreateArgs} args - Arguments to create a CheckIn.
     * @example
     * // Create one CheckIn
     * const CheckIn = await prisma.checkIn.create({
     *   data: {
     *     // ... data to create a CheckIn
     *   }
     * })
     * 
     */
    create<T extends CheckInCreateArgs>(args: SelectSubset<T, CheckInCreateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CheckIns.
     * @param {CheckInCreateManyArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckInCreateManyArgs>(args?: SelectSubset<T, CheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckIns and returns the data saved in the database.
     * @param {CheckInCreateManyAndReturnArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckIns and only return the `id`
     * const checkInWithIdOnly = await prisma.checkIn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CheckIn.
     * @param {CheckInDeleteArgs} args - Arguments to delete one CheckIn.
     * @example
     * // Delete one CheckIn
     * const CheckIn = await prisma.checkIn.delete({
     *   where: {
     *     // ... filter to delete one CheckIn
     *   }
     * })
     * 
     */
    delete<T extends CheckInDeleteArgs>(args: SelectSubset<T, CheckInDeleteArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CheckIn.
     * @param {CheckInUpdateArgs} args - Arguments to update one CheckIn.
     * @example
     * // Update one CheckIn
     * const checkIn = await prisma.checkIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckInUpdateArgs>(args: SelectSubset<T, CheckInUpdateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CheckIns.
     * @param {CheckInDeleteManyArgs} args - Arguments to filter CheckIns to delete.
     * @example
     * // Delete a few CheckIns
     * const { count } = await prisma.checkIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckInDeleteManyArgs>(args?: SelectSubset<T, CheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckInUpdateManyArgs>(args: SelectSubset<T, CheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns and returns the data updated in the database.
     * @param {CheckInUpdateManyAndReturnArgs} args - Arguments to update many CheckIns.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CheckIns and only return the `id`
     * const checkInWithIdOnly = await prisma.checkIn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CheckInUpdateManyAndReturnArgs>(args: SelectSubset<T, CheckInUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CheckIn.
     * @param {CheckInUpsertArgs} args - Arguments to update or create a CheckIn.
     * @example
     * // Update or create a CheckIn
     * const checkIn = await prisma.checkIn.upsert({
     *   create: {
     *     // ... data to create a CheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckIn we want to update
     *   }
     * })
     */
    upsert<T extends CheckInUpsertArgs>(args: SelectSubset<T, CheckInUpsertArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInCountArgs} args - Arguments to filter CheckIns to count.
     * @example
     * // Count the number of CheckIns
     * const count = await prisma.checkIn.count({
     *   where: {
     *     // ... the filter for the CheckIns we want to count
     *   }
     * })
    **/
    count<T extends CheckInCountArgs>(
      args?: Subset<T, CheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckInAggregateArgs>(args: Subset<T, CheckInAggregateArgs>): Prisma.PrismaPromise<GetCheckInAggregateType<T>>

    /**
     * Group by CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckInGroupByArgs['orderBy'] }
        : { orderBy?: CheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckIn model
   */
  readonly fields: CheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scannedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckIn model
   */
  interface CheckInFieldRefs {
    readonly id: FieldRef<"CheckIn", 'String'>
    readonly ticketId: FieldRef<"CheckIn", 'String'>
    readonly scannedByUserId: FieldRef<"CheckIn", 'String'>
    readonly scannedAt: FieldRef<"CheckIn", 'DateTime'>
    readonly gate: FieldRef<"CheckIn", 'Gate'>
    readonly ok: FieldRef<"CheckIn", 'Boolean'>
    readonly notes: FieldRef<"CheckIn", 'String'>
    readonly arrivalTime: FieldRef<"CheckIn", 'String'>
    readonly groupSize: FieldRef<"CheckIn", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CheckIn findUnique
   */
  export type CheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findUniqueOrThrow
   */
  export type CheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findFirst
   */
  export type CheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findFirstOrThrow
   */
  export type CheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findMany
   */
  export type CheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIns to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn create
   */
  export type CheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckIn.
     */
    data: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
  }

  /**
   * CheckIn createMany
   */
  export type CheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckIn createManyAndReturn
   */
  export type CheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckIn update
   */
  export type CheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckIn.
     */
    data: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
    /**
     * Choose, which CheckIn to update.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn updateMany
   */
  export type CheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to update.
     */
    limit?: number
  }

  /**
   * CheckIn updateManyAndReturn
   */
  export type CheckInUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckIn upsert
   */
  export type CheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckIn to update in case it exists.
     */
    where: CheckInWhereUniqueInput
    /**
     * In case the CheckIn found by the `where` argument doesn't exist, create a new CheckIn with this data.
     */
    create: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
    /**
     * In case the CheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
  }

  /**
   * CheckIn delete
   */
  export type CheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter which CheckIn to delete.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn deleteMany
   */
  export type CheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIns to delete
     */
    where?: CheckInWhereInput
    /**
     * Limit how many CheckIns to delete.
     */
    limit?: number
  }

  /**
   * CheckIn without action
   */
  export type CheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckIn
     */
    omit?: CheckInOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
  }


  /**
   * Model InviteLink
   */

  export type AggregateInviteLink = {
    _count: InviteLinkCountAggregateOutputType | null
    _avg: InviteLinkAvgAggregateOutputType | null
    _sum: InviteLinkSumAggregateOutputType | null
    _min: InviteLinkMinAggregateOutputType | null
    _max: InviteLinkMaxAggregateOutputType | null
  }

  export type InviteLinkAvgAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type InviteLinkSumAggregateOutputType = {
    maxUses: number | null
    uses: number | null
  }

  export type InviteLinkMinAggregateOutputType = {
    id: string | null
    createdByUserId: string | null
    eventId: string | null
    prProfileId: string | null
    slug: string | null
    maxUses: number | null
    uses: number | null
    expiresAt: Date | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteLinkMaxAggregateOutputType = {
    id: string | null
    createdByUserId: string | null
    eventId: string | null
    prProfileId: string | null
    slug: string | null
    maxUses: number | null
    uses: number | null
    expiresAt: Date | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteLinkCountAggregateOutputType = {
    id: number
    createdByUserId: number
    eventId: number
    prProfileId: number
    slug: number
    maxUses: number
    uses: number
    expiresAt: number
    utmSource: number
    utmMedium: number
    utmCampaign: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InviteLinkAvgAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type InviteLinkSumAggregateInputType = {
    maxUses?: true
    uses?: true
  }

  export type InviteLinkMinAggregateInputType = {
    id?: true
    createdByUserId?: true
    eventId?: true
    prProfileId?: true
    slug?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteLinkMaxAggregateInputType = {
    id?: true
    createdByUserId?: true
    eventId?: true
    prProfileId?: true
    slug?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteLinkCountAggregateInputType = {
    id?: true
    createdByUserId?: true
    eventId?: true
    prProfileId?: true
    slug?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InviteLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteLink to aggregate.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InviteLinks
    **/
    _count?: true | InviteLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InviteLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InviteLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteLinkMaxAggregateInputType
  }

  export type GetInviteLinkAggregateType<T extends InviteLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateInviteLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInviteLink[P]>
      : GetScalarType<T[P], AggregateInviteLink[P]>
  }




  export type InviteLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteLinkWhereInput
    orderBy?: InviteLinkOrderByWithAggregationInput | InviteLinkOrderByWithAggregationInput[]
    by: InviteLinkScalarFieldEnum[] | InviteLinkScalarFieldEnum
    having?: InviteLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteLinkCountAggregateInputType | true
    _avg?: InviteLinkAvgAggregateInputType
    _sum?: InviteLinkSumAggregateInputType
    _min?: InviteLinkMinAggregateInputType
    _max?: InviteLinkMaxAggregateInputType
  }

  export type InviteLinkGroupByOutputType = {
    id: string
    createdByUserId: string
    eventId: string
    prProfileId: string | null
    slug: string
    maxUses: number | null
    uses: number
    expiresAt: Date | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    createdAt: Date
    updatedAt: Date
    _count: InviteLinkCountAggregateOutputType | null
    _avg: InviteLinkAvgAggregateOutputType | null
    _sum: InviteLinkSumAggregateOutputType | null
    _min: InviteLinkMinAggregateOutputType | null
    _max: InviteLinkMaxAggregateOutputType | null
  }

  type GetInviteLinkGroupByPayload<T extends InviteLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteLinkGroupByOutputType[P]>
            : GetScalarType<T[P], InviteLinkGroupByOutputType[P]>
        }
      >
    >


  export type InviteLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdByUserId?: boolean
    eventId?: boolean
    prProfileId?: boolean
    slug?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }, ExtArgs["result"]["inviteLink"]>

  export type InviteLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdByUserId?: boolean
    eventId?: boolean
    prProfileId?: boolean
    slug?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }, ExtArgs["result"]["inviteLink"]>

  export type InviteLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdByUserId?: boolean
    eventId?: boolean
    prProfileId?: boolean
    slug?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }, ExtArgs["result"]["inviteLink"]>

  export type InviteLinkSelectScalar = {
    id?: boolean
    createdByUserId?: boolean
    eventId?: boolean
    prProfileId?: boolean
    slug?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InviteLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdByUserId" | "eventId" | "prProfileId" | "slug" | "maxUses" | "uses" | "expiresAt" | "utmSource" | "utmMedium" | "utmCampaign" | "createdAt" | "updatedAt", ExtArgs["result"]["inviteLink"]>
  export type InviteLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }
  export type InviteLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }
  export type InviteLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    prProfile?: boolean | InviteLink$prProfileArgs<ExtArgs>
  }

  export type $InviteLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InviteLink"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
      prProfile: Prisma.$PRProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdByUserId: string
      eventId: string
      prProfileId: string | null
      slug: string
      maxUses: number | null
      uses: number
      expiresAt: Date | null
      utmSource: string | null
      utmMedium: string | null
      utmCampaign: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inviteLink"]>
    composites: {}
  }

  type InviteLinkGetPayload<S extends boolean | null | undefined | InviteLinkDefaultArgs> = $Result.GetResult<Prisma.$InviteLinkPayload, S>

  type InviteLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InviteLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InviteLinkCountAggregateInputType | true
    }

  export interface InviteLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InviteLink'], meta: { name: 'InviteLink' } }
    /**
     * Find zero or one InviteLink that matches the filter.
     * @param {InviteLinkFindUniqueArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteLinkFindUniqueArgs>(args: SelectSubset<T, InviteLinkFindUniqueArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InviteLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InviteLinkFindUniqueOrThrowArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InviteLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindFirstArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteLinkFindFirstArgs>(args?: SelectSubset<T, InviteLinkFindFirstArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InviteLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindFirstOrThrowArgs} args - Arguments to find a InviteLink
     * @example
     * // Get one InviteLink
     * const inviteLink = await prisma.inviteLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InviteLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InviteLinks
     * const inviteLinks = await prisma.inviteLink.findMany()
     * 
     * // Get first 10 InviteLinks
     * const inviteLinks = await prisma.inviteLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteLinkWithIdOnly = await prisma.inviteLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteLinkFindManyArgs>(args?: SelectSubset<T, InviteLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InviteLink.
     * @param {InviteLinkCreateArgs} args - Arguments to create a InviteLink.
     * @example
     * // Create one InviteLink
     * const InviteLink = await prisma.inviteLink.create({
     *   data: {
     *     // ... data to create a InviteLink
     *   }
     * })
     * 
     */
    create<T extends InviteLinkCreateArgs>(args: SelectSubset<T, InviteLinkCreateArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InviteLinks.
     * @param {InviteLinkCreateManyArgs} args - Arguments to create many InviteLinks.
     * @example
     * // Create many InviteLinks
     * const inviteLink = await prisma.inviteLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteLinkCreateManyArgs>(args?: SelectSubset<T, InviteLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InviteLinks and returns the data saved in the database.
     * @param {InviteLinkCreateManyAndReturnArgs} args - Arguments to create many InviteLinks.
     * @example
     * // Create many InviteLinks
     * const inviteLink = await prisma.inviteLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InviteLinks and only return the `id`
     * const inviteLinkWithIdOnly = await prisma.inviteLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InviteLink.
     * @param {InviteLinkDeleteArgs} args - Arguments to delete one InviteLink.
     * @example
     * // Delete one InviteLink
     * const InviteLink = await prisma.inviteLink.delete({
     *   where: {
     *     // ... filter to delete one InviteLink
     *   }
     * })
     * 
     */
    delete<T extends InviteLinkDeleteArgs>(args: SelectSubset<T, InviteLinkDeleteArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InviteLink.
     * @param {InviteLinkUpdateArgs} args - Arguments to update one InviteLink.
     * @example
     * // Update one InviteLink
     * const inviteLink = await prisma.inviteLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteLinkUpdateArgs>(args: SelectSubset<T, InviteLinkUpdateArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InviteLinks.
     * @param {InviteLinkDeleteManyArgs} args - Arguments to filter InviteLinks to delete.
     * @example
     * // Delete a few InviteLinks
     * const { count } = await prisma.inviteLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteLinkDeleteManyArgs>(args?: SelectSubset<T, InviteLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InviteLinks
     * const inviteLink = await prisma.inviteLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteLinkUpdateManyArgs>(args: SelectSubset<T, InviteLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteLinks and returns the data updated in the database.
     * @param {InviteLinkUpdateManyAndReturnArgs} args - Arguments to update many InviteLinks.
     * @example
     * // Update many InviteLinks
     * const inviteLink = await prisma.inviteLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InviteLinks and only return the `id`
     * const inviteLinkWithIdOnly = await prisma.inviteLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InviteLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, InviteLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InviteLink.
     * @param {InviteLinkUpsertArgs} args - Arguments to update or create a InviteLink.
     * @example
     * // Update or create a InviteLink
     * const inviteLink = await prisma.inviteLink.upsert({
     *   create: {
     *     // ... data to create a InviteLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InviteLink we want to update
     *   }
     * })
     */
    upsert<T extends InviteLinkUpsertArgs>(args: SelectSubset<T, InviteLinkUpsertArgs<ExtArgs>>): Prisma__InviteLinkClient<$Result.GetResult<Prisma.$InviteLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkCountArgs} args - Arguments to filter InviteLinks to count.
     * @example
     * // Count the number of InviteLinks
     * const count = await prisma.inviteLink.count({
     *   where: {
     *     // ... the filter for the InviteLinks we want to count
     *   }
     * })
    **/
    count<T extends InviteLinkCountArgs>(
      args?: Subset<T, InviteLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteLinkAggregateArgs>(args: Subset<T, InviteLinkAggregateArgs>): Prisma.PrismaPromise<GetInviteLinkAggregateType<T>>

    /**
     * Group by InviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteLinkGroupByArgs['orderBy'] }
        : { orderBy?: InviteLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InviteLink model
   */
  readonly fields: InviteLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InviteLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prProfile<T extends InviteLink$prProfileArgs<ExtArgs> = {}>(args?: Subset<T, InviteLink$prProfileArgs<ExtArgs>>): Prisma__PRProfileClient<$Result.GetResult<Prisma.$PRProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InviteLink model
   */
  interface InviteLinkFieldRefs {
    readonly id: FieldRef<"InviteLink", 'String'>
    readonly createdByUserId: FieldRef<"InviteLink", 'String'>
    readonly eventId: FieldRef<"InviteLink", 'String'>
    readonly prProfileId: FieldRef<"InviteLink", 'String'>
    readonly slug: FieldRef<"InviteLink", 'String'>
    readonly maxUses: FieldRef<"InviteLink", 'Int'>
    readonly uses: FieldRef<"InviteLink", 'Int'>
    readonly expiresAt: FieldRef<"InviteLink", 'DateTime'>
    readonly utmSource: FieldRef<"InviteLink", 'String'>
    readonly utmMedium: FieldRef<"InviteLink", 'String'>
    readonly utmCampaign: FieldRef<"InviteLink", 'String'>
    readonly createdAt: FieldRef<"InviteLink", 'DateTime'>
    readonly updatedAt: FieldRef<"InviteLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InviteLink findUnique
   */
  export type InviteLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink findUniqueOrThrow
   */
  export type InviteLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink findFirst
   */
  export type InviteLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteLinks.
     */
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink findFirstOrThrow
   */
  export type InviteLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLink to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteLinks.
     */
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink findMany
   */
  export type InviteLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which InviteLinks to fetch.
     */
    where?: InviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteLinks to fetch.
     */
    orderBy?: InviteLinkOrderByWithRelationInput | InviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InviteLinks.
     */
    cursor?: InviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteLinks.
     */
    skip?: number
    distinct?: InviteLinkScalarFieldEnum | InviteLinkScalarFieldEnum[]
  }

  /**
   * InviteLink create
   */
  export type InviteLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a InviteLink.
     */
    data: XOR<InviteLinkCreateInput, InviteLinkUncheckedCreateInput>
  }

  /**
   * InviteLink createMany
   */
  export type InviteLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InviteLinks.
     */
    data: InviteLinkCreateManyInput | InviteLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InviteLink createManyAndReturn
   */
  export type InviteLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * The data used to create many InviteLinks.
     */
    data: InviteLinkCreateManyInput | InviteLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteLink update
   */
  export type InviteLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a InviteLink.
     */
    data: XOR<InviteLinkUpdateInput, InviteLinkUncheckedUpdateInput>
    /**
     * Choose, which InviteLink to update.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink updateMany
   */
  export type InviteLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InviteLinks.
     */
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which InviteLinks to update
     */
    where?: InviteLinkWhereInput
    /**
     * Limit how many InviteLinks to update.
     */
    limit?: number
  }

  /**
   * InviteLink updateManyAndReturn
   */
  export type InviteLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * The data used to update InviteLinks.
     */
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which InviteLinks to update
     */
    where?: InviteLinkWhereInput
    /**
     * Limit how many InviteLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteLink upsert
   */
  export type InviteLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the InviteLink to update in case it exists.
     */
    where: InviteLinkWhereUniqueInput
    /**
     * In case the InviteLink found by the `where` argument doesn't exist, create a new InviteLink with this data.
     */
    create: XOR<InviteLinkCreateInput, InviteLinkUncheckedCreateInput>
    /**
     * In case the InviteLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteLinkUpdateInput, InviteLinkUncheckedUpdateInput>
  }

  /**
   * InviteLink delete
   */
  export type InviteLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
    /**
     * Filter which InviteLink to delete.
     */
    where: InviteLinkWhereUniqueInput
  }

  /**
   * InviteLink deleteMany
   */
  export type InviteLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteLinks to delete
     */
    where?: InviteLinkWhereInput
    /**
     * Limit how many InviteLinks to delete.
     */
    limit?: number
  }

  /**
   * InviteLink.prProfile
   */
  export type InviteLink$prProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRProfile
     */
    select?: PRProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PRProfile
     */
    omit?: PRProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRProfileInclude<ExtArgs> | null
    where?: PRProfileWhereInput
  }

  /**
   * InviteLink without action
   */
  export type InviteLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteLink
     */
    select?: InviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InviteLink
     */
    omit?: InviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteLinkInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    details: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    details: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "details" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      details: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Consumption
   */

  export type AggregateConsumption = {
    _count: ConsumptionCountAggregateOutputType | null
    _avg: ConsumptionAvgAggregateOutputType | null
    _sum: ConsumptionSumAggregateOutputType | null
    _min: ConsumptionMinAggregateOutputType | null
    _max: ConsumptionMaxAggregateOutputType | null
  }

  export type ConsumptionAvgAggregateOutputType = {
    amount: number | null
  }

  export type ConsumptionSumAggregateOutputType = {
    amount: number | null
  }

  export type ConsumptionMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    eventId: string | null
    amount: number | null
    category: string | null
    createdAt: Date | null
  }

  export type ConsumptionMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    eventId: string | null
    amount: number | null
    category: string | null
    createdAt: Date | null
  }

  export type ConsumptionCountAggregateOutputType = {
    id: number
    ticketId: number
    eventId: number
    amount: number
    category: number
    items: number
    createdAt: number
    _all: number
  }


  export type ConsumptionAvgAggregateInputType = {
    amount?: true
  }

  export type ConsumptionSumAggregateInputType = {
    amount?: true
  }

  export type ConsumptionMinAggregateInputType = {
    id?: true
    ticketId?: true
    eventId?: true
    amount?: true
    category?: true
    createdAt?: true
  }

  export type ConsumptionMaxAggregateInputType = {
    id?: true
    ticketId?: true
    eventId?: true
    amount?: true
    category?: true
    createdAt?: true
  }

  export type ConsumptionCountAggregateInputType = {
    id?: true
    ticketId?: true
    eventId?: true
    amount?: true
    category?: true
    items?: true
    createdAt?: true
    _all?: true
  }

  export type ConsumptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consumption to aggregate.
     */
    where?: ConsumptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consumptions to fetch.
     */
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsumptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consumptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consumptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consumptions
    **/
    _count?: true | ConsumptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsumptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsumptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsumptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsumptionMaxAggregateInputType
  }

  export type GetConsumptionAggregateType<T extends ConsumptionAggregateArgs> = {
        [P in keyof T & keyof AggregateConsumption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsumption[P]>
      : GetScalarType<T[P], AggregateConsumption[P]>
  }




  export type ConsumptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsumptionWhereInput
    orderBy?: ConsumptionOrderByWithAggregationInput | ConsumptionOrderByWithAggregationInput[]
    by: ConsumptionScalarFieldEnum[] | ConsumptionScalarFieldEnum
    having?: ConsumptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsumptionCountAggregateInputType | true
    _avg?: ConsumptionAvgAggregateInputType
    _sum?: ConsumptionSumAggregateInputType
    _min?: ConsumptionMinAggregateInputType
    _max?: ConsumptionMaxAggregateInputType
  }

  export type ConsumptionGroupByOutputType = {
    id: string
    ticketId: string
    eventId: string
    amount: number
    category: string
    items: JsonValue | null
    createdAt: Date
    _count: ConsumptionCountAggregateOutputType | null
    _avg: ConsumptionAvgAggregateOutputType | null
    _sum: ConsumptionSumAggregateOutputType | null
    _min: ConsumptionMinAggregateOutputType | null
    _max: ConsumptionMaxAggregateOutputType | null
  }

  type GetConsumptionGroupByPayload<T extends ConsumptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsumptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsumptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsumptionGroupByOutputType[P]>
            : GetScalarType<T[P], ConsumptionGroupByOutputType[P]>
        }
      >
    >


  export type ConsumptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    eventId?: boolean
    amount?: boolean
    category?: boolean
    items?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumption"]>

  export type ConsumptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    eventId?: boolean
    amount?: boolean
    category?: boolean
    items?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumption"]>

  export type ConsumptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    eventId?: boolean
    amount?: boolean
    category?: boolean
    items?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumption"]>

  export type ConsumptionSelectScalar = {
    id?: boolean
    ticketId?: boolean
    eventId?: boolean
    amount?: boolean
    category?: boolean
    items?: boolean
    createdAt?: boolean
  }

  export type ConsumptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "eventId" | "amount" | "category" | "items" | "createdAt", ExtArgs["result"]["consumption"]>
  export type ConsumptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type ConsumptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type ConsumptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $ConsumptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consumption"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      eventId: string
      amount: number
      category: string
      items: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["consumption"]>
    composites: {}
  }

  type ConsumptionGetPayload<S extends boolean | null | undefined | ConsumptionDefaultArgs> = $Result.GetResult<Prisma.$ConsumptionPayload, S>

  type ConsumptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsumptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsumptionCountAggregateInputType | true
    }

  export interface ConsumptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consumption'], meta: { name: 'Consumption' } }
    /**
     * Find zero or one Consumption that matches the filter.
     * @param {ConsumptionFindUniqueArgs} args - Arguments to find a Consumption
     * @example
     * // Get one Consumption
     * const consumption = await prisma.consumption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsumptionFindUniqueArgs>(args: SelectSubset<T, ConsumptionFindUniqueArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consumption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsumptionFindUniqueOrThrowArgs} args - Arguments to find a Consumption
     * @example
     * // Get one Consumption
     * const consumption = await prisma.consumption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsumptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsumptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consumption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionFindFirstArgs} args - Arguments to find a Consumption
     * @example
     * // Get one Consumption
     * const consumption = await prisma.consumption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsumptionFindFirstArgs>(args?: SelectSubset<T, ConsumptionFindFirstArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consumption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionFindFirstOrThrowArgs} args - Arguments to find a Consumption
     * @example
     * // Get one Consumption
     * const consumption = await prisma.consumption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsumptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsumptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consumptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consumptions
     * const consumptions = await prisma.consumption.findMany()
     * 
     * // Get first 10 Consumptions
     * const consumptions = await prisma.consumption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consumptionWithIdOnly = await prisma.consumption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsumptionFindManyArgs>(args?: SelectSubset<T, ConsumptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consumption.
     * @param {ConsumptionCreateArgs} args - Arguments to create a Consumption.
     * @example
     * // Create one Consumption
     * const Consumption = await prisma.consumption.create({
     *   data: {
     *     // ... data to create a Consumption
     *   }
     * })
     * 
     */
    create<T extends ConsumptionCreateArgs>(args: SelectSubset<T, ConsumptionCreateArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consumptions.
     * @param {ConsumptionCreateManyArgs} args - Arguments to create many Consumptions.
     * @example
     * // Create many Consumptions
     * const consumption = await prisma.consumption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsumptionCreateManyArgs>(args?: SelectSubset<T, ConsumptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consumptions and returns the data saved in the database.
     * @param {ConsumptionCreateManyAndReturnArgs} args - Arguments to create many Consumptions.
     * @example
     * // Create many Consumptions
     * const consumption = await prisma.consumption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consumptions and only return the `id`
     * const consumptionWithIdOnly = await prisma.consumption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsumptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsumptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consumption.
     * @param {ConsumptionDeleteArgs} args - Arguments to delete one Consumption.
     * @example
     * // Delete one Consumption
     * const Consumption = await prisma.consumption.delete({
     *   where: {
     *     // ... filter to delete one Consumption
     *   }
     * })
     * 
     */
    delete<T extends ConsumptionDeleteArgs>(args: SelectSubset<T, ConsumptionDeleteArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consumption.
     * @param {ConsumptionUpdateArgs} args - Arguments to update one Consumption.
     * @example
     * // Update one Consumption
     * const consumption = await prisma.consumption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsumptionUpdateArgs>(args: SelectSubset<T, ConsumptionUpdateArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consumptions.
     * @param {ConsumptionDeleteManyArgs} args - Arguments to filter Consumptions to delete.
     * @example
     * // Delete a few Consumptions
     * const { count } = await prisma.consumption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsumptionDeleteManyArgs>(args?: SelectSubset<T, ConsumptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consumptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consumptions
     * const consumption = await prisma.consumption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsumptionUpdateManyArgs>(args: SelectSubset<T, ConsumptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consumptions and returns the data updated in the database.
     * @param {ConsumptionUpdateManyAndReturnArgs} args - Arguments to update many Consumptions.
     * @example
     * // Update many Consumptions
     * const consumption = await prisma.consumption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consumptions and only return the `id`
     * const consumptionWithIdOnly = await prisma.consumption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsumptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsumptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consumption.
     * @param {ConsumptionUpsertArgs} args - Arguments to update or create a Consumption.
     * @example
     * // Update or create a Consumption
     * const consumption = await prisma.consumption.upsert({
     *   create: {
     *     // ... data to create a Consumption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consumption we want to update
     *   }
     * })
     */
    upsert<T extends ConsumptionUpsertArgs>(args: SelectSubset<T, ConsumptionUpsertArgs<ExtArgs>>): Prisma__ConsumptionClient<$Result.GetResult<Prisma.$ConsumptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consumptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionCountArgs} args - Arguments to filter Consumptions to count.
     * @example
     * // Count the number of Consumptions
     * const count = await prisma.consumption.count({
     *   where: {
     *     // ... the filter for the Consumptions we want to count
     *   }
     * })
    **/
    count<T extends ConsumptionCountArgs>(
      args?: Subset<T, ConsumptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsumptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consumption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsumptionAggregateArgs>(args: Subset<T, ConsumptionAggregateArgs>): Prisma.PrismaPromise<GetConsumptionAggregateType<T>>

    /**
     * Group by Consumption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsumptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsumptionGroupByArgs['orderBy'] }
        : { orderBy?: ConsumptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsumptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsumptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consumption model
   */
  readonly fields: ConsumptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consumption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsumptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consumption model
   */
  interface ConsumptionFieldRefs {
    readonly id: FieldRef<"Consumption", 'String'>
    readonly ticketId: FieldRef<"Consumption", 'String'>
    readonly eventId: FieldRef<"Consumption", 'String'>
    readonly amount: FieldRef<"Consumption", 'Float'>
    readonly category: FieldRef<"Consumption", 'String'>
    readonly items: FieldRef<"Consumption", 'Json'>
    readonly createdAt: FieldRef<"Consumption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Consumption findUnique
   */
  export type ConsumptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter, which Consumption to fetch.
     */
    where: ConsumptionWhereUniqueInput
  }

  /**
   * Consumption findUniqueOrThrow
   */
  export type ConsumptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter, which Consumption to fetch.
     */
    where: ConsumptionWhereUniqueInput
  }

  /**
   * Consumption findFirst
   */
  export type ConsumptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter, which Consumption to fetch.
     */
    where?: ConsumptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consumptions to fetch.
     */
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consumptions.
     */
    cursor?: ConsumptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consumptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consumptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consumptions.
     */
    distinct?: ConsumptionScalarFieldEnum | ConsumptionScalarFieldEnum[]
  }

  /**
   * Consumption findFirstOrThrow
   */
  export type ConsumptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter, which Consumption to fetch.
     */
    where?: ConsumptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consumptions to fetch.
     */
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consumptions.
     */
    cursor?: ConsumptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consumptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consumptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consumptions.
     */
    distinct?: ConsumptionScalarFieldEnum | ConsumptionScalarFieldEnum[]
  }

  /**
   * Consumption findMany
   */
  export type ConsumptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter, which Consumptions to fetch.
     */
    where?: ConsumptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consumptions to fetch.
     */
    orderBy?: ConsumptionOrderByWithRelationInput | ConsumptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consumptions.
     */
    cursor?: ConsumptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consumptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consumptions.
     */
    skip?: number
    distinct?: ConsumptionScalarFieldEnum | ConsumptionScalarFieldEnum[]
  }

  /**
   * Consumption create
   */
  export type ConsumptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Consumption.
     */
    data: XOR<ConsumptionCreateInput, ConsumptionUncheckedCreateInput>
  }

  /**
   * Consumption createMany
   */
  export type ConsumptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consumptions.
     */
    data: ConsumptionCreateManyInput | ConsumptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consumption createManyAndReturn
   */
  export type ConsumptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * The data used to create many Consumptions.
     */
    data: ConsumptionCreateManyInput | ConsumptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consumption update
   */
  export type ConsumptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Consumption.
     */
    data: XOR<ConsumptionUpdateInput, ConsumptionUncheckedUpdateInput>
    /**
     * Choose, which Consumption to update.
     */
    where: ConsumptionWhereUniqueInput
  }

  /**
   * Consumption updateMany
   */
  export type ConsumptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consumptions.
     */
    data: XOR<ConsumptionUpdateManyMutationInput, ConsumptionUncheckedUpdateManyInput>
    /**
     * Filter which Consumptions to update
     */
    where?: ConsumptionWhereInput
    /**
     * Limit how many Consumptions to update.
     */
    limit?: number
  }

  /**
   * Consumption updateManyAndReturn
   */
  export type ConsumptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * The data used to update Consumptions.
     */
    data: XOR<ConsumptionUpdateManyMutationInput, ConsumptionUncheckedUpdateManyInput>
    /**
     * Filter which Consumptions to update
     */
    where?: ConsumptionWhereInput
    /**
     * Limit how many Consumptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consumption upsert
   */
  export type ConsumptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Consumption to update in case it exists.
     */
    where: ConsumptionWhereUniqueInput
    /**
     * In case the Consumption found by the `where` argument doesn't exist, create a new Consumption with this data.
     */
    create: XOR<ConsumptionCreateInput, ConsumptionUncheckedCreateInput>
    /**
     * In case the Consumption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsumptionUpdateInput, ConsumptionUncheckedUpdateInput>
  }

  /**
   * Consumption delete
   */
  export type ConsumptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
    /**
     * Filter which Consumption to delete.
     */
    where: ConsumptionWhereUniqueInput
  }

  /**
   * Consumption deleteMany
   */
  export type ConsumptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consumptions to delete
     */
    where?: ConsumptionWhereInput
    /**
     * Limit how many Consumptions to delete.
     */
    limit?: number
  }

  /**
   * Consumption without action
   */
  export type ConsumptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consumption
     */
    select?: ConsumptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consumption
     */
    omit?: ConsumptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsumptionInclude<ExtArgs> | null
  }


  /**
   * Model FunnelTracking
   */

  export type AggregateFunnelTracking = {
    _count: FunnelTrackingCountAggregateOutputType | null
    _min: FunnelTrackingMinAggregateOutputType | null
    _max: FunnelTrackingMaxAggregateOutputType | null
  }

  export type FunnelTrackingMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    guestEmail: string | null
    guestPhone: string | null
    eventId: string | null
    step: string | null
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    timestamp: Date | null
  }

  export type FunnelTrackingMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    guestEmail: string | null
    guestPhone: string | null
    eventId: string | null
    step: string | null
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    timestamp: Date | null
  }

  export type FunnelTrackingCountAggregateOutputType = {
    id: number
    sessionId: number
    guestEmail: number
    guestPhone: number
    eventId: number
    step: number
    metadata: number
    userAgent: number
    ipAddress: number
    referer: number
    timestamp: number
    _all: number
  }


  export type FunnelTrackingMinAggregateInputType = {
    id?: true
    sessionId?: true
    guestEmail?: true
    guestPhone?: true
    eventId?: true
    step?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    timestamp?: true
  }

  export type FunnelTrackingMaxAggregateInputType = {
    id?: true
    sessionId?: true
    guestEmail?: true
    guestPhone?: true
    eventId?: true
    step?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    timestamp?: true
  }

  export type FunnelTrackingCountAggregateInputType = {
    id?: true
    sessionId?: true
    guestEmail?: true
    guestPhone?: true
    eventId?: true
    step?: true
    metadata?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    timestamp?: true
    _all?: true
  }

  export type FunnelTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelTracking to aggregate.
     */
    where?: FunnelTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelTrackings to fetch.
     */
    orderBy?: FunnelTrackingOrderByWithRelationInput | FunnelTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunnelTrackings
    **/
    _count?: true | FunnelTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelTrackingMaxAggregateInputType
  }

  export type GetFunnelTrackingAggregateType<T extends FunnelTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnelTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnelTracking[P]>
      : GetScalarType<T[P], AggregateFunnelTracking[P]>
  }




  export type FunnelTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelTrackingWhereInput
    orderBy?: FunnelTrackingOrderByWithAggregationInput | FunnelTrackingOrderByWithAggregationInput[]
    by: FunnelTrackingScalarFieldEnum[] | FunnelTrackingScalarFieldEnum
    having?: FunnelTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelTrackingCountAggregateInputType | true
    _min?: FunnelTrackingMinAggregateInputType
    _max?: FunnelTrackingMaxAggregateInputType
  }

  export type FunnelTrackingGroupByOutputType = {
    id: string
    sessionId: string
    guestEmail: string | null
    guestPhone: string | null
    eventId: string
    step: string
    metadata: JsonValue | null
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    timestamp: Date
    _count: FunnelTrackingCountAggregateOutputType | null
    _min: FunnelTrackingMinAggregateOutputType | null
    _max: FunnelTrackingMaxAggregateOutputType | null
  }

  type GetFunnelTrackingGroupByPayload<T extends FunnelTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelTrackingGroupByOutputType[P]>
        }
      >
    >


  export type FunnelTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    eventId?: boolean
    step?: boolean
    metadata?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    timestamp?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelTracking"]>

  export type FunnelTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    eventId?: boolean
    step?: boolean
    metadata?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    timestamp?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelTracking"]>

  export type FunnelTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    eventId?: boolean
    step?: boolean
    metadata?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    timestamp?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelTracking"]>

  export type FunnelTrackingSelectScalar = {
    id?: boolean
    sessionId?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    eventId?: boolean
    step?: boolean
    metadata?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    timestamp?: boolean
  }

  export type FunnelTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "guestEmail" | "guestPhone" | "eventId" | "step" | "metadata" | "userAgent" | "ipAddress" | "referer" | "timestamp", ExtArgs["result"]["funnelTracking"]>
  export type FunnelTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type FunnelTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type FunnelTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $FunnelTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunnelTracking"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      guestEmail: string | null
      guestPhone: string | null
      eventId: string
      step: string
      metadata: Prisma.JsonValue | null
      userAgent: string | null
      ipAddress: string | null
      referer: string | null
      timestamp: Date
    }, ExtArgs["result"]["funnelTracking"]>
    composites: {}
  }

  type FunnelTrackingGetPayload<S extends boolean | null | undefined | FunnelTrackingDefaultArgs> = $Result.GetResult<Prisma.$FunnelTrackingPayload, S>

  type FunnelTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelTrackingCountAggregateInputType | true
    }

  export interface FunnelTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunnelTracking'], meta: { name: 'FunnelTracking' } }
    /**
     * Find zero or one FunnelTracking that matches the filter.
     * @param {FunnelTrackingFindUniqueArgs} args - Arguments to find a FunnelTracking
     * @example
     * // Get one FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelTrackingFindUniqueArgs>(args: SelectSubset<T, FunnelTrackingFindUniqueArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FunnelTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelTrackingFindUniqueOrThrowArgs} args - Arguments to find a FunnelTracking
     * @example
     * // Get one FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingFindFirstArgs} args - Arguments to find a FunnelTracking
     * @example
     * // Get one FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelTrackingFindFirstArgs>(args?: SelectSubset<T, FunnelTrackingFindFirstArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingFindFirstOrThrowArgs} args - Arguments to find a FunnelTracking
     * @example
     * // Get one FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FunnelTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunnelTrackings
     * const funnelTrackings = await prisma.funnelTracking.findMany()
     * 
     * // Get first 10 FunnelTrackings
     * const funnelTrackings = await prisma.funnelTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelTrackingWithIdOnly = await prisma.funnelTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelTrackingFindManyArgs>(args?: SelectSubset<T, FunnelTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FunnelTracking.
     * @param {FunnelTrackingCreateArgs} args - Arguments to create a FunnelTracking.
     * @example
     * // Create one FunnelTracking
     * const FunnelTracking = await prisma.funnelTracking.create({
     *   data: {
     *     // ... data to create a FunnelTracking
     *   }
     * })
     * 
     */
    create<T extends FunnelTrackingCreateArgs>(args: SelectSubset<T, FunnelTrackingCreateArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FunnelTrackings.
     * @param {FunnelTrackingCreateManyArgs} args - Arguments to create many FunnelTrackings.
     * @example
     * // Create many FunnelTrackings
     * const funnelTracking = await prisma.funnelTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelTrackingCreateManyArgs>(args?: SelectSubset<T, FunnelTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FunnelTrackings and returns the data saved in the database.
     * @param {FunnelTrackingCreateManyAndReturnArgs} args - Arguments to create many FunnelTrackings.
     * @example
     * // Create many FunnelTrackings
     * const funnelTracking = await prisma.funnelTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FunnelTrackings and only return the `id`
     * const funnelTrackingWithIdOnly = await prisma.funnelTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FunnelTracking.
     * @param {FunnelTrackingDeleteArgs} args - Arguments to delete one FunnelTracking.
     * @example
     * // Delete one FunnelTracking
     * const FunnelTracking = await prisma.funnelTracking.delete({
     *   where: {
     *     // ... filter to delete one FunnelTracking
     *   }
     * })
     * 
     */
    delete<T extends FunnelTrackingDeleteArgs>(args: SelectSubset<T, FunnelTrackingDeleteArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FunnelTracking.
     * @param {FunnelTrackingUpdateArgs} args - Arguments to update one FunnelTracking.
     * @example
     * // Update one FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelTrackingUpdateArgs>(args: SelectSubset<T, FunnelTrackingUpdateArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FunnelTrackings.
     * @param {FunnelTrackingDeleteManyArgs} args - Arguments to filter FunnelTrackings to delete.
     * @example
     * // Delete a few FunnelTrackings
     * const { count } = await prisma.funnelTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelTrackingDeleteManyArgs>(args?: SelectSubset<T, FunnelTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunnelTrackings
     * const funnelTracking = await prisma.funnelTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelTrackingUpdateManyArgs>(args: SelectSubset<T, FunnelTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelTrackings and returns the data updated in the database.
     * @param {FunnelTrackingUpdateManyAndReturnArgs} args - Arguments to update many FunnelTrackings.
     * @example
     * // Update many FunnelTrackings
     * const funnelTracking = await prisma.funnelTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FunnelTrackings and only return the `id`
     * const funnelTrackingWithIdOnly = await prisma.funnelTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FunnelTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, FunnelTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FunnelTracking.
     * @param {FunnelTrackingUpsertArgs} args - Arguments to update or create a FunnelTracking.
     * @example
     * // Update or create a FunnelTracking
     * const funnelTracking = await prisma.funnelTracking.upsert({
     *   create: {
     *     // ... data to create a FunnelTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunnelTracking we want to update
     *   }
     * })
     */
    upsert<T extends FunnelTrackingUpsertArgs>(args: SelectSubset<T, FunnelTrackingUpsertArgs<ExtArgs>>): Prisma__FunnelTrackingClient<$Result.GetResult<Prisma.$FunnelTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FunnelTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingCountArgs} args - Arguments to filter FunnelTrackings to count.
     * @example
     * // Count the number of FunnelTrackings
     * const count = await prisma.funnelTracking.count({
     *   where: {
     *     // ... the filter for the FunnelTrackings we want to count
     *   }
     * })
    **/
    count<T extends FunnelTrackingCountArgs>(
      args?: Subset<T, FunnelTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunnelTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelTrackingAggregateArgs>(args: Subset<T, FunnelTrackingAggregateArgs>): Prisma.PrismaPromise<GetFunnelTrackingAggregateType<T>>

    /**
     * Group by FunnelTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelTrackingGroupByArgs['orderBy'] }
        : { orderBy?: FunnelTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunnelTracking model
   */
  readonly fields: FunnelTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunnelTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunnelTracking model
   */
  interface FunnelTrackingFieldRefs {
    readonly id: FieldRef<"FunnelTracking", 'String'>
    readonly sessionId: FieldRef<"FunnelTracking", 'String'>
    readonly guestEmail: FieldRef<"FunnelTracking", 'String'>
    readonly guestPhone: FieldRef<"FunnelTracking", 'String'>
    readonly eventId: FieldRef<"FunnelTracking", 'String'>
    readonly step: FieldRef<"FunnelTracking", 'String'>
    readonly metadata: FieldRef<"FunnelTracking", 'Json'>
    readonly userAgent: FieldRef<"FunnelTracking", 'String'>
    readonly ipAddress: FieldRef<"FunnelTracking", 'String'>
    readonly referer: FieldRef<"FunnelTracking", 'String'>
    readonly timestamp: FieldRef<"FunnelTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FunnelTracking findUnique
   */
  export type FunnelTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter, which FunnelTracking to fetch.
     */
    where: FunnelTrackingWhereUniqueInput
  }

  /**
   * FunnelTracking findUniqueOrThrow
   */
  export type FunnelTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter, which FunnelTracking to fetch.
     */
    where: FunnelTrackingWhereUniqueInput
  }

  /**
   * FunnelTracking findFirst
   */
  export type FunnelTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter, which FunnelTracking to fetch.
     */
    where?: FunnelTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelTrackings to fetch.
     */
    orderBy?: FunnelTrackingOrderByWithRelationInput | FunnelTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelTrackings.
     */
    cursor?: FunnelTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelTrackings.
     */
    distinct?: FunnelTrackingScalarFieldEnum | FunnelTrackingScalarFieldEnum[]
  }

  /**
   * FunnelTracking findFirstOrThrow
   */
  export type FunnelTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter, which FunnelTracking to fetch.
     */
    where?: FunnelTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelTrackings to fetch.
     */
    orderBy?: FunnelTrackingOrderByWithRelationInput | FunnelTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelTrackings.
     */
    cursor?: FunnelTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelTrackings.
     */
    distinct?: FunnelTrackingScalarFieldEnum | FunnelTrackingScalarFieldEnum[]
  }

  /**
   * FunnelTracking findMany
   */
  export type FunnelTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter, which FunnelTrackings to fetch.
     */
    where?: FunnelTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelTrackings to fetch.
     */
    orderBy?: FunnelTrackingOrderByWithRelationInput | FunnelTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunnelTrackings.
     */
    cursor?: FunnelTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelTrackings.
     */
    skip?: number
    distinct?: FunnelTrackingScalarFieldEnum | FunnelTrackingScalarFieldEnum[]
  }

  /**
   * FunnelTracking create
   */
  export type FunnelTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a FunnelTracking.
     */
    data: XOR<FunnelTrackingCreateInput, FunnelTrackingUncheckedCreateInput>
  }

  /**
   * FunnelTracking createMany
   */
  export type FunnelTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunnelTrackings.
     */
    data: FunnelTrackingCreateManyInput | FunnelTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunnelTracking createManyAndReturn
   */
  export type FunnelTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many FunnelTrackings.
     */
    data: FunnelTrackingCreateManyInput | FunnelTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunnelTracking update
   */
  export type FunnelTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a FunnelTracking.
     */
    data: XOR<FunnelTrackingUpdateInput, FunnelTrackingUncheckedUpdateInput>
    /**
     * Choose, which FunnelTracking to update.
     */
    where: FunnelTrackingWhereUniqueInput
  }

  /**
   * FunnelTracking updateMany
   */
  export type FunnelTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunnelTrackings.
     */
    data: XOR<FunnelTrackingUpdateManyMutationInput, FunnelTrackingUncheckedUpdateManyInput>
    /**
     * Filter which FunnelTrackings to update
     */
    where?: FunnelTrackingWhereInput
    /**
     * Limit how many FunnelTrackings to update.
     */
    limit?: number
  }

  /**
   * FunnelTracking updateManyAndReturn
   */
  export type FunnelTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * The data used to update FunnelTrackings.
     */
    data: XOR<FunnelTrackingUpdateManyMutationInput, FunnelTrackingUncheckedUpdateManyInput>
    /**
     * Filter which FunnelTrackings to update
     */
    where?: FunnelTrackingWhereInput
    /**
     * Limit how many FunnelTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunnelTracking upsert
   */
  export type FunnelTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the FunnelTracking to update in case it exists.
     */
    where: FunnelTrackingWhereUniqueInput
    /**
     * In case the FunnelTracking found by the `where` argument doesn't exist, create a new FunnelTracking with this data.
     */
    create: XOR<FunnelTrackingCreateInput, FunnelTrackingUncheckedCreateInput>
    /**
     * In case the FunnelTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelTrackingUpdateInput, FunnelTrackingUncheckedUpdateInput>
  }

  /**
   * FunnelTracking delete
   */
  export type FunnelTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
    /**
     * Filter which FunnelTracking to delete.
     */
    where: FunnelTrackingWhereUniqueInput
  }

  /**
   * FunnelTracking deleteMany
   */
  export type FunnelTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelTrackings to delete
     */
    where?: FunnelTrackingWhereInput
    /**
     * Limit how many FunnelTrackings to delete.
     */
    limit?: number
  }

  /**
   * FunnelTracking without action
   */
  export type FunnelTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelTracking
     */
    select?: FunnelTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelTracking
     */
    omit?: FunnelTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelTrackingInclude<ExtArgs> | null
  }


  /**
   * Model EventFeedback
   */

  export type AggregateEventFeedback = {
    _count: EventFeedbackCountAggregateOutputType | null
    _avg: EventFeedbackAvgAggregateOutputType | null
    _sum: EventFeedbackSumAggregateOutputType | null
    _min: EventFeedbackMinAggregateOutputType | null
    _max: EventFeedbackMaxAggregateOutputType | null
  }

  export type EventFeedbackAvgAggregateOutputType = {
    overallRating: number | null
    musicRating: number | null
    serviceRating: number | null
    venueRating: number | null
  }

  export type EventFeedbackSumAggregateOutputType = {
    overallRating: number | null
    musicRating: number | null
    serviceRating: number | null
    venueRating: number | null
  }

  export type EventFeedbackMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    ticketId: string | null
    guestId: string | null
    overallRating: number | null
    musicRating: number | null
    serviceRating: number | null
    venueRating: number | null
    comment: string | null
    wouldReturn: boolean | null
    createdAt: Date | null
  }

  export type EventFeedbackMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    ticketId: string | null
    guestId: string | null
    overallRating: number | null
    musicRating: number | null
    serviceRating: number | null
    venueRating: number | null
    comment: string | null
    wouldReturn: boolean | null
    createdAt: Date | null
  }

  export type EventFeedbackCountAggregateOutputType = {
    id: number
    eventId: number
    ticketId: number
    guestId: number
    overallRating: number
    musicRating: number
    serviceRating: number
    venueRating: number
    comment: number
    wouldReturn: number
    interests: number
    createdAt: number
    _all: number
  }


  export type EventFeedbackAvgAggregateInputType = {
    overallRating?: true
    musicRating?: true
    serviceRating?: true
    venueRating?: true
  }

  export type EventFeedbackSumAggregateInputType = {
    overallRating?: true
    musicRating?: true
    serviceRating?: true
    venueRating?: true
  }

  export type EventFeedbackMinAggregateInputType = {
    id?: true
    eventId?: true
    ticketId?: true
    guestId?: true
    overallRating?: true
    musicRating?: true
    serviceRating?: true
    venueRating?: true
    comment?: true
    wouldReturn?: true
    createdAt?: true
  }

  export type EventFeedbackMaxAggregateInputType = {
    id?: true
    eventId?: true
    ticketId?: true
    guestId?: true
    overallRating?: true
    musicRating?: true
    serviceRating?: true
    venueRating?: true
    comment?: true
    wouldReturn?: true
    createdAt?: true
  }

  export type EventFeedbackCountAggregateInputType = {
    id?: true
    eventId?: true
    ticketId?: true
    guestId?: true
    overallRating?: true
    musicRating?: true
    serviceRating?: true
    venueRating?: true
    comment?: true
    wouldReturn?: true
    interests?: true
    createdAt?: true
    _all?: true
  }

  export type EventFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventFeedback to aggregate.
     */
    where?: EventFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventFeedbacks to fetch.
     */
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventFeedbacks
    **/
    _count?: true | EventFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventFeedbackMaxAggregateInputType
  }

  export type GetEventFeedbackAggregateType<T extends EventFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateEventFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventFeedback[P]>
      : GetScalarType<T[P], AggregateEventFeedback[P]>
  }




  export type EventFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventFeedbackWhereInput
    orderBy?: EventFeedbackOrderByWithAggregationInput | EventFeedbackOrderByWithAggregationInput[]
    by: EventFeedbackScalarFieldEnum[] | EventFeedbackScalarFieldEnum
    having?: EventFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventFeedbackCountAggregateInputType | true
    _avg?: EventFeedbackAvgAggregateInputType
    _sum?: EventFeedbackSumAggregateInputType
    _min?: EventFeedbackMinAggregateInputType
    _max?: EventFeedbackMaxAggregateInputType
  }

  export type EventFeedbackGroupByOutputType = {
    id: string
    eventId: string
    ticketId: string | null
    guestId: string | null
    overallRating: number
    musicRating: number | null
    serviceRating: number | null
    venueRating: number | null
    comment: string | null
    wouldReturn: boolean | null
    interests: JsonValue | null
    createdAt: Date
    _count: EventFeedbackCountAggregateOutputType | null
    _avg: EventFeedbackAvgAggregateOutputType | null
    _sum: EventFeedbackSumAggregateOutputType | null
    _min: EventFeedbackMinAggregateOutputType | null
    _max: EventFeedbackMaxAggregateOutputType | null
  }

  type GetEventFeedbackGroupByPayload<T extends EventFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], EventFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type EventFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    ticketId?: boolean
    guestId?: boolean
    overallRating?: boolean
    musicRating?: boolean
    serviceRating?: boolean
    venueRating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    interests?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["eventFeedback"]>

  export type EventFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    ticketId?: boolean
    guestId?: boolean
    overallRating?: boolean
    musicRating?: boolean
    serviceRating?: boolean
    venueRating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    interests?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["eventFeedback"]>

  export type EventFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    ticketId?: boolean
    guestId?: boolean
    overallRating?: boolean
    musicRating?: boolean
    serviceRating?: boolean
    venueRating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    interests?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["eventFeedback"]>

  export type EventFeedbackSelectScalar = {
    id?: boolean
    eventId?: boolean
    ticketId?: boolean
    guestId?: boolean
    overallRating?: boolean
    musicRating?: boolean
    serviceRating?: boolean
    venueRating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    interests?: boolean
    createdAt?: boolean
  }

  export type EventFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "ticketId" | "guestId" | "overallRating" | "musicRating" | "serviceRating" | "venueRating" | "comment" | "wouldReturn" | "interests" | "createdAt", ExtArgs["result"]["eventFeedback"]>
  export type EventFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }
  export type EventFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }
  export type EventFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    guest?: boolean | EventFeedback$guestArgs<ExtArgs>
    ticket?: boolean | EventFeedback$ticketArgs<ExtArgs>
  }

  export type $EventFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventFeedback"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      guest: Prisma.$GuestPayload<ExtArgs> | null
      ticket: Prisma.$TicketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      ticketId: string | null
      guestId: string | null
      overallRating: number
      musicRating: number | null
      serviceRating: number | null
      venueRating: number | null
      comment: string | null
      wouldReturn: boolean | null
      interests: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["eventFeedback"]>
    composites: {}
  }

  type EventFeedbackGetPayload<S extends boolean | null | undefined | EventFeedbackDefaultArgs> = $Result.GetResult<Prisma.$EventFeedbackPayload, S>

  type EventFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventFeedbackCountAggregateInputType | true
    }

  export interface EventFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventFeedback'], meta: { name: 'EventFeedback' } }
    /**
     * Find zero or one EventFeedback that matches the filter.
     * @param {EventFeedbackFindUniqueArgs} args - Arguments to find a EventFeedback
     * @example
     * // Get one EventFeedback
     * const eventFeedback = await prisma.eventFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFeedbackFindUniqueArgs>(args: SelectSubset<T, EventFeedbackFindUniqueArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFeedbackFindUniqueOrThrowArgs} args - Arguments to find a EventFeedback
     * @example
     * // Get one EventFeedback
     * const eventFeedback = await prisma.eventFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackFindFirstArgs} args - Arguments to find a EventFeedback
     * @example
     * // Get one EventFeedback
     * const eventFeedback = await prisma.eventFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFeedbackFindFirstArgs>(args?: SelectSubset<T, EventFeedbackFindFirstArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackFindFirstOrThrowArgs} args - Arguments to find a EventFeedback
     * @example
     * // Get one EventFeedback
     * const eventFeedback = await prisma.eventFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventFeedbacks
     * const eventFeedbacks = await prisma.eventFeedback.findMany()
     * 
     * // Get first 10 EventFeedbacks
     * const eventFeedbacks = await prisma.eventFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventFeedbackWithIdOnly = await prisma.eventFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFeedbackFindManyArgs>(args?: SelectSubset<T, EventFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventFeedback.
     * @param {EventFeedbackCreateArgs} args - Arguments to create a EventFeedback.
     * @example
     * // Create one EventFeedback
     * const EventFeedback = await prisma.eventFeedback.create({
     *   data: {
     *     // ... data to create a EventFeedback
     *   }
     * })
     * 
     */
    create<T extends EventFeedbackCreateArgs>(args: SelectSubset<T, EventFeedbackCreateArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventFeedbacks.
     * @param {EventFeedbackCreateManyArgs} args - Arguments to create many EventFeedbacks.
     * @example
     * // Create many EventFeedbacks
     * const eventFeedback = await prisma.eventFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventFeedbackCreateManyArgs>(args?: SelectSubset<T, EventFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventFeedbacks and returns the data saved in the database.
     * @param {EventFeedbackCreateManyAndReturnArgs} args - Arguments to create many EventFeedbacks.
     * @example
     * // Create many EventFeedbacks
     * const eventFeedback = await prisma.eventFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventFeedbacks and only return the `id`
     * const eventFeedbackWithIdOnly = await prisma.eventFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, EventFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventFeedback.
     * @param {EventFeedbackDeleteArgs} args - Arguments to delete one EventFeedback.
     * @example
     * // Delete one EventFeedback
     * const EventFeedback = await prisma.eventFeedback.delete({
     *   where: {
     *     // ... filter to delete one EventFeedback
     *   }
     * })
     * 
     */
    delete<T extends EventFeedbackDeleteArgs>(args: SelectSubset<T, EventFeedbackDeleteArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventFeedback.
     * @param {EventFeedbackUpdateArgs} args - Arguments to update one EventFeedback.
     * @example
     * // Update one EventFeedback
     * const eventFeedback = await prisma.eventFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventFeedbackUpdateArgs>(args: SelectSubset<T, EventFeedbackUpdateArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventFeedbacks.
     * @param {EventFeedbackDeleteManyArgs} args - Arguments to filter EventFeedbacks to delete.
     * @example
     * // Delete a few EventFeedbacks
     * const { count } = await prisma.eventFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventFeedbackDeleteManyArgs>(args?: SelectSubset<T, EventFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventFeedbacks
     * const eventFeedback = await prisma.eventFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventFeedbackUpdateManyArgs>(args: SelectSubset<T, EventFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventFeedbacks and returns the data updated in the database.
     * @param {EventFeedbackUpdateManyAndReturnArgs} args - Arguments to update many EventFeedbacks.
     * @example
     * // Update many EventFeedbacks
     * const eventFeedback = await prisma.eventFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventFeedbacks and only return the `id`
     * const eventFeedbackWithIdOnly = await prisma.eventFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, EventFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventFeedback.
     * @param {EventFeedbackUpsertArgs} args - Arguments to update or create a EventFeedback.
     * @example
     * // Update or create a EventFeedback
     * const eventFeedback = await prisma.eventFeedback.upsert({
     *   create: {
     *     // ... data to create a EventFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventFeedback we want to update
     *   }
     * })
     */
    upsert<T extends EventFeedbackUpsertArgs>(args: SelectSubset<T, EventFeedbackUpsertArgs<ExtArgs>>): Prisma__EventFeedbackClient<$Result.GetResult<Prisma.$EventFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackCountArgs} args - Arguments to filter EventFeedbacks to count.
     * @example
     * // Count the number of EventFeedbacks
     * const count = await prisma.eventFeedback.count({
     *   where: {
     *     // ... the filter for the EventFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends EventFeedbackCountArgs>(
      args?: Subset<T, EventFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventFeedbackAggregateArgs>(args: Subset<T, EventFeedbackAggregateArgs>): Prisma.PrismaPromise<GetEventFeedbackAggregateType<T>>

    /**
     * Group by EventFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: EventFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventFeedback model
   */
  readonly fields: EventFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guest<T extends EventFeedback$guestArgs<ExtArgs> = {}>(args?: Subset<T, EventFeedback$guestArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ticket<T extends EventFeedback$ticketArgs<ExtArgs> = {}>(args?: Subset<T, EventFeedback$ticketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventFeedback model
   */
  interface EventFeedbackFieldRefs {
    readonly id: FieldRef<"EventFeedback", 'String'>
    readonly eventId: FieldRef<"EventFeedback", 'String'>
    readonly ticketId: FieldRef<"EventFeedback", 'String'>
    readonly guestId: FieldRef<"EventFeedback", 'String'>
    readonly overallRating: FieldRef<"EventFeedback", 'Int'>
    readonly musicRating: FieldRef<"EventFeedback", 'Int'>
    readonly serviceRating: FieldRef<"EventFeedback", 'Int'>
    readonly venueRating: FieldRef<"EventFeedback", 'Int'>
    readonly comment: FieldRef<"EventFeedback", 'String'>
    readonly wouldReturn: FieldRef<"EventFeedback", 'Boolean'>
    readonly interests: FieldRef<"EventFeedback", 'Json'>
    readonly createdAt: FieldRef<"EventFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventFeedback findUnique
   */
  export type EventFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which EventFeedback to fetch.
     */
    where: EventFeedbackWhereUniqueInput
  }

  /**
   * EventFeedback findUniqueOrThrow
   */
  export type EventFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which EventFeedback to fetch.
     */
    where: EventFeedbackWhereUniqueInput
  }

  /**
   * EventFeedback findFirst
   */
  export type EventFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which EventFeedback to fetch.
     */
    where?: EventFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventFeedbacks to fetch.
     */
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventFeedbacks.
     */
    cursor?: EventFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventFeedbacks.
     */
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * EventFeedback findFirstOrThrow
   */
  export type EventFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which EventFeedback to fetch.
     */
    where?: EventFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventFeedbacks to fetch.
     */
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventFeedbacks.
     */
    cursor?: EventFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventFeedbacks.
     */
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * EventFeedback findMany
   */
  export type EventFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which EventFeedbacks to fetch.
     */
    where?: EventFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventFeedbacks to fetch.
     */
    orderBy?: EventFeedbackOrderByWithRelationInput | EventFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventFeedbacks.
     */
    cursor?: EventFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventFeedbacks.
     */
    skip?: number
    distinct?: EventFeedbackScalarFieldEnum | EventFeedbackScalarFieldEnum[]
  }

  /**
   * EventFeedback create
   */
  export type EventFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a EventFeedback.
     */
    data: XOR<EventFeedbackCreateInput, EventFeedbackUncheckedCreateInput>
  }

  /**
   * EventFeedback createMany
   */
  export type EventFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventFeedbacks.
     */
    data: EventFeedbackCreateManyInput | EventFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventFeedback createManyAndReturn
   */
  export type EventFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many EventFeedbacks.
     */
    data: EventFeedbackCreateManyInput | EventFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventFeedback update
   */
  export type EventFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a EventFeedback.
     */
    data: XOR<EventFeedbackUpdateInput, EventFeedbackUncheckedUpdateInput>
    /**
     * Choose, which EventFeedback to update.
     */
    where: EventFeedbackWhereUniqueInput
  }

  /**
   * EventFeedback updateMany
   */
  export type EventFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventFeedbacks.
     */
    data: XOR<EventFeedbackUpdateManyMutationInput, EventFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which EventFeedbacks to update
     */
    where?: EventFeedbackWhereInput
    /**
     * Limit how many EventFeedbacks to update.
     */
    limit?: number
  }

  /**
   * EventFeedback updateManyAndReturn
   */
  export type EventFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update EventFeedbacks.
     */
    data: XOR<EventFeedbackUpdateManyMutationInput, EventFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which EventFeedbacks to update
     */
    where?: EventFeedbackWhereInput
    /**
     * Limit how many EventFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventFeedback upsert
   */
  export type EventFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the EventFeedback to update in case it exists.
     */
    where: EventFeedbackWhereUniqueInput
    /**
     * In case the EventFeedback found by the `where` argument doesn't exist, create a new EventFeedback with this data.
     */
    create: XOR<EventFeedbackCreateInput, EventFeedbackUncheckedCreateInput>
    /**
     * In case the EventFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventFeedbackUpdateInput, EventFeedbackUncheckedUpdateInput>
  }

  /**
   * EventFeedback delete
   */
  export type EventFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
    /**
     * Filter which EventFeedback to delete.
     */
    where: EventFeedbackWhereUniqueInput
  }

  /**
   * EventFeedback deleteMany
   */
  export type EventFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventFeedbacks to delete
     */
    where?: EventFeedbackWhereInput
    /**
     * Limit how many EventFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * EventFeedback.guest
   */
  export type EventFeedback$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
  }

  /**
   * EventFeedback.ticket
   */
  export type EventFeedback$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * EventFeedback without action
   */
  export type EventFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventFeedback
     */
    select?: EventFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventFeedback
     */
    omit?: EventFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model SecurityNote
   */

  export type AggregateSecurityNote = {
    _count: SecurityNoteCountAggregateOutputType | null
    _min: SecurityNoteMinAggregateOutputType | null
    _max: SecurityNoteMaxAggregateOutputType | null
  }

  export type SecurityNoteMinAggregateOutputType = {
    id: string | null
    guestId: string | null
    eventId: string | null
    ticketId: string | null
    severity: string | null
    type: string | null
    description: string | null
    reportedByUserId: string | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type SecurityNoteMaxAggregateOutputType = {
    id: string | null
    guestId: string | null
    eventId: string | null
    ticketId: string | null
    severity: string | null
    type: string | null
    description: string | null
    reportedByUserId: string | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type SecurityNoteCountAggregateOutputType = {
    id: number
    guestId: number
    eventId: number
    ticketId: number
    severity: number
    type: number
    description: number
    reportedByUserId: number
    actionTaken: number
    createdAt: number
    _all: number
  }


  export type SecurityNoteMinAggregateInputType = {
    id?: true
    guestId?: true
    eventId?: true
    ticketId?: true
    severity?: true
    type?: true
    description?: true
    reportedByUserId?: true
    actionTaken?: true
    createdAt?: true
  }

  export type SecurityNoteMaxAggregateInputType = {
    id?: true
    guestId?: true
    eventId?: true
    ticketId?: true
    severity?: true
    type?: true
    description?: true
    reportedByUserId?: true
    actionTaken?: true
    createdAt?: true
  }

  export type SecurityNoteCountAggregateInputType = {
    id?: true
    guestId?: true
    eventId?: true
    ticketId?: true
    severity?: true
    type?: true
    description?: true
    reportedByUserId?: true
    actionTaken?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityNote to aggregate.
     */
    where?: SecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityNotes to fetch.
     */
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityNotes
    **/
    _count?: true | SecurityNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityNoteMaxAggregateInputType
  }

  export type GetSecurityNoteAggregateType<T extends SecurityNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityNote[P]>
      : GetScalarType<T[P], AggregateSecurityNote[P]>
  }




  export type SecurityNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityNoteWhereInput
    orderBy?: SecurityNoteOrderByWithAggregationInput | SecurityNoteOrderByWithAggregationInput[]
    by: SecurityNoteScalarFieldEnum[] | SecurityNoteScalarFieldEnum
    having?: SecurityNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityNoteCountAggregateInputType | true
    _min?: SecurityNoteMinAggregateInputType
    _max?: SecurityNoteMaxAggregateInputType
  }

  export type SecurityNoteGroupByOutputType = {
    id: string
    guestId: string | null
    eventId: string | null
    ticketId: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken: string | null
    createdAt: Date
    _count: SecurityNoteCountAggregateOutputType | null
    _min: SecurityNoteMinAggregateOutputType | null
    _max: SecurityNoteMaxAggregateOutputType | null
  }

  type GetSecurityNoteGroupByPayload<T extends SecurityNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityNoteGroupByOutputType[P]>
        }
      >
    >


  export type SecurityNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    eventId?: boolean
    ticketId?: boolean
    severity?: boolean
    type?: boolean
    description?: boolean
    reportedByUserId?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["securityNote"]>

  export type SecurityNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    eventId?: boolean
    ticketId?: boolean
    severity?: boolean
    type?: boolean
    description?: boolean
    reportedByUserId?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["securityNote"]>

  export type SecurityNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    eventId?: boolean
    ticketId?: boolean
    severity?: boolean
    type?: boolean
    description?: boolean
    reportedByUserId?: boolean
    actionTaken?: boolean
    createdAt?: boolean
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }, ExtArgs["result"]["securityNote"]>

  export type SecurityNoteSelectScalar = {
    id?: boolean
    guestId?: boolean
    eventId?: boolean
    ticketId?: boolean
    severity?: boolean
    type?: boolean
    description?: boolean
    reportedByUserId?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }

  export type SecurityNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guestId" | "eventId" | "ticketId" | "severity" | "type" | "description" | "reportedByUserId" | "actionTaken" | "createdAt", ExtArgs["result"]["securityNote"]>
  export type SecurityNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }
  export type SecurityNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }
  export type SecurityNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | SecurityNote$eventArgs<ExtArgs>
    guest?: boolean | SecurityNote$guestArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | SecurityNote$ticketArgs<ExtArgs>
  }

  export type $SecurityNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityNote"
    objects: {
      event: Prisma.$EventPayload<ExtArgs> | null
      guest: Prisma.$GuestPayload<ExtArgs> | null
      reportedBy: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guestId: string | null
      eventId: string | null
      ticketId: string | null
      severity: string
      type: string
      description: string
      reportedByUserId: string
      actionTaken: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityNote"]>
    composites: {}
  }

  type SecurityNoteGetPayload<S extends boolean | null | undefined | SecurityNoteDefaultArgs> = $Result.GetResult<Prisma.$SecurityNotePayload, S>

  type SecurityNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityNoteCountAggregateInputType | true
    }

  export interface SecurityNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityNote'], meta: { name: 'SecurityNote' } }
    /**
     * Find zero or one SecurityNote that matches the filter.
     * @param {SecurityNoteFindUniqueArgs} args - Arguments to find a SecurityNote
     * @example
     * // Get one SecurityNote
     * const securityNote = await prisma.securityNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityNoteFindUniqueArgs>(args: SelectSubset<T, SecurityNoteFindUniqueArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityNoteFindUniqueOrThrowArgs} args - Arguments to find a SecurityNote
     * @example
     * // Get one SecurityNote
     * const securityNote = await prisma.securityNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteFindFirstArgs} args - Arguments to find a SecurityNote
     * @example
     * // Get one SecurityNote
     * const securityNote = await prisma.securityNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityNoteFindFirstArgs>(args?: SelectSubset<T, SecurityNoteFindFirstArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteFindFirstOrThrowArgs} args - Arguments to find a SecurityNote
     * @example
     * // Get one SecurityNote
     * const securityNote = await prisma.securityNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityNotes
     * const securityNotes = await prisma.securityNote.findMany()
     * 
     * // Get first 10 SecurityNotes
     * const securityNotes = await prisma.securityNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityNoteWithIdOnly = await prisma.securityNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityNoteFindManyArgs>(args?: SelectSubset<T, SecurityNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityNote.
     * @param {SecurityNoteCreateArgs} args - Arguments to create a SecurityNote.
     * @example
     * // Create one SecurityNote
     * const SecurityNote = await prisma.securityNote.create({
     *   data: {
     *     // ... data to create a SecurityNote
     *   }
     * })
     * 
     */
    create<T extends SecurityNoteCreateArgs>(args: SelectSubset<T, SecurityNoteCreateArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityNotes.
     * @param {SecurityNoteCreateManyArgs} args - Arguments to create many SecurityNotes.
     * @example
     * // Create many SecurityNotes
     * const securityNote = await prisma.securityNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityNoteCreateManyArgs>(args?: SelectSubset<T, SecurityNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityNotes and returns the data saved in the database.
     * @param {SecurityNoteCreateManyAndReturnArgs} args - Arguments to create many SecurityNotes.
     * @example
     * // Create many SecurityNotes
     * const securityNote = await prisma.securityNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityNotes and only return the `id`
     * const securityNoteWithIdOnly = await prisma.securityNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityNote.
     * @param {SecurityNoteDeleteArgs} args - Arguments to delete one SecurityNote.
     * @example
     * // Delete one SecurityNote
     * const SecurityNote = await prisma.securityNote.delete({
     *   where: {
     *     // ... filter to delete one SecurityNote
     *   }
     * })
     * 
     */
    delete<T extends SecurityNoteDeleteArgs>(args: SelectSubset<T, SecurityNoteDeleteArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityNote.
     * @param {SecurityNoteUpdateArgs} args - Arguments to update one SecurityNote.
     * @example
     * // Update one SecurityNote
     * const securityNote = await prisma.securityNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityNoteUpdateArgs>(args: SelectSubset<T, SecurityNoteUpdateArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityNotes.
     * @param {SecurityNoteDeleteManyArgs} args - Arguments to filter SecurityNotes to delete.
     * @example
     * // Delete a few SecurityNotes
     * const { count } = await prisma.securityNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityNoteDeleteManyArgs>(args?: SelectSubset<T, SecurityNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityNotes
     * const securityNote = await prisma.securityNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityNoteUpdateManyArgs>(args: SelectSubset<T, SecurityNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityNotes and returns the data updated in the database.
     * @param {SecurityNoteUpdateManyAndReturnArgs} args - Arguments to update many SecurityNotes.
     * @example
     * // Update many SecurityNotes
     * const securityNote = await prisma.securityNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SecurityNotes and only return the `id`
     * const securityNoteWithIdOnly = await prisma.securityNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SecurityNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityNote.
     * @param {SecurityNoteUpsertArgs} args - Arguments to update or create a SecurityNote.
     * @example
     * // Update or create a SecurityNote
     * const securityNote = await prisma.securityNote.upsert({
     *   create: {
     *     // ... data to create a SecurityNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityNote we want to update
     *   }
     * })
     */
    upsert<T extends SecurityNoteUpsertArgs>(args: SelectSubset<T, SecurityNoteUpsertArgs<ExtArgs>>): Prisma__SecurityNoteClient<$Result.GetResult<Prisma.$SecurityNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteCountArgs} args - Arguments to filter SecurityNotes to count.
     * @example
     * // Count the number of SecurityNotes
     * const count = await prisma.securityNote.count({
     *   where: {
     *     // ... the filter for the SecurityNotes we want to count
     *   }
     * })
    **/
    count<T extends SecurityNoteCountArgs>(
      args?: Subset<T, SecurityNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityNoteAggregateArgs>(args: Subset<T, SecurityNoteAggregateArgs>): Prisma.PrismaPromise<GetSecurityNoteAggregateType<T>>

    /**
     * Group by SecurityNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityNoteGroupByArgs['orderBy'] }
        : { orderBy?: SecurityNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityNote model
   */
  readonly fields: SecurityNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends SecurityNote$eventArgs<ExtArgs> = {}>(args?: Subset<T, SecurityNote$eventArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guest<T extends SecurityNote$guestArgs<ExtArgs> = {}>(args?: Subset<T, SecurityNote$guestArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends SecurityNote$ticketArgs<ExtArgs> = {}>(args?: Subset<T, SecurityNote$ticketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityNote model
   */
  interface SecurityNoteFieldRefs {
    readonly id: FieldRef<"SecurityNote", 'String'>
    readonly guestId: FieldRef<"SecurityNote", 'String'>
    readonly eventId: FieldRef<"SecurityNote", 'String'>
    readonly ticketId: FieldRef<"SecurityNote", 'String'>
    readonly severity: FieldRef<"SecurityNote", 'String'>
    readonly type: FieldRef<"SecurityNote", 'String'>
    readonly description: FieldRef<"SecurityNote", 'String'>
    readonly reportedByUserId: FieldRef<"SecurityNote", 'String'>
    readonly actionTaken: FieldRef<"SecurityNote", 'String'>
    readonly createdAt: FieldRef<"SecurityNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityNote findUnique
   */
  export type SecurityNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which SecurityNote to fetch.
     */
    where: SecurityNoteWhereUniqueInput
  }

  /**
   * SecurityNote findUniqueOrThrow
   */
  export type SecurityNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which SecurityNote to fetch.
     */
    where: SecurityNoteWhereUniqueInput
  }

  /**
   * SecurityNote findFirst
   */
  export type SecurityNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which SecurityNote to fetch.
     */
    where?: SecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityNotes to fetch.
     */
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityNotes.
     */
    cursor?: SecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityNotes.
     */
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * SecurityNote findFirstOrThrow
   */
  export type SecurityNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which SecurityNote to fetch.
     */
    where?: SecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityNotes to fetch.
     */
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityNotes.
     */
    cursor?: SecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityNotes.
     */
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * SecurityNote findMany
   */
  export type SecurityNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which SecurityNotes to fetch.
     */
    where?: SecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityNotes to fetch.
     */
    orderBy?: SecurityNoteOrderByWithRelationInput | SecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityNotes.
     */
    cursor?: SecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityNotes.
     */
    skip?: number
    distinct?: SecurityNoteScalarFieldEnum | SecurityNoteScalarFieldEnum[]
  }

  /**
   * SecurityNote create
   */
  export type SecurityNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SecurityNote.
     */
    data: XOR<SecurityNoteCreateInput, SecurityNoteUncheckedCreateInput>
  }

  /**
   * SecurityNote createMany
   */
  export type SecurityNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityNotes.
     */
    data: SecurityNoteCreateManyInput | SecurityNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityNote createManyAndReturn
   */
  export type SecurityNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityNotes.
     */
    data: SecurityNoteCreateManyInput | SecurityNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityNote update
   */
  export type SecurityNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SecurityNote.
     */
    data: XOR<SecurityNoteUpdateInput, SecurityNoteUncheckedUpdateInput>
    /**
     * Choose, which SecurityNote to update.
     */
    where: SecurityNoteWhereUniqueInput
  }

  /**
   * SecurityNote updateMany
   */
  export type SecurityNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityNotes.
     */
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyInput>
    /**
     * Filter which SecurityNotes to update
     */
    where?: SecurityNoteWhereInput
    /**
     * Limit how many SecurityNotes to update.
     */
    limit?: number
  }

  /**
   * SecurityNote updateManyAndReturn
   */
  export type SecurityNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * The data used to update SecurityNotes.
     */
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyInput>
    /**
     * Filter which SecurityNotes to update
     */
    where?: SecurityNoteWhereInput
    /**
     * Limit how many SecurityNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SecurityNote upsert
   */
  export type SecurityNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SecurityNote to update in case it exists.
     */
    where: SecurityNoteWhereUniqueInput
    /**
     * In case the SecurityNote found by the `where` argument doesn't exist, create a new SecurityNote with this data.
     */
    create: XOR<SecurityNoteCreateInput, SecurityNoteUncheckedCreateInput>
    /**
     * In case the SecurityNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityNoteUpdateInput, SecurityNoteUncheckedUpdateInput>
  }

  /**
   * SecurityNote delete
   */
  export type SecurityNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
    /**
     * Filter which SecurityNote to delete.
     */
    where: SecurityNoteWhereUniqueInput
  }

  /**
   * SecurityNote deleteMany
   */
  export type SecurityNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityNotes to delete
     */
    where?: SecurityNoteWhereInput
    /**
     * Limit how many SecurityNotes to delete.
     */
    limit?: number
  }

  /**
   * SecurityNote.event
   */
  export type SecurityNote$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
  }

  /**
   * SecurityNote.guest
   */
  export type SecurityNote$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
  }

  /**
   * SecurityNote.ticket
   */
  export type SecurityNote$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * SecurityNote without action
   */
  export type SecurityNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityNote
     */
    select?: SecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityNote
     */
    omit?: SecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SecurityNoteInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPreferences
   */

  export type AggregateCustomerPreferences = {
    _count: CustomerPreferencesCountAggregateOutputType | null
    _avg: CustomerPreferencesAvgAggregateOutputType | null
    _sum: CustomerPreferencesSumAggregateOutputType | null
    _min: CustomerPreferencesMinAggregateOutputType | null
    _max: CustomerPreferencesMaxAggregateOutputType | null
  }

  export type CustomerPreferencesAvgAggregateOutputType = {
    avgSpending: number | null
    conversionScore: number | null
    lifetimeValue: number | null
  }

  export type CustomerPreferencesSumAggregateOutputType = {
    avgSpending: number | null
    conversionScore: number | null
    lifetimeValue: number | null
  }

  export type CustomerPreferencesMinAggregateOutputType = {
    id: string | null
    guestId: string | null
    dressStyle: string | null
    avgSpending: number | null
    responseToPromo: string | null
    socialEngagement: string | null
    conversionScore: number | null
    lifetimeValue: number | null
    updatedAt: Date | null
  }

  export type CustomerPreferencesMaxAggregateOutputType = {
    id: string | null
    guestId: string | null
    dressStyle: string | null
    avgSpending: number | null
    responseToPromo: string | null
    socialEngagement: string | null
    conversionScore: number | null
    lifetimeValue: number | null
    updatedAt: Date | null
  }

  export type CustomerPreferencesCountAggregateOutputType = {
    id: number
    guestId: number
    musicGenres: number
    dressStyle: number
    drinkPreferences: number
    avgSpending: number
    responseToPromo: number
    socialEngagement: number
    conversionScore: number
    lifetimeValue: number
    consents: number
    updatedAt: number
    _all: number
  }


  export type CustomerPreferencesAvgAggregateInputType = {
    avgSpending?: true
    conversionScore?: true
    lifetimeValue?: true
  }

  export type CustomerPreferencesSumAggregateInputType = {
    avgSpending?: true
    conversionScore?: true
    lifetimeValue?: true
  }

  export type CustomerPreferencesMinAggregateInputType = {
    id?: true
    guestId?: true
    dressStyle?: true
    avgSpending?: true
    responseToPromo?: true
    socialEngagement?: true
    conversionScore?: true
    lifetimeValue?: true
    updatedAt?: true
  }

  export type CustomerPreferencesMaxAggregateInputType = {
    id?: true
    guestId?: true
    dressStyle?: true
    avgSpending?: true
    responseToPromo?: true
    socialEngagement?: true
    conversionScore?: true
    lifetimeValue?: true
    updatedAt?: true
  }

  export type CustomerPreferencesCountAggregateInputType = {
    id?: true
    guestId?: true
    musicGenres?: true
    dressStyle?: true
    drinkPreferences?: true
    avgSpending?: true
    responseToPromo?: true
    socialEngagement?: true
    conversionScore?: true
    lifetimeValue?: true
    consents?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPreferences to aggregate.
     */
    where?: CustomerPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPreferences to fetch.
     */
    orderBy?: CustomerPreferencesOrderByWithRelationInput | CustomerPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPreferences
    **/
    _count?: true | CustomerPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPreferencesMaxAggregateInputType
  }

  export type GetCustomerPreferencesAggregateType<T extends CustomerPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPreferences[P]>
      : GetScalarType<T[P], AggregateCustomerPreferences[P]>
  }




  export type CustomerPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPreferencesWhereInput
    orderBy?: CustomerPreferencesOrderByWithAggregationInput | CustomerPreferencesOrderByWithAggregationInput[]
    by: CustomerPreferencesScalarFieldEnum[] | CustomerPreferencesScalarFieldEnum
    having?: CustomerPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPreferencesCountAggregateInputType | true
    _avg?: CustomerPreferencesAvgAggregateInputType
    _sum?: CustomerPreferencesSumAggregateInputType
    _min?: CustomerPreferencesMinAggregateInputType
    _max?: CustomerPreferencesMaxAggregateInputType
  }

  export type CustomerPreferencesGroupByOutputType = {
    id: string
    guestId: string
    musicGenres: JsonValue | null
    dressStyle: string | null
    drinkPreferences: JsonValue | null
    avgSpending: number | null
    responseToPromo: string | null
    socialEngagement: string | null
    conversionScore: number | null
    lifetimeValue: number | null
    consents: JsonValue | null
    updatedAt: Date
    _count: CustomerPreferencesCountAggregateOutputType | null
    _avg: CustomerPreferencesAvgAggregateOutputType | null
    _sum: CustomerPreferencesSumAggregateOutputType | null
    _min: CustomerPreferencesMinAggregateOutputType | null
    _max: CustomerPreferencesMaxAggregateOutputType | null
  }

  type GetCustomerPreferencesGroupByPayload<T extends CustomerPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    musicGenres?: boolean
    dressStyle?: boolean
    drinkPreferences?: boolean
    avgSpending?: boolean
    responseToPromo?: boolean
    socialEngagement?: boolean
    conversionScore?: boolean
    lifetimeValue?: boolean
    consents?: boolean
    updatedAt?: boolean
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPreferences"]>

  export type CustomerPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    musicGenres?: boolean
    dressStyle?: boolean
    drinkPreferences?: boolean
    avgSpending?: boolean
    responseToPromo?: boolean
    socialEngagement?: boolean
    conversionScore?: boolean
    lifetimeValue?: boolean
    consents?: boolean
    updatedAt?: boolean
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPreferences"]>

  export type CustomerPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guestId?: boolean
    musicGenres?: boolean
    dressStyle?: boolean
    drinkPreferences?: boolean
    avgSpending?: boolean
    responseToPromo?: boolean
    socialEngagement?: boolean
    conversionScore?: boolean
    lifetimeValue?: boolean
    consents?: boolean
    updatedAt?: boolean
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPreferences"]>

  export type CustomerPreferencesSelectScalar = {
    id?: boolean
    guestId?: boolean
    musicGenres?: boolean
    dressStyle?: boolean
    drinkPreferences?: boolean
    avgSpending?: boolean
    responseToPromo?: boolean
    socialEngagement?: boolean
    conversionScore?: boolean
    lifetimeValue?: boolean
    consents?: boolean
    updatedAt?: boolean
  }

  export type CustomerPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guestId" | "musicGenres" | "dressStyle" | "drinkPreferences" | "avgSpending" | "responseToPromo" | "socialEngagement" | "conversionScore" | "lifetimeValue" | "consents" | "updatedAt", ExtArgs["result"]["customerPreferences"]>
  export type CustomerPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }
  export type CustomerPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }
  export type CustomerPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }

  export type $CustomerPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPreferences"
    objects: {
      guest: Prisma.$GuestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guestId: string
      musicGenres: Prisma.JsonValue | null
      dressStyle: string | null
      drinkPreferences: Prisma.JsonValue | null
      avgSpending: number | null
      responseToPromo: string | null
      socialEngagement: string | null
      conversionScore: number | null
      lifetimeValue: number | null
      consents: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["customerPreferences"]>
    composites: {}
  }

  type CustomerPreferencesGetPayload<S extends boolean | null | undefined | CustomerPreferencesDefaultArgs> = $Result.GetResult<Prisma.$CustomerPreferencesPayload, S>

  type CustomerPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPreferencesCountAggregateInputType | true
    }

  export interface CustomerPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPreferences'], meta: { name: 'CustomerPreferences' } }
    /**
     * Find zero or one CustomerPreferences that matches the filter.
     * @param {CustomerPreferencesFindUniqueArgs} args - Arguments to find a CustomerPreferences
     * @example
     * // Get one CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPreferencesFindUniqueArgs>(args: SelectSubset<T, CustomerPreferencesFindUniqueArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPreferencesFindUniqueOrThrowArgs} args - Arguments to find a CustomerPreferences
     * @example
     * // Get one CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesFindFirstArgs} args - Arguments to find a CustomerPreferences
     * @example
     * // Get one CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPreferencesFindFirstArgs>(args?: SelectSubset<T, CustomerPreferencesFindFirstArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesFindFirstOrThrowArgs} args - Arguments to find a CustomerPreferences
     * @example
     * // Get one CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findMany()
     * 
     * // Get first 10 CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPreferencesWithIdOnly = await prisma.customerPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPreferencesFindManyArgs>(args?: SelectSubset<T, CustomerPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPreferences.
     * @param {CustomerPreferencesCreateArgs} args - Arguments to create a CustomerPreferences.
     * @example
     * // Create one CustomerPreferences
     * const CustomerPreferences = await prisma.customerPreferences.create({
     *   data: {
     *     // ... data to create a CustomerPreferences
     *   }
     * })
     * 
     */
    create<T extends CustomerPreferencesCreateArgs>(args: SelectSubset<T, CustomerPreferencesCreateArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPreferences.
     * @param {CustomerPreferencesCreateManyArgs} args - Arguments to create many CustomerPreferences.
     * @example
     * // Create many CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPreferencesCreateManyArgs>(args?: SelectSubset<T, CustomerPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPreferences and returns the data saved in the database.
     * @param {CustomerPreferencesCreateManyAndReturnArgs} args - Arguments to create many CustomerPreferences.
     * @example
     * // Create many CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPreferences and only return the `id`
     * const customerPreferencesWithIdOnly = await prisma.customerPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPreferences.
     * @param {CustomerPreferencesDeleteArgs} args - Arguments to delete one CustomerPreferences.
     * @example
     * // Delete one CustomerPreferences
     * const CustomerPreferences = await prisma.customerPreferences.delete({
     *   where: {
     *     // ... filter to delete one CustomerPreferences
     *   }
     * })
     * 
     */
    delete<T extends CustomerPreferencesDeleteArgs>(args: SelectSubset<T, CustomerPreferencesDeleteArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPreferences.
     * @param {CustomerPreferencesUpdateArgs} args - Arguments to update one CustomerPreferences.
     * @example
     * // Update one CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPreferencesUpdateArgs>(args: SelectSubset<T, CustomerPreferencesUpdateArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPreferences.
     * @param {CustomerPreferencesDeleteManyArgs} args - Arguments to filter CustomerPreferences to delete.
     * @example
     * // Delete a few CustomerPreferences
     * const { count } = await prisma.customerPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPreferencesDeleteManyArgs>(args?: SelectSubset<T, CustomerPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPreferencesUpdateManyArgs>(args: SelectSubset<T, CustomerPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPreferences and returns the data updated in the database.
     * @param {CustomerPreferencesUpdateManyAndReturnArgs} args - Arguments to update many CustomerPreferences.
     * @example
     * // Update many CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPreferences and only return the `id`
     * const customerPreferencesWithIdOnly = await prisma.customerPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPreferences.
     * @param {CustomerPreferencesUpsertArgs} args - Arguments to update or create a CustomerPreferences.
     * @example
     * // Update or create a CustomerPreferences
     * const customerPreferences = await prisma.customerPreferences.upsert({
     *   create: {
     *     // ... data to create a CustomerPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPreferences we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPreferencesUpsertArgs>(args: SelectSubset<T, CustomerPreferencesUpsertArgs<ExtArgs>>): Prisma__CustomerPreferencesClient<$Result.GetResult<Prisma.$CustomerPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesCountArgs} args - Arguments to filter CustomerPreferences to count.
     * @example
     * // Count the number of CustomerPreferences
     * const count = await prisma.customerPreferences.count({
     *   where: {
     *     // ... the filter for the CustomerPreferences we want to count
     *   }
     * })
    **/
    count<T extends CustomerPreferencesCountArgs>(
      args?: Subset<T, CustomerPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPreferencesAggregateArgs>(args: Subset<T, CustomerPreferencesAggregateArgs>): Prisma.PrismaPromise<GetCustomerPreferencesAggregateType<T>>

    /**
     * Group by CustomerPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPreferences model
   */
  readonly fields: CustomerPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest<T extends GuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuestDefaultArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPreferences model
   */
  interface CustomerPreferencesFieldRefs {
    readonly id: FieldRef<"CustomerPreferences", 'String'>
    readonly guestId: FieldRef<"CustomerPreferences", 'String'>
    readonly musicGenres: FieldRef<"CustomerPreferences", 'Json'>
    readonly dressStyle: FieldRef<"CustomerPreferences", 'String'>
    readonly drinkPreferences: FieldRef<"CustomerPreferences", 'Json'>
    readonly avgSpending: FieldRef<"CustomerPreferences", 'Float'>
    readonly responseToPromo: FieldRef<"CustomerPreferences", 'String'>
    readonly socialEngagement: FieldRef<"CustomerPreferences", 'String'>
    readonly conversionScore: FieldRef<"CustomerPreferences", 'Float'>
    readonly lifetimeValue: FieldRef<"CustomerPreferences", 'Float'>
    readonly consents: FieldRef<"CustomerPreferences", 'Json'>
    readonly updatedAt: FieldRef<"CustomerPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPreferences findUnique
   */
  export type CustomerPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPreferences to fetch.
     */
    where: CustomerPreferencesWhereUniqueInput
  }

  /**
   * CustomerPreferences findUniqueOrThrow
   */
  export type CustomerPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPreferences to fetch.
     */
    where: CustomerPreferencesWhereUniqueInput
  }

  /**
   * CustomerPreferences findFirst
   */
  export type CustomerPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPreferences to fetch.
     */
    where?: CustomerPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPreferences to fetch.
     */
    orderBy?: CustomerPreferencesOrderByWithRelationInput | CustomerPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPreferences.
     */
    cursor?: CustomerPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPreferences.
     */
    distinct?: CustomerPreferencesScalarFieldEnum | CustomerPreferencesScalarFieldEnum[]
  }

  /**
   * CustomerPreferences findFirstOrThrow
   */
  export type CustomerPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPreferences to fetch.
     */
    where?: CustomerPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPreferences to fetch.
     */
    orderBy?: CustomerPreferencesOrderByWithRelationInput | CustomerPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPreferences.
     */
    cursor?: CustomerPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPreferences.
     */
    distinct?: CustomerPreferencesScalarFieldEnum | CustomerPreferencesScalarFieldEnum[]
  }

  /**
   * CustomerPreferences findMany
   */
  export type CustomerPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPreferences to fetch.
     */
    where?: CustomerPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPreferences to fetch.
     */
    orderBy?: CustomerPreferencesOrderByWithRelationInput | CustomerPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPreferences.
     */
    cursor?: CustomerPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPreferences.
     */
    skip?: number
    distinct?: CustomerPreferencesScalarFieldEnum | CustomerPreferencesScalarFieldEnum[]
  }

  /**
   * CustomerPreferences create
   */
  export type CustomerPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPreferences.
     */
    data: XOR<CustomerPreferencesCreateInput, CustomerPreferencesUncheckedCreateInput>
  }

  /**
   * CustomerPreferences createMany
   */
  export type CustomerPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPreferences.
     */
    data: CustomerPreferencesCreateManyInput | CustomerPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPreferences createManyAndReturn
   */
  export type CustomerPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPreferences.
     */
    data: CustomerPreferencesCreateManyInput | CustomerPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPreferences update
   */
  export type CustomerPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPreferences.
     */
    data: XOR<CustomerPreferencesUpdateInput, CustomerPreferencesUncheckedUpdateInput>
    /**
     * Choose, which CustomerPreferences to update.
     */
    where: CustomerPreferencesWhereUniqueInput
  }

  /**
   * CustomerPreferences updateMany
   */
  export type CustomerPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPreferences.
     */
    data: XOR<CustomerPreferencesUpdateManyMutationInput, CustomerPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPreferences to update
     */
    where?: CustomerPreferencesWhereInput
    /**
     * Limit how many CustomerPreferences to update.
     */
    limit?: number
  }

  /**
   * CustomerPreferences updateManyAndReturn
   */
  export type CustomerPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPreferences.
     */
    data: XOR<CustomerPreferencesUpdateManyMutationInput, CustomerPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPreferences to update
     */
    where?: CustomerPreferencesWhereInput
    /**
     * Limit how many CustomerPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPreferences upsert
   */
  export type CustomerPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPreferences to update in case it exists.
     */
    where: CustomerPreferencesWhereUniqueInput
    /**
     * In case the CustomerPreferences found by the `where` argument doesn't exist, create a new CustomerPreferences with this data.
     */
    create: XOR<CustomerPreferencesCreateInput, CustomerPreferencesUncheckedCreateInput>
    /**
     * In case the CustomerPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPreferencesUpdateInput, CustomerPreferencesUncheckedUpdateInput>
  }

  /**
   * CustomerPreferences delete
   */
  export type CustomerPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
    /**
     * Filter which CustomerPreferences to delete.
     */
    where: CustomerPreferencesWhereUniqueInput
  }

  /**
   * CustomerPreferences deleteMany
   */
  export type CustomerPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPreferences to delete
     */
    where?: CustomerPreferencesWhereInput
    /**
     * Limit how many CustomerPreferences to delete.
     */
    limit?: number
  }

  /**
   * CustomerPreferences without action
   */
  export type CustomerPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPreferences
     */
    select?: CustomerPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPreferences
     */
    omit?: CustomerPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationProfile
   */

  export type AggregateOrganizationProfile = {
    _count: OrganizationProfileCountAggregateOutputType | null
    _avg: OrganizationProfileAvgAggregateOutputType | null
    _sum: OrganizationProfileSumAggregateOutputType | null
    _min: OrganizationProfileMinAggregateOutputType | null
    _max: OrganizationProfileMaxAggregateOutputType | null
  }

  export type OrganizationProfileAvgAggregateOutputType = {
    totalEvents: number | null
    totalAttendees: number | null
  }

  export type OrganizationProfileSumAggregateOutputType = {
    totalEvents: number | null
    totalAttendees: number | null
  }

  export type OrganizationProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    organizationName: string | null
    bio: string | null
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    logo: string | null
    coverImage: string | null
    verified: boolean | null
    totalEvents: number | null
    totalAttendees: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    organizationName: string | null
    bio: string | null
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    logo: string | null
    coverImage: string | null
    verified: boolean | null
    totalEvents: number | null
    totalAttendees: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationProfileCountAggregateOutputType = {
    id: number
    userId: number
    slug: number
    organizationName: number
    bio: number
    website: number
    instagram: number
    facebook: number
    twitter: number
    whatsappNumber: number
    telegramHandle: number
    logo: number
    coverImage: number
    verified: number
    totalEvents: number
    totalAttendees: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationProfileAvgAggregateInputType = {
    totalEvents?: true
    totalAttendees?: true
  }

  export type OrganizationProfileSumAggregateInputType = {
    totalEvents?: true
    totalAttendees?: true
  }

  export type OrganizationProfileMinAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    organizationName?: true
    bio?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    whatsappNumber?: true
    telegramHandle?: true
    logo?: true
    coverImage?: true
    verified?: true
    totalEvents?: true
    totalAttendees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    organizationName?: true
    bio?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    whatsappNumber?: true
    telegramHandle?: true
    logo?: true
    coverImage?: true
    verified?: true
    totalEvents?: true
    totalAttendees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationProfileCountAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    organizationName?: true
    bio?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    whatsappNumber?: true
    telegramHandle?: true
    logo?: true
    coverImage?: true
    verified?: true
    totalEvents?: true
    totalAttendees?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationProfile to aggregate.
     */
    where?: OrganizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationProfiles to fetch.
     */
    orderBy?: OrganizationProfileOrderByWithRelationInput | OrganizationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationProfiles
    **/
    _count?: true | OrganizationProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationProfileMaxAggregateInputType
  }

  export type GetOrganizationProfileAggregateType<T extends OrganizationProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationProfile[P]>
      : GetScalarType<T[P], AggregateOrganizationProfile[P]>
  }




  export type OrganizationProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationProfileWhereInput
    orderBy?: OrganizationProfileOrderByWithAggregationInput | OrganizationProfileOrderByWithAggregationInput[]
    by: OrganizationProfileScalarFieldEnum[] | OrganizationProfileScalarFieldEnum
    having?: OrganizationProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationProfileCountAggregateInputType | true
    _avg?: OrganizationProfileAvgAggregateInputType
    _sum?: OrganizationProfileSumAggregateInputType
    _min?: OrganizationProfileMinAggregateInputType
    _max?: OrganizationProfileMaxAggregateInputType
  }

  export type OrganizationProfileGroupByOutputType = {
    id: string
    userId: string
    slug: string | null
    organizationName: string
    bio: string | null
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    logo: string | null
    coverImage: string | null
    verified: boolean
    totalEvents: number
    totalAttendees: number
    createdAt: Date
    updatedAt: Date
    _count: OrganizationProfileCountAggregateOutputType | null
    _avg: OrganizationProfileAvgAggregateOutputType | null
    _sum: OrganizationProfileSumAggregateOutputType | null
    _min: OrganizationProfileMinAggregateOutputType | null
    _max: OrganizationProfileMaxAggregateOutputType | null
  }

  type GetOrganizationProfileGroupByPayload<T extends OrganizationProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationProfileGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationProfileGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    organizationName?: boolean
    bio?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    logo?: boolean
    coverImage?: boolean
    verified?: boolean
    totalEvents?: boolean
    totalAttendees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    teamMembers?: boolean | OrganizationProfile$teamMembersArgs<ExtArgs>
    _count?: boolean | OrganizationProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationProfile"]>

  export type OrganizationProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    organizationName?: boolean
    bio?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    logo?: boolean
    coverImage?: boolean
    verified?: boolean
    totalEvents?: boolean
    totalAttendees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationProfile"]>

  export type OrganizationProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    organizationName?: boolean
    bio?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    logo?: boolean
    coverImage?: boolean
    verified?: boolean
    totalEvents?: boolean
    totalAttendees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationProfile"]>

  export type OrganizationProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    slug?: boolean
    organizationName?: boolean
    bio?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    logo?: boolean
    coverImage?: boolean
    verified?: boolean
    totalEvents?: boolean
    totalAttendees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "slug" | "organizationName" | "bio" | "website" | "instagram" | "facebook" | "twitter" | "whatsappNumber" | "telegramHandle" | "logo" | "coverImage" | "verified" | "totalEvents" | "totalAttendees" | "createdAt" | "updatedAt", ExtArgs["result"]["organizationProfile"]>
  export type OrganizationProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    teamMembers?: boolean | OrganizationProfile$teamMembersArgs<ExtArgs>
    _count?: boolean | OrganizationProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      teamMembers: Prisma.$OrganizationMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      slug: string | null
      organizationName: string
      bio: string | null
      website: string | null
      instagram: string | null
      facebook: string | null
      twitter: string | null
      whatsappNumber: string | null
      telegramHandle: string | null
      logo: string | null
      coverImage: string | null
      verified: boolean
      totalEvents: number
      totalAttendees: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationProfile"]>
    composites: {}
  }

  type OrganizationProfileGetPayload<S extends boolean | null | undefined | OrganizationProfileDefaultArgs> = $Result.GetResult<Prisma.$OrganizationProfilePayload, S>

  type OrganizationProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationProfileCountAggregateInputType | true
    }

  export interface OrganizationProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationProfile'], meta: { name: 'OrganizationProfile' } }
    /**
     * Find zero or one OrganizationProfile that matches the filter.
     * @param {OrganizationProfileFindUniqueArgs} args - Arguments to find a OrganizationProfile
     * @example
     * // Get one OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationProfileFindUniqueArgs>(args: SelectSubset<T, OrganizationProfileFindUniqueArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationProfileFindUniqueOrThrowArgs} args - Arguments to find a OrganizationProfile
     * @example
     * // Get one OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileFindFirstArgs} args - Arguments to find a OrganizationProfile
     * @example
     * // Get one OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationProfileFindFirstArgs>(args?: SelectSubset<T, OrganizationProfileFindFirstArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileFindFirstOrThrowArgs} args - Arguments to find a OrganizationProfile
     * @example
     * // Get one OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationProfiles
     * const organizationProfiles = await prisma.organizationProfile.findMany()
     * 
     * // Get first 10 OrganizationProfiles
     * const organizationProfiles = await prisma.organizationProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationProfileWithIdOnly = await prisma.organizationProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationProfileFindManyArgs>(args?: SelectSubset<T, OrganizationProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationProfile.
     * @param {OrganizationProfileCreateArgs} args - Arguments to create a OrganizationProfile.
     * @example
     * // Create one OrganizationProfile
     * const OrganizationProfile = await prisma.organizationProfile.create({
     *   data: {
     *     // ... data to create a OrganizationProfile
     *   }
     * })
     * 
     */
    create<T extends OrganizationProfileCreateArgs>(args: SelectSubset<T, OrganizationProfileCreateArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationProfiles.
     * @param {OrganizationProfileCreateManyArgs} args - Arguments to create many OrganizationProfiles.
     * @example
     * // Create many OrganizationProfiles
     * const organizationProfile = await prisma.organizationProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationProfileCreateManyArgs>(args?: SelectSubset<T, OrganizationProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationProfiles and returns the data saved in the database.
     * @param {OrganizationProfileCreateManyAndReturnArgs} args - Arguments to create many OrganizationProfiles.
     * @example
     * // Create many OrganizationProfiles
     * const organizationProfile = await prisma.organizationProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationProfiles and only return the `id`
     * const organizationProfileWithIdOnly = await prisma.organizationProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationProfile.
     * @param {OrganizationProfileDeleteArgs} args - Arguments to delete one OrganizationProfile.
     * @example
     * // Delete one OrganizationProfile
     * const OrganizationProfile = await prisma.organizationProfile.delete({
     *   where: {
     *     // ... filter to delete one OrganizationProfile
     *   }
     * })
     * 
     */
    delete<T extends OrganizationProfileDeleteArgs>(args: SelectSubset<T, OrganizationProfileDeleteArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationProfile.
     * @param {OrganizationProfileUpdateArgs} args - Arguments to update one OrganizationProfile.
     * @example
     * // Update one OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationProfileUpdateArgs>(args: SelectSubset<T, OrganizationProfileUpdateArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationProfiles.
     * @param {OrganizationProfileDeleteManyArgs} args - Arguments to filter OrganizationProfiles to delete.
     * @example
     * // Delete a few OrganizationProfiles
     * const { count } = await prisma.organizationProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationProfileDeleteManyArgs>(args?: SelectSubset<T, OrganizationProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationProfiles
     * const organizationProfile = await prisma.organizationProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationProfileUpdateManyArgs>(args: SelectSubset<T, OrganizationProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationProfiles and returns the data updated in the database.
     * @param {OrganizationProfileUpdateManyAndReturnArgs} args - Arguments to update many OrganizationProfiles.
     * @example
     * // Update many OrganizationProfiles
     * const organizationProfile = await prisma.organizationProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationProfiles and only return the `id`
     * const organizationProfileWithIdOnly = await prisma.organizationProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationProfile.
     * @param {OrganizationProfileUpsertArgs} args - Arguments to update or create a OrganizationProfile.
     * @example
     * // Update or create a OrganizationProfile
     * const organizationProfile = await prisma.organizationProfile.upsert({
     *   create: {
     *     // ... data to create a OrganizationProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationProfile we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationProfileUpsertArgs>(args: SelectSubset<T, OrganizationProfileUpsertArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileCountArgs} args - Arguments to filter OrganizationProfiles to count.
     * @example
     * // Count the number of OrganizationProfiles
     * const count = await prisma.organizationProfile.count({
     *   where: {
     *     // ... the filter for the OrganizationProfiles we want to count
     *   }
     * })
    **/
    count<T extends OrganizationProfileCountArgs>(
      args?: Subset<T, OrganizationProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationProfileAggregateArgs>(args: Subset<T, OrganizationProfileAggregateArgs>): Prisma.PrismaPromise<GetOrganizationProfileAggregateType<T>>

    /**
     * Group by OrganizationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationProfileGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationProfile model
   */
  readonly fields: OrganizationProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teamMembers<T extends OrganizationProfile$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationProfile$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationProfile model
   */
  interface OrganizationProfileFieldRefs {
    readonly id: FieldRef<"OrganizationProfile", 'String'>
    readonly userId: FieldRef<"OrganizationProfile", 'String'>
    readonly slug: FieldRef<"OrganizationProfile", 'String'>
    readonly organizationName: FieldRef<"OrganizationProfile", 'String'>
    readonly bio: FieldRef<"OrganizationProfile", 'String'>
    readonly website: FieldRef<"OrganizationProfile", 'String'>
    readonly instagram: FieldRef<"OrganizationProfile", 'String'>
    readonly facebook: FieldRef<"OrganizationProfile", 'String'>
    readonly twitter: FieldRef<"OrganizationProfile", 'String'>
    readonly whatsappNumber: FieldRef<"OrganizationProfile", 'String'>
    readonly telegramHandle: FieldRef<"OrganizationProfile", 'String'>
    readonly logo: FieldRef<"OrganizationProfile", 'String'>
    readonly coverImage: FieldRef<"OrganizationProfile", 'String'>
    readonly verified: FieldRef<"OrganizationProfile", 'Boolean'>
    readonly totalEvents: FieldRef<"OrganizationProfile", 'Int'>
    readonly totalAttendees: FieldRef<"OrganizationProfile", 'Int'>
    readonly createdAt: FieldRef<"OrganizationProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationProfile findUnique
   */
  export type OrganizationProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationProfile to fetch.
     */
    where: OrganizationProfileWhereUniqueInput
  }

  /**
   * OrganizationProfile findUniqueOrThrow
   */
  export type OrganizationProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationProfile to fetch.
     */
    where: OrganizationProfileWhereUniqueInput
  }

  /**
   * OrganizationProfile findFirst
   */
  export type OrganizationProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationProfile to fetch.
     */
    where?: OrganizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationProfiles to fetch.
     */
    orderBy?: OrganizationProfileOrderByWithRelationInput | OrganizationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationProfiles.
     */
    cursor?: OrganizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationProfiles.
     */
    distinct?: OrganizationProfileScalarFieldEnum | OrganizationProfileScalarFieldEnum[]
  }

  /**
   * OrganizationProfile findFirstOrThrow
   */
  export type OrganizationProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationProfile to fetch.
     */
    where?: OrganizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationProfiles to fetch.
     */
    orderBy?: OrganizationProfileOrderByWithRelationInput | OrganizationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationProfiles.
     */
    cursor?: OrganizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationProfiles.
     */
    distinct?: OrganizationProfileScalarFieldEnum | OrganizationProfileScalarFieldEnum[]
  }

  /**
   * OrganizationProfile findMany
   */
  export type OrganizationProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationProfiles to fetch.
     */
    where?: OrganizationProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationProfiles to fetch.
     */
    orderBy?: OrganizationProfileOrderByWithRelationInput | OrganizationProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationProfiles.
     */
    cursor?: OrganizationProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationProfiles.
     */
    skip?: number
    distinct?: OrganizationProfileScalarFieldEnum | OrganizationProfileScalarFieldEnum[]
  }

  /**
   * OrganizationProfile create
   */
  export type OrganizationProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationProfile.
     */
    data: XOR<OrganizationProfileCreateInput, OrganizationProfileUncheckedCreateInput>
  }

  /**
   * OrganizationProfile createMany
   */
  export type OrganizationProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationProfiles.
     */
    data: OrganizationProfileCreateManyInput | OrganizationProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationProfile createManyAndReturn
   */
  export type OrganizationProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationProfiles.
     */
    data: OrganizationProfileCreateManyInput | OrganizationProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationProfile update
   */
  export type OrganizationProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationProfile.
     */
    data: XOR<OrganizationProfileUpdateInput, OrganizationProfileUncheckedUpdateInput>
    /**
     * Choose, which OrganizationProfile to update.
     */
    where: OrganizationProfileWhereUniqueInput
  }

  /**
   * OrganizationProfile updateMany
   */
  export type OrganizationProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationProfiles.
     */
    data: XOR<OrganizationProfileUpdateManyMutationInput, OrganizationProfileUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationProfiles to update
     */
    where?: OrganizationProfileWhereInput
    /**
     * Limit how many OrganizationProfiles to update.
     */
    limit?: number
  }

  /**
   * OrganizationProfile updateManyAndReturn
   */
  export type OrganizationProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationProfiles.
     */
    data: XOR<OrganizationProfileUpdateManyMutationInput, OrganizationProfileUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationProfiles to update
     */
    where?: OrganizationProfileWhereInput
    /**
     * Limit how many OrganizationProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationProfile upsert
   */
  export type OrganizationProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationProfile to update in case it exists.
     */
    where: OrganizationProfileWhereUniqueInput
    /**
     * In case the OrganizationProfile found by the `where` argument doesn't exist, create a new OrganizationProfile with this data.
     */
    create: XOR<OrganizationProfileCreateInput, OrganizationProfileUncheckedCreateInput>
    /**
     * In case the OrganizationProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationProfileUpdateInput, OrganizationProfileUncheckedUpdateInput>
  }

  /**
   * OrganizationProfile delete
   */
  export type OrganizationProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
    /**
     * Filter which OrganizationProfile to delete.
     */
    where: OrganizationProfileWhereUniqueInput
  }

  /**
   * OrganizationProfile deleteMany
   */
  export type OrganizationProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationProfiles to delete
     */
    where?: OrganizationProfileWhereInput
    /**
     * Limit how many OrganizationProfiles to delete.
     */
    limit?: number
  }

  /**
   * OrganizationProfile.teamMembers
   */
  export type OrganizationProfile$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationProfile without action
   */
  export type OrganizationProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationProfile
     */
    select?: OrganizationProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationProfile
     */
    omit?: OrganizationProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationProfileInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    role: number
    email: number
    phone: number
    avatar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    role: string
    email: string | null
    phone: string | null
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "role" | "email" | "phone" | "avatar" | "createdAt" | "updatedAt", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationProfileDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      organization: Prisma.$OrganizationProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      role: string
      email: string | null
      phone: string | null
      avatar: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationProfileDefaultArgs<ExtArgs>>): Prisma__OrganizationProfileClient<$Result.GetResult<Prisma.$OrganizationProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly organizationId: FieldRef<"OrganizationMember", 'String'>
    readonly name: FieldRef<"OrganizationMember", 'String'>
    readonly role: FieldRef<"OrganizationMember", 'String'>
    readonly email: FieldRef<"OrganizationMember", 'String'>
    readonly phone: FieldRef<"OrganizationMember", 'String'>
    readonly avatar: FieldRef<"OrganizationMember", 'String'>
    readonly createdAt: FieldRef<"OrganizationMember", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model ArtistProfile
   */

  export type AggregateArtistProfile = {
    _count: ArtistProfileCountAggregateOutputType | null
    _avg: ArtistProfileAvgAggregateOutputType | null
    _sum: ArtistProfileSumAggregateOutputType | null
    _min: ArtistProfileMinAggregateOutputType | null
    _max: ArtistProfileMaxAggregateOutputType | null
  }

  export type ArtistProfileAvgAggregateOutputType = {
    totalGigs: number | null
    rating: number | null
  }

  export type ArtistProfileSumAggregateOutputType = {
    totalGigs: number | null
    rating: number | null
  }

  export type ArtistProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    artistName: string | null
    artistType: $Enums.ArtistType | null
    bio: string | null
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    soundcloud: string | null
    spotify: string | null
    youtube: string | null
    avatar: string | null
    coverImage: string | null
    verified: boolean | null
    totalGigs: number | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    artistName: string | null
    artistType: $Enums.ArtistType | null
    bio: string | null
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    soundcloud: string | null
    spotify: string | null
    youtube: string | null
    avatar: string | null
    coverImage: string | null
    verified: boolean | null
    totalGigs: number | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistProfileCountAggregateOutputType = {
    id: number
    userId: number
    artistName: number
    artistType: number
    bio: number
    genres: number
    website: number
    instagram: number
    facebook: number
    twitter: number
    soundcloud: number
    spotify: number
    youtube: number
    avatar: number
    coverImage: number
    verified: number
    totalGigs: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArtistProfileAvgAggregateInputType = {
    totalGigs?: true
    rating?: true
  }

  export type ArtistProfileSumAggregateInputType = {
    totalGigs?: true
    rating?: true
  }

  export type ArtistProfileMinAggregateInputType = {
    id?: true
    userId?: true
    artistName?: true
    artistType?: true
    bio?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    soundcloud?: true
    spotify?: true
    youtube?: true
    avatar?: true
    coverImage?: true
    verified?: true
    totalGigs?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    artistName?: true
    artistType?: true
    bio?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    soundcloud?: true
    spotify?: true
    youtube?: true
    avatar?: true
    coverImage?: true
    verified?: true
    totalGigs?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistProfileCountAggregateInputType = {
    id?: true
    userId?: true
    artistName?: true
    artistType?: true
    bio?: true
    genres?: true
    website?: true
    instagram?: true
    facebook?: true
    twitter?: true
    soundcloud?: true
    spotify?: true
    youtube?: true
    avatar?: true
    coverImage?: true
    verified?: true
    totalGigs?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArtistProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistProfile to aggregate.
     */
    where?: ArtistProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistProfiles to fetch.
     */
    orderBy?: ArtistProfileOrderByWithRelationInput | ArtistProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtistProfiles
    **/
    _count?: true | ArtistProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtistProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtistProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistProfileMaxAggregateInputType
  }

  export type GetArtistProfileAggregateType<T extends ArtistProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateArtistProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtistProfile[P]>
      : GetScalarType<T[P], AggregateArtistProfile[P]>
  }




  export type ArtistProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistProfileWhereInput
    orderBy?: ArtistProfileOrderByWithAggregationInput | ArtistProfileOrderByWithAggregationInput[]
    by: ArtistProfileScalarFieldEnum[] | ArtistProfileScalarFieldEnum
    having?: ArtistProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistProfileCountAggregateInputType | true
    _avg?: ArtistProfileAvgAggregateInputType
    _sum?: ArtistProfileSumAggregateInputType
    _min?: ArtistProfileMinAggregateInputType
    _max?: ArtistProfileMaxAggregateInputType
  }

  export type ArtistProfileGroupByOutputType = {
    id: string
    userId: string
    artistName: string
    artistType: $Enums.ArtistType
    bio: string | null
    genres: string[]
    website: string | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    soundcloud: string | null
    spotify: string | null
    youtube: string | null
    avatar: string | null
    coverImage: string | null
    verified: boolean
    totalGigs: number
    rating: number | null
    createdAt: Date
    updatedAt: Date
    _count: ArtistProfileCountAggregateOutputType | null
    _avg: ArtistProfileAvgAggregateOutputType | null
    _sum: ArtistProfileSumAggregateOutputType | null
    _min: ArtistProfileMinAggregateOutputType | null
    _max: ArtistProfileMaxAggregateOutputType | null
  }

  type GetArtistProfileGroupByPayload<T extends ArtistProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistProfileGroupByOutputType[P]>
        }
      >
    >


  export type ArtistProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    artistName?: boolean
    artistType?: boolean
    bio?: boolean
    genres?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    soundcloud?: boolean
    spotify?: boolean
    youtube?: boolean
    avatar?: boolean
    coverImage?: boolean
    verified?: boolean
    totalGigs?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    performances?: boolean | ArtistProfile$performancesArgs<ExtArgs>
    mediaGallery?: boolean | ArtistProfile$mediaGalleryArgs<ExtArgs>
    _count?: boolean | ArtistProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistProfile"]>

  export type ArtistProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    artistName?: boolean
    artistType?: boolean
    bio?: boolean
    genres?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    soundcloud?: boolean
    spotify?: boolean
    youtube?: boolean
    avatar?: boolean
    coverImage?: boolean
    verified?: boolean
    totalGigs?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistProfile"]>

  export type ArtistProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    artistName?: boolean
    artistType?: boolean
    bio?: boolean
    genres?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    soundcloud?: boolean
    spotify?: boolean
    youtube?: boolean
    avatar?: boolean
    coverImage?: boolean
    verified?: boolean
    totalGigs?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistProfile"]>

  export type ArtistProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    artistName?: boolean
    artistType?: boolean
    bio?: boolean
    genres?: boolean
    website?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    soundcloud?: boolean
    spotify?: boolean
    youtube?: boolean
    avatar?: boolean
    coverImage?: boolean
    verified?: boolean
    totalGigs?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArtistProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "artistName" | "artistType" | "bio" | "genres" | "website" | "instagram" | "facebook" | "twitter" | "soundcloud" | "spotify" | "youtube" | "avatar" | "coverImage" | "verified" | "totalGigs" | "rating" | "createdAt" | "updatedAt", ExtArgs["result"]["artistProfile"]>
  export type ArtistProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    performances?: boolean | ArtistProfile$performancesArgs<ExtArgs>
    mediaGallery?: boolean | ArtistProfile$mediaGalleryArgs<ExtArgs>
    _count?: boolean | ArtistProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtistProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ArtistProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ArtistProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtistProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      performances: Prisma.$PerformancePayload<ExtArgs>[]
      mediaGallery: Prisma.$ArtistMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      artistName: string
      artistType: $Enums.ArtistType
      bio: string | null
      genres: string[]
      website: string | null
      instagram: string | null
      facebook: string | null
      twitter: string | null
      soundcloud: string | null
      spotify: string | null
      youtube: string | null
      avatar: string | null
      coverImage: string | null
      verified: boolean
      totalGigs: number
      rating: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["artistProfile"]>
    composites: {}
  }

  type ArtistProfileGetPayload<S extends boolean | null | undefined | ArtistProfileDefaultArgs> = $Result.GetResult<Prisma.$ArtistProfilePayload, S>

  type ArtistProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistProfileCountAggregateInputType | true
    }

  export interface ArtistProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtistProfile'], meta: { name: 'ArtistProfile' } }
    /**
     * Find zero or one ArtistProfile that matches the filter.
     * @param {ArtistProfileFindUniqueArgs} args - Arguments to find a ArtistProfile
     * @example
     * // Get one ArtistProfile
     * const artistProfile = await prisma.artistProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistProfileFindUniqueArgs>(args: SelectSubset<T, ArtistProfileFindUniqueArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtistProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistProfileFindUniqueOrThrowArgs} args - Arguments to find a ArtistProfile
     * @example
     * // Get one ArtistProfile
     * const artistProfile = await prisma.artistProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileFindFirstArgs} args - Arguments to find a ArtistProfile
     * @example
     * // Get one ArtistProfile
     * const artistProfile = await prisma.artistProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistProfileFindFirstArgs>(args?: SelectSubset<T, ArtistProfileFindFirstArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileFindFirstOrThrowArgs} args - Arguments to find a ArtistProfile
     * @example
     * // Get one ArtistProfile
     * const artistProfile = await prisma.artistProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtistProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtistProfiles
     * const artistProfiles = await prisma.artistProfile.findMany()
     * 
     * // Get first 10 ArtistProfiles
     * const artistProfiles = await prisma.artistProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artistProfileWithIdOnly = await prisma.artistProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtistProfileFindManyArgs>(args?: SelectSubset<T, ArtistProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtistProfile.
     * @param {ArtistProfileCreateArgs} args - Arguments to create a ArtistProfile.
     * @example
     * // Create one ArtistProfile
     * const ArtistProfile = await prisma.artistProfile.create({
     *   data: {
     *     // ... data to create a ArtistProfile
     *   }
     * })
     * 
     */
    create<T extends ArtistProfileCreateArgs>(args: SelectSubset<T, ArtistProfileCreateArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtistProfiles.
     * @param {ArtistProfileCreateManyArgs} args - Arguments to create many ArtistProfiles.
     * @example
     * // Create many ArtistProfiles
     * const artistProfile = await prisma.artistProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistProfileCreateManyArgs>(args?: SelectSubset<T, ArtistProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtistProfiles and returns the data saved in the database.
     * @param {ArtistProfileCreateManyAndReturnArgs} args - Arguments to create many ArtistProfiles.
     * @example
     * // Create many ArtistProfiles
     * const artistProfile = await prisma.artistProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtistProfiles and only return the `id`
     * const artistProfileWithIdOnly = await prisma.artistProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtistProfile.
     * @param {ArtistProfileDeleteArgs} args - Arguments to delete one ArtistProfile.
     * @example
     * // Delete one ArtistProfile
     * const ArtistProfile = await prisma.artistProfile.delete({
     *   where: {
     *     // ... filter to delete one ArtistProfile
     *   }
     * })
     * 
     */
    delete<T extends ArtistProfileDeleteArgs>(args: SelectSubset<T, ArtistProfileDeleteArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtistProfile.
     * @param {ArtistProfileUpdateArgs} args - Arguments to update one ArtistProfile.
     * @example
     * // Update one ArtistProfile
     * const artistProfile = await prisma.artistProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistProfileUpdateArgs>(args: SelectSubset<T, ArtistProfileUpdateArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtistProfiles.
     * @param {ArtistProfileDeleteManyArgs} args - Arguments to filter ArtistProfiles to delete.
     * @example
     * // Delete a few ArtistProfiles
     * const { count } = await prisma.artistProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistProfileDeleteManyArgs>(args?: SelectSubset<T, ArtistProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtistProfiles
     * const artistProfile = await prisma.artistProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistProfileUpdateManyArgs>(args: SelectSubset<T, ArtistProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistProfiles and returns the data updated in the database.
     * @param {ArtistProfileUpdateManyAndReturnArgs} args - Arguments to update many ArtistProfiles.
     * @example
     * // Update many ArtistProfiles
     * const artistProfile = await prisma.artistProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtistProfiles and only return the `id`
     * const artistProfileWithIdOnly = await prisma.artistProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtistProfile.
     * @param {ArtistProfileUpsertArgs} args - Arguments to update or create a ArtistProfile.
     * @example
     * // Update or create a ArtistProfile
     * const artistProfile = await prisma.artistProfile.upsert({
     *   create: {
     *     // ... data to create a ArtistProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtistProfile we want to update
     *   }
     * })
     */
    upsert<T extends ArtistProfileUpsertArgs>(args: SelectSubset<T, ArtistProfileUpsertArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtistProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileCountArgs} args - Arguments to filter ArtistProfiles to count.
     * @example
     * // Count the number of ArtistProfiles
     * const count = await prisma.artistProfile.count({
     *   where: {
     *     // ... the filter for the ArtistProfiles we want to count
     *   }
     * })
    **/
    count<T extends ArtistProfileCountArgs>(
      args?: Subset<T, ArtistProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtistProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistProfileAggregateArgs>(args: Subset<T, ArtistProfileAggregateArgs>): Prisma.PrismaPromise<GetArtistProfileAggregateType<T>>

    /**
     * Group by ArtistProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistProfileGroupByArgs['orderBy'] }
        : { orderBy?: ArtistProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtistProfile model
   */
  readonly fields: ArtistProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtistProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    performances<T extends ArtistProfile$performancesArgs<ExtArgs> = {}>(args?: Subset<T, ArtistProfile$performancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaGallery<T extends ArtistProfile$mediaGalleryArgs<ExtArgs> = {}>(args?: Subset<T, ArtistProfile$mediaGalleryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtistProfile model
   */
  interface ArtistProfileFieldRefs {
    readonly id: FieldRef<"ArtistProfile", 'String'>
    readonly userId: FieldRef<"ArtistProfile", 'String'>
    readonly artistName: FieldRef<"ArtistProfile", 'String'>
    readonly artistType: FieldRef<"ArtistProfile", 'ArtistType'>
    readonly bio: FieldRef<"ArtistProfile", 'String'>
    readonly genres: FieldRef<"ArtistProfile", 'String[]'>
    readonly website: FieldRef<"ArtistProfile", 'String'>
    readonly instagram: FieldRef<"ArtistProfile", 'String'>
    readonly facebook: FieldRef<"ArtistProfile", 'String'>
    readonly twitter: FieldRef<"ArtistProfile", 'String'>
    readonly soundcloud: FieldRef<"ArtistProfile", 'String'>
    readonly spotify: FieldRef<"ArtistProfile", 'String'>
    readonly youtube: FieldRef<"ArtistProfile", 'String'>
    readonly avatar: FieldRef<"ArtistProfile", 'String'>
    readonly coverImage: FieldRef<"ArtistProfile", 'String'>
    readonly verified: FieldRef<"ArtistProfile", 'Boolean'>
    readonly totalGigs: FieldRef<"ArtistProfile", 'Int'>
    readonly rating: FieldRef<"ArtistProfile", 'Float'>
    readonly createdAt: FieldRef<"ArtistProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"ArtistProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArtistProfile findUnique
   */
  export type ArtistProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter, which ArtistProfile to fetch.
     */
    where: ArtistProfileWhereUniqueInput
  }

  /**
   * ArtistProfile findUniqueOrThrow
   */
  export type ArtistProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter, which ArtistProfile to fetch.
     */
    where: ArtistProfileWhereUniqueInput
  }

  /**
   * ArtistProfile findFirst
   */
  export type ArtistProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter, which ArtistProfile to fetch.
     */
    where?: ArtistProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistProfiles to fetch.
     */
    orderBy?: ArtistProfileOrderByWithRelationInput | ArtistProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistProfiles.
     */
    cursor?: ArtistProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistProfiles.
     */
    distinct?: ArtistProfileScalarFieldEnum | ArtistProfileScalarFieldEnum[]
  }

  /**
   * ArtistProfile findFirstOrThrow
   */
  export type ArtistProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter, which ArtistProfile to fetch.
     */
    where?: ArtistProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistProfiles to fetch.
     */
    orderBy?: ArtistProfileOrderByWithRelationInput | ArtistProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistProfiles.
     */
    cursor?: ArtistProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistProfiles.
     */
    distinct?: ArtistProfileScalarFieldEnum | ArtistProfileScalarFieldEnum[]
  }

  /**
   * ArtistProfile findMany
   */
  export type ArtistProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter, which ArtistProfiles to fetch.
     */
    where?: ArtistProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistProfiles to fetch.
     */
    orderBy?: ArtistProfileOrderByWithRelationInput | ArtistProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtistProfiles.
     */
    cursor?: ArtistProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistProfiles.
     */
    skip?: number
    distinct?: ArtistProfileScalarFieldEnum | ArtistProfileScalarFieldEnum[]
  }

  /**
   * ArtistProfile create
   */
  export type ArtistProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtistProfile.
     */
    data: XOR<ArtistProfileCreateInput, ArtistProfileUncheckedCreateInput>
  }

  /**
   * ArtistProfile createMany
   */
  export type ArtistProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtistProfiles.
     */
    data: ArtistProfileCreateManyInput | ArtistProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtistProfile createManyAndReturn
   */
  export type ArtistProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * The data used to create many ArtistProfiles.
     */
    data: ArtistProfileCreateManyInput | ArtistProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistProfile update
   */
  export type ArtistProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtistProfile.
     */
    data: XOR<ArtistProfileUpdateInput, ArtistProfileUncheckedUpdateInput>
    /**
     * Choose, which ArtistProfile to update.
     */
    where: ArtistProfileWhereUniqueInput
  }

  /**
   * ArtistProfile updateMany
   */
  export type ArtistProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtistProfiles.
     */
    data: XOR<ArtistProfileUpdateManyMutationInput, ArtistProfileUncheckedUpdateManyInput>
    /**
     * Filter which ArtistProfiles to update
     */
    where?: ArtistProfileWhereInput
    /**
     * Limit how many ArtistProfiles to update.
     */
    limit?: number
  }

  /**
   * ArtistProfile updateManyAndReturn
   */
  export type ArtistProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * The data used to update ArtistProfiles.
     */
    data: XOR<ArtistProfileUpdateManyMutationInput, ArtistProfileUncheckedUpdateManyInput>
    /**
     * Filter which ArtistProfiles to update
     */
    where?: ArtistProfileWhereInput
    /**
     * Limit how many ArtistProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistProfile upsert
   */
  export type ArtistProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtistProfile to update in case it exists.
     */
    where: ArtistProfileWhereUniqueInput
    /**
     * In case the ArtistProfile found by the `where` argument doesn't exist, create a new ArtistProfile with this data.
     */
    create: XOR<ArtistProfileCreateInput, ArtistProfileUncheckedCreateInput>
    /**
     * In case the ArtistProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistProfileUpdateInput, ArtistProfileUncheckedUpdateInput>
  }

  /**
   * ArtistProfile delete
   */
  export type ArtistProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
    /**
     * Filter which ArtistProfile to delete.
     */
    where: ArtistProfileWhereUniqueInput
  }

  /**
   * ArtistProfile deleteMany
   */
  export type ArtistProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistProfiles to delete
     */
    where?: ArtistProfileWhereInput
    /**
     * Limit how many ArtistProfiles to delete.
     */
    limit?: number
  }

  /**
   * ArtistProfile.performances
   */
  export type ArtistProfile$performancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    where?: PerformanceWhereInput
    orderBy?: PerformanceOrderByWithRelationInput | PerformanceOrderByWithRelationInput[]
    cursor?: PerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * ArtistProfile.mediaGallery
   */
  export type ArtistProfile$mediaGalleryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    where?: ArtistMediaWhereInput
    orderBy?: ArtistMediaOrderByWithRelationInput | ArtistMediaOrderByWithRelationInput[]
    cursor?: ArtistMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtistMediaScalarFieldEnum | ArtistMediaScalarFieldEnum[]
  }

  /**
   * ArtistProfile without action
   */
  export type ArtistProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistProfile
     */
    select?: ArtistProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistProfile
     */
    omit?: ArtistProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistProfileInclude<ExtArgs> | null
  }


  /**
   * Model Performance
   */

  export type AggregatePerformance = {
    _count: PerformanceCountAggregateOutputType | null
    _avg: PerformanceAvgAggregateOutputType | null
    _sum: PerformanceSumAggregateOutputType | null
    _min: PerformanceMinAggregateOutputType | null
    _max: PerformanceMaxAggregateOutputType | null
  }

  export type PerformanceAvgAggregateOutputType = {
    fee: number | null
  }

  export type PerformanceSumAggregateOutputType = {
    fee: number | null
  }

  export type PerformanceMinAggregateOutputType = {
    id: string | null
    artistId: string | null
    eventId: string | null
    eventName: string | null
    eventDate: Date | null
    venueName: string | null
    city: string | null
    description: string | null
    fee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceMaxAggregateOutputType = {
    id: string | null
    artistId: string | null
    eventId: string | null
    eventName: string | null
    eventDate: Date | null
    venueName: string | null
    city: string | null
    description: string | null
    fee: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceCountAggregateOutputType = {
    id: number
    artistId: number
    eventId: number
    eventName: number
    eventDate: number
    venueName: number
    city: number
    description: number
    fee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceAvgAggregateInputType = {
    fee?: true
  }

  export type PerformanceSumAggregateInputType = {
    fee?: true
  }

  export type PerformanceMinAggregateInputType = {
    id?: true
    artistId?: true
    eventId?: true
    eventName?: true
    eventDate?: true
    venueName?: true
    city?: true
    description?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceMaxAggregateInputType = {
    id?: true
    artistId?: true
    eventId?: true
    eventName?: true
    eventDate?: true
    venueName?: true
    city?: true
    description?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceCountAggregateInputType = {
    id?: true
    artistId?: true
    eventId?: true
    eventName?: true
    eventDate?: true
    venueName?: true
    city?: true
    description?: true
    fee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Performance to aggregate.
     */
    where?: PerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Performances to fetch.
     */
    orderBy?: PerformanceOrderByWithRelationInput | PerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Performances
    **/
    _count?: true | PerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMaxAggregateInputType
  }

  export type GetPerformanceAggregateType<T extends PerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformance[P]>
      : GetScalarType<T[P], AggregatePerformance[P]>
  }




  export type PerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceWhereInput
    orderBy?: PerformanceOrderByWithAggregationInput | PerformanceOrderByWithAggregationInput[]
    by: PerformanceScalarFieldEnum[] | PerformanceScalarFieldEnum
    having?: PerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceCountAggregateInputType | true
    _avg?: PerformanceAvgAggregateInputType
    _sum?: PerformanceSumAggregateInputType
    _min?: PerformanceMinAggregateInputType
    _max?: PerformanceMaxAggregateInputType
  }

  export type PerformanceGroupByOutputType = {
    id: string
    artistId: string
    eventId: string | null
    eventName: string
    eventDate: Date
    venueName: string
    city: string | null
    description: string | null
    fee: number | null
    createdAt: Date
    updatedAt: Date
    _count: PerformanceCountAggregateOutputType | null
    _avg: PerformanceAvgAggregateOutputType | null
    _sum: PerformanceSumAggregateOutputType | null
    _min: PerformanceMinAggregateOutputType | null
    _max: PerformanceMaxAggregateOutputType | null
  }

  type GetPerformanceGroupByPayload<T extends PerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    eventId?: boolean
    eventName?: boolean
    eventDate?: boolean
    venueName?: boolean
    city?: boolean
    description?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type PerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    eventId?: boolean
    eventName?: boolean
    eventDate?: boolean
    venueName?: boolean
    city?: boolean
    description?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type PerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    eventId?: boolean
    eventName?: boolean
    eventDate?: boolean
    venueName?: boolean
    city?: boolean
    description?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type PerformanceSelectScalar = {
    id?: boolean
    artistId?: boolean
    eventId?: boolean
    eventName?: boolean
    eventDate?: boolean
    venueName?: boolean
    city?: boolean
    description?: boolean
    fee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artistId" | "eventId" | "eventName" | "eventDate" | "venueName" | "city" | "description" | "fee" | "createdAt" | "updatedAt", ExtArgs["result"]["performance"]>
  export type PerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }
  export type PerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }
  export type PerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }

  export type $PerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Performance"
    objects: {
      artist: Prisma.$ArtistProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artistId: string
      eventId: string | null
      eventName: string
      eventDate: Date
      venueName: string
      city: string | null
      description: string | null
      fee: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performance"]>
    composites: {}
  }

  type PerformanceGetPayload<S extends boolean | null | undefined | PerformanceDefaultArgs> = $Result.GetResult<Prisma.$PerformancePayload, S>

  type PerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceCountAggregateInputType | true
    }

  export interface PerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Performance'], meta: { name: 'Performance' } }
    /**
     * Find zero or one Performance that matches the filter.
     * @param {PerformanceFindUniqueArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceFindUniqueArgs>(args: SelectSubset<T, PerformanceFindUniqueArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Performance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceFindUniqueOrThrowArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceFindFirstArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceFindFirstArgs>(args?: SelectSubset<T, PerformanceFindFirstArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceFindFirstOrThrowArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Performances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Performances
     * const performances = await prisma.performance.findMany()
     * 
     * // Get first 10 Performances
     * const performances = await prisma.performance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceWithIdOnly = await prisma.performance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceFindManyArgs>(args?: SelectSubset<T, PerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Performance.
     * @param {PerformanceCreateArgs} args - Arguments to create a Performance.
     * @example
     * // Create one Performance
     * const Performance = await prisma.performance.create({
     *   data: {
     *     // ... data to create a Performance
     *   }
     * })
     * 
     */
    create<T extends PerformanceCreateArgs>(args: SelectSubset<T, PerformanceCreateArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Performances.
     * @param {PerformanceCreateManyArgs} args - Arguments to create many Performances.
     * @example
     * // Create many Performances
     * const performance = await prisma.performance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceCreateManyArgs>(args?: SelectSubset<T, PerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Performances and returns the data saved in the database.
     * @param {PerformanceCreateManyAndReturnArgs} args - Arguments to create many Performances.
     * @example
     * // Create many Performances
     * const performance = await prisma.performance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Performances and only return the `id`
     * const performanceWithIdOnly = await prisma.performance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Performance.
     * @param {PerformanceDeleteArgs} args - Arguments to delete one Performance.
     * @example
     * // Delete one Performance
     * const Performance = await prisma.performance.delete({
     *   where: {
     *     // ... filter to delete one Performance
     *   }
     * })
     * 
     */
    delete<T extends PerformanceDeleteArgs>(args: SelectSubset<T, PerformanceDeleteArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Performance.
     * @param {PerformanceUpdateArgs} args - Arguments to update one Performance.
     * @example
     * // Update one Performance
     * const performance = await prisma.performance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceUpdateArgs>(args: SelectSubset<T, PerformanceUpdateArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Performances.
     * @param {PerformanceDeleteManyArgs} args - Arguments to filter Performances to delete.
     * @example
     * // Delete a few Performances
     * const { count } = await prisma.performance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceDeleteManyArgs>(args?: SelectSubset<T, PerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Performances
     * const performance = await prisma.performance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceUpdateManyArgs>(args: SelectSubset<T, PerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Performances and returns the data updated in the database.
     * @param {PerformanceUpdateManyAndReturnArgs} args - Arguments to update many Performances.
     * @example
     * // Update many Performances
     * const performance = await prisma.performance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Performances and only return the `id`
     * const performanceWithIdOnly = await prisma.performance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Performance.
     * @param {PerformanceUpsertArgs} args - Arguments to update or create a Performance.
     * @example
     * // Update or create a Performance
     * const performance = await prisma.performance.upsert({
     *   create: {
     *     // ... data to create a Performance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Performance we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceUpsertArgs>(args: SelectSubset<T, PerformanceUpsertArgs<ExtArgs>>): Prisma__PerformanceClient<$Result.GetResult<Prisma.$PerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCountArgs} args - Arguments to filter Performances to count.
     * @example
     * // Count the number of Performances
     * const count = await prisma.performance.count({
     *   where: {
     *     // ... the filter for the Performances we want to count
     *   }
     * })
    **/
    count<T extends PerformanceCountArgs>(
      args?: Subset<T, PerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceAggregateArgs>(args: Subset<T, PerformanceAggregateArgs>): Prisma.PrismaPromise<GetPerformanceAggregateType<T>>

    /**
     * Group by Performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Performance model
   */
  readonly fields: PerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Performance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistProfileDefaultArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Performance model
   */
  interface PerformanceFieldRefs {
    readonly id: FieldRef<"Performance", 'String'>
    readonly artistId: FieldRef<"Performance", 'String'>
    readonly eventId: FieldRef<"Performance", 'String'>
    readonly eventName: FieldRef<"Performance", 'String'>
    readonly eventDate: FieldRef<"Performance", 'DateTime'>
    readonly venueName: FieldRef<"Performance", 'String'>
    readonly city: FieldRef<"Performance", 'String'>
    readonly description: FieldRef<"Performance", 'String'>
    readonly fee: FieldRef<"Performance", 'Float'>
    readonly createdAt: FieldRef<"Performance", 'DateTime'>
    readonly updatedAt: FieldRef<"Performance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Performance findUnique
   */
  export type PerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter, which Performance to fetch.
     */
    where: PerformanceWhereUniqueInput
  }

  /**
   * Performance findUniqueOrThrow
   */
  export type PerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter, which Performance to fetch.
     */
    where: PerformanceWhereUniqueInput
  }

  /**
   * Performance findFirst
   */
  export type PerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter, which Performance to fetch.
     */
    where?: PerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Performances to fetch.
     */
    orderBy?: PerformanceOrderByWithRelationInput | PerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Performances.
     */
    cursor?: PerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Performances.
     */
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * Performance findFirstOrThrow
   */
  export type PerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter, which Performance to fetch.
     */
    where?: PerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Performances to fetch.
     */
    orderBy?: PerformanceOrderByWithRelationInput | PerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Performances.
     */
    cursor?: PerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Performances.
     */
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * Performance findMany
   */
  export type PerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter, which Performances to fetch.
     */
    where?: PerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Performances to fetch.
     */
    orderBy?: PerformanceOrderByWithRelationInput | PerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Performances.
     */
    cursor?: PerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Performances.
     */
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * Performance create
   */
  export type PerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Performance.
     */
    data: XOR<PerformanceCreateInput, PerformanceUncheckedCreateInput>
  }

  /**
   * Performance createMany
   */
  export type PerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Performances.
     */
    data: PerformanceCreateManyInput | PerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Performance createManyAndReturn
   */
  export type PerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many Performances.
     */
    data: PerformanceCreateManyInput | PerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Performance update
   */
  export type PerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Performance.
     */
    data: XOR<PerformanceUpdateInput, PerformanceUncheckedUpdateInput>
    /**
     * Choose, which Performance to update.
     */
    where: PerformanceWhereUniqueInput
  }

  /**
   * Performance updateMany
   */
  export type PerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Performances.
     */
    data: XOR<PerformanceUpdateManyMutationInput, PerformanceUncheckedUpdateManyInput>
    /**
     * Filter which Performances to update
     */
    where?: PerformanceWhereInput
    /**
     * Limit how many Performances to update.
     */
    limit?: number
  }

  /**
   * Performance updateManyAndReturn
   */
  export type PerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * The data used to update Performances.
     */
    data: XOR<PerformanceUpdateManyMutationInput, PerformanceUncheckedUpdateManyInput>
    /**
     * Filter which Performances to update
     */
    where?: PerformanceWhereInput
    /**
     * Limit how many Performances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Performance upsert
   */
  export type PerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Performance to update in case it exists.
     */
    where: PerformanceWhereUniqueInput
    /**
     * In case the Performance found by the `where` argument doesn't exist, create a new Performance with this data.
     */
    create: XOR<PerformanceCreateInput, PerformanceUncheckedCreateInput>
    /**
     * In case the Performance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceUpdateInput, PerformanceUncheckedUpdateInput>
  }

  /**
   * Performance delete
   */
  export type PerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
    /**
     * Filter which Performance to delete.
     */
    where: PerformanceWhereUniqueInput
  }

  /**
   * Performance deleteMany
   */
  export type PerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Performances to delete
     */
    where?: PerformanceWhereInput
    /**
     * Limit how many Performances to delete.
     */
    limit?: number
  }

  /**
   * Performance without action
   */
  export type PerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Performance
     */
    select?: PerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Performance
     */
    omit?: PerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceInclude<ExtArgs> | null
  }


  /**
   * Model ArtistMedia
   */

  export type AggregateArtistMedia = {
    _count: ArtistMediaCountAggregateOutputType | null
    _avg: ArtistMediaAvgAggregateOutputType | null
    _sum: ArtistMediaSumAggregateOutputType | null
    _min: ArtistMediaMinAggregateOutputType | null
    _max: ArtistMediaMaxAggregateOutputType | null
  }

  export type ArtistMediaAvgAggregateOutputType = {
    order: number | null
  }

  export type ArtistMediaSumAggregateOutputType = {
    order: number | null
  }

  export type ArtistMediaMinAggregateOutputType = {
    id: string | null
    artistId: string | null
    type: $Enums.MediaType | null
    title: string | null
    description: string | null
    url: string | null
    thumbnailUrl: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistMediaMaxAggregateOutputType = {
    id: string | null
    artistId: string | null
    type: $Enums.MediaType | null
    title: string | null
    description: string | null
    url: string | null
    thumbnailUrl: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistMediaCountAggregateOutputType = {
    id: number
    artistId: number
    type: number
    title: number
    description: number
    url: number
    thumbnailUrl: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArtistMediaAvgAggregateInputType = {
    order?: true
  }

  export type ArtistMediaSumAggregateInputType = {
    order?: true
  }

  export type ArtistMediaMinAggregateInputType = {
    id?: true
    artistId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    thumbnailUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistMediaMaxAggregateInputType = {
    id?: true
    artistId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    thumbnailUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistMediaCountAggregateInputType = {
    id?: true
    artistId?: true
    type?: true
    title?: true
    description?: true
    url?: true
    thumbnailUrl?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArtistMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistMedia to aggregate.
     */
    where?: ArtistMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistMedias to fetch.
     */
    orderBy?: ArtistMediaOrderByWithRelationInput | ArtistMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtistMedias
    **/
    _count?: true | ArtistMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtistMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtistMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistMediaMaxAggregateInputType
  }

  export type GetArtistMediaAggregateType<T extends ArtistMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateArtistMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtistMedia[P]>
      : GetScalarType<T[P], AggregateArtistMedia[P]>
  }




  export type ArtistMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistMediaWhereInput
    orderBy?: ArtistMediaOrderByWithAggregationInput | ArtistMediaOrderByWithAggregationInput[]
    by: ArtistMediaScalarFieldEnum[] | ArtistMediaScalarFieldEnum
    having?: ArtistMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistMediaCountAggregateInputType | true
    _avg?: ArtistMediaAvgAggregateInputType
    _sum?: ArtistMediaSumAggregateInputType
    _min?: ArtistMediaMinAggregateInputType
    _max?: ArtistMediaMaxAggregateInputType
  }

  export type ArtistMediaGroupByOutputType = {
    id: string
    artistId: string
    type: $Enums.MediaType
    title: string | null
    description: string | null
    url: string
    thumbnailUrl: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: ArtistMediaCountAggregateOutputType | null
    _avg: ArtistMediaAvgAggregateOutputType | null
    _sum: ArtistMediaSumAggregateOutputType | null
    _min: ArtistMediaMinAggregateOutputType | null
    _max: ArtistMediaMaxAggregateOutputType | null
  }

  type GetArtistMediaGroupByPayload<T extends ArtistMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistMediaGroupByOutputType[P]>
        }
      >
    >


  export type ArtistMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistMedia"]>

  export type ArtistMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistMedia"]>

  export type ArtistMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistMedia"]>

  export type ArtistMediaSelectScalar = {
    id?: boolean
    artistId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArtistMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artistId" | "type" | "title" | "description" | "url" | "thumbnailUrl" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["artistMedia"]>
  export type ArtistMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }
  export type ArtistMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }
  export type ArtistMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistProfileDefaultArgs<ExtArgs>
  }

  export type $ArtistMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtistMedia"
    objects: {
      artist: Prisma.$ArtistProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artistId: string
      type: $Enums.MediaType
      title: string | null
      description: string | null
      url: string
      thumbnailUrl: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["artistMedia"]>
    composites: {}
  }

  type ArtistMediaGetPayload<S extends boolean | null | undefined | ArtistMediaDefaultArgs> = $Result.GetResult<Prisma.$ArtistMediaPayload, S>

  type ArtistMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistMediaCountAggregateInputType | true
    }

  export interface ArtistMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtistMedia'], meta: { name: 'ArtistMedia' } }
    /**
     * Find zero or one ArtistMedia that matches the filter.
     * @param {ArtistMediaFindUniqueArgs} args - Arguments to find a ArtistMedia
     * @example
     * // Get one ArtistMedia
     * const artistMedia = await prisma.artistMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistMediaFindUniqueArgs>(args: SelectSubset<T, ArtistMediaFindUniqueArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtistMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistMediaFindUniqueOrThrowArgs} args - Arguments to find a ArtistMedia
     * @example
     * // Get one ArtistMedia
     * const artistMedia = await prisma.artistMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaFindFirstArgs} args - Arguments to find a ArtistMedia
     * @example
     * // Get one ArtistMedia
     * const artistMedia = await prisma.artistMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistMediaFindFirstArgs>(args?: SelectSubset<T, ArtistMediaFindFirstArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaFindFirstOrThrowArgs} args - Arguments to find a ArtistMedia
     * @example
     * // Get one ArtistMedia
     * const artistMedia = await prisma.artistMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtistMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtistMedias
     * const artistMedias = await prisma.artistMedia.findMany()
     * 
     * // Get first 10 ArtistMedias
     * const artistMedias = await prisma.artistMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artistMediaWithIdOnly = await prisma.artistMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtistMediaFindManyArgs>(args?: SelectSubset<T, ArtistMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtistMedia.
     * @param {ArtistMediaCreateArgs} args - Arguments to create a ArtistMedia.
     * @example
     * // Create one ArtistMedia
     * const ArtistMedia = await prisma.artistMedia.create({
     *   data: {
     *     // ... data to create a ArtistMedia
     *   }
     * })
     * 
     */
    create<T extends ArtistMediaCreateArgs>(args: SelectSubset<T, ArtistMediaCreateArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtistMedias.
     * @param {ArtistMediaCreateManyArgs} args - Arguments to create many ArtistMedias.
     * @example
     * // Create many ArtistMedias
     * const artistMedia = await prisma.artistMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistMediaCreateManyArgs>(args?: SelectSubset<T, ArtistMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtistMedias and returns the data saved in the database.
     * @param {ArtistMediaCreateManyAndReturnArgs} args - Arguments to create many ArtistMedias.
     * @example
     * // Create many ArtistMedias
     * const artistMedia = await prisma.artistMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtistMedias and only return the `id`
     * const artistMediaWithIdOnly = await prisma.artistMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtistMedia.
     * @param {ArtistMediaDeleteArgs} args - Arguments to delete one ArtistMedia.
     * @example
     * // Delete one ArtistMedia
     * const ArtistMedia = await prisma.artistMedia.delete({
     *   where: {
     *     // ... filter to delete one ArtistMedia
     *   }
     * })
     * 
     */
    delete<T extends ArtistMediaDeleteArgs>(args: SelectSubset<T, ArtistMediaDeleteArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtistMedia.
     * @param {ArtistMediaUpdateArgs} args - Arguments to update one ArtistMedia.
     * @example
     * // Update one ArtistMedia
     * const artistMedia = await prisma.artistMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistMediaUpdateArgs>(args: SelectSubset<T, ArtistMediaUpdateArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtistMedias.
     * @param {ArtistMediaDeleteManyArgs} args - Arguments to filter ArtistMedias to delete.
     * @example
     * // Delete a few ArtistMedias
     * const { count } = await prisma.artistMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistMediaDeleteManyArgs>(args?: SelectSubset<T, ArtistMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtistMedias
     * const artistMedia = await prisma.artistMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistMediaUpdateManyArgs>(args: SelectSubset<T, ArtistMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistMedias and returns the data updated in the database.
     * @param {ArtistMediaUpdateManyAndReturnArgs} args - Arguments to update many ArtistMedias.
     * @example
     * // Update many ArtistMedias
     * const artistMedia = await prisma.artistMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtistMedias and only return the `id`
     * const artistMediaWithIdOnly = await prisma.artistMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtistMedia.
     * @param {ArtistMediaUpsertArgs} args - Arguments to update or create a ArtistMedia.
     * @example
     * // Update or create a ArtistMedia
     * const artistMedia = await prisma.artistMedia.upsert({
     *   create: {
     *     // ... data to create a ArtistMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtistMedia we want to update
     *   }
     * })
     */
    upsert<T extends ArtistMediaUpsertArgs>(args: SelectSubset<T, ArtistMediaUpsertArgs<ExtArgs>>): Prisma__ArtistMediaClient<$Result.GetResult<Prisma.$ArtistMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtistMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaCountArgs} args - Arguments to filter ArtistMedias to count.
     * @example
     * // Count the number of ArtistMedias
     * const count = await prisma.artistMedia.count({
     *   where: {
     *     // ... the filter for the ArtistMedias we want to count
     *   }
     * })
    **/
    count<T extends ArtistMediaCountArgs>(
      args?: Subset<T, ArtistMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtistMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistMediaAggregateArgs>(args: Subset<T, ArtistMediaAggregateArgs>): Prisma.PrismaPromise<GetArtistMediaAggregateType<T>>

    /**
     * Group by ArtistMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistMediaGroupByArgs['orderBy'] }
        : { orderBy?: ArtistMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtistMedia model
   */
  readonly fields: ArtistMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtistMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistProfileDefaultArgs<ExtArgs>>): Prisma__ArtistProfileClient<$Result.GetResult<Prisma.$ArtistProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtistMedia model
   */
  interface ArtistMediaFieldRefs {
    readonly id: FieldRef<"ArtistMedia", 'String'>
    readonly artistId: FieldRef<"ArtistMedia", 'String'>
    readonly type: FieldRef<"ArtistMedia", 'MediaType'>
    readonly title: FieldRef<"ArtistMedia", 'String'>
    readonly description: FieldRef<"ArtistMedia", 'String'>
    readonly url: FieldRef<"ArtistMedia", 'String'>
    readonly thumbnailUrl: FieldRef<"ArtistMedia", 'String'>
    readonly order: FieldRef<"ArtistMedia", 'Int'>
    readonly createdAt: FieldRef<"ArtistMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"ArtistMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArtistMedia findUnique
   */
  export type ArtistMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter, which ArtistMedia to fetch.
     */
    where: ArtistMediaWhereUniqueInput
  }

  /**
   * ArtistMedia findUniqueOrThrow
   */
  export type ArtistMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter, which ArtistMedia to fetch.
     */
    where: ArtistMediaWhereUniqueInput
  }

  /**
   * ArtistMedia findFirst
   */
  export type ArtistMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter, which ArtistMedia to fetch.
     */
    where?: ArtistMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistMedias to fetch.
     */
    orderBy?: ArtistMediaOrderByWithRelationInput | ArtistMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistMedias.
     */
    cursor?: ArtistMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistMedias.
     */
    distinct?: ArtistMediaScalarFieldEnum | ArtistMediaScalarFieldEnum[]
  }

  /**
   * ArtistMedia findFirstOrThrow
   */
  export type ArtistMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter, which ArtistMedia to fetch.
     */
    where?: ArtistMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistMedias to fetch.
     */
    orderBy?: ArtistMediaOrderByWithRelationInput | ArtistMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistMedias.
     */
    cursor?: ArtistMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistMedias.
     */
    distinct?: ArtistMediaScalarFieldEnum | ArtistMediaScalarFieldEnum[]
  }

  /**
   * ArtistMedia findMany
   */
  export type ArtistMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter, which ArtistMedias to fetch.
     */
    where?: ArtistMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistMedias to fetch.
     */
    orderBy?: ArtistMediaOrderByWithRelationInput | ArtistMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtistMedias.
     */
    cursor?: ArtistMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistMedias.
     */
    skip?: number
    distinct?: ArtistMediaScalarFieldEnum | ArtistMediaScalarFieldEnum[]
  }

  /**
   * ArtistMedia create
   */
  export type ArtistMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtistMedia.
     */
    data: XOR<ArtistMediaCreateInput, ArtistMediaUncheckedCreateInput>
  }

  /**
   * ArtistMedia createMany
   */
  export type ArtistMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtistMedias.
     */
    data: ArtistMediaCreateManyInput | ArtistMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtistMedia createManyAndReturn
   */
  export type ArtistMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * The data used to create many ArtistMedias.
     */
    data: ArtistMediaCreateManyInput | ArtistMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistMedia update
   */
  export type ArtistMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtistMedia.
     */
    data: XOR<ArtistMediaUpdateInput, ArtistMediaUncheckedUpdateInput>
    /**
     * Choose, which ArtistMedia to update.
     */
    where: ArtistMediaWhereUniqueInput
  }

  /**
   * ArtistMedia updateMany
   */
  export type ArtistMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtistMedias.
     */
    data: XOR<ArtistMediaUpdateManyMutationInput, ArtistMediaUncheckedUpdateManyInput>
    /**
     * Filter which ArtistMedias to update
     */
    where?: ArtistMediaWhereInput
    /**
     * Limit how many ArtistMedias to update.
     */
    limit?: number
  }

  /**
   * ArtistMedia updateManyAndReturn
   */
  export type ArtistMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * The data used to update ArtistMedias.
     */
    data: XOR<ArtistMediaUpdateManyMutationInput, ArtistMediaUncheckedUpdateManyInput>
    /**
     * Filter which ArtistMedias to update
     */
    where?: ArtistMediaWhereInput
    /**
     * Limit how many ArtistMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistMedia upsert
   */
  export type ArtistMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtistMedia to update in case it exists.
     */
    where: ArtistMediaWhereUniqueInput
    /**
     * In case the ArtistMedia found by the `where` argument doesn't exist, create a new ArtistMedia with this data.
     */
    create: XOR<ArtistMediaCreateInput, ArtistMediaUncheckedCreateInput>
    /**
     * In case the ArtistMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistMediaUpdateInput, ArtistMediaUncheckedUpdateInput>
  }

  /**
   * ArtistMedia delete
   */
  export type ArtistMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
    /**
     * Filter which ArtistMedia to delete.
     */
    where: ArtistMediaWhereUniqueInput
  }

  /**
   * ArtistMedia deleteMany
   */
  export type ArtistMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistMedias to delete
     */
    where?: ArtistMediaWhereInput
    /**
     * Limit how many ArtistMedias to delete.
     */
    limit?: number
  }

  /**
   * ArtistMedia without action
   */
  export type ArtistMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistMedia
     */
    select?: ArtistMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistMedia
     */
    omit?: ArtistMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistMediaInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    followersCount: number | null
    followingCount: number | null
    postsCount: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    followersCount: number | null
    followingCount: number | null
    postsCount: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    bio: string | null
    avatar: string | null
    coverImage: string | null
    provincia: string | null
    city: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    tiktokHandle: string | null
    spotifyUrl: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    isPublic: boolean | null
    followersCount: number | null
    followingCount: number | null
    postsCount: number | null
    verifiedBadge: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    slug: string | null
    bio: string | null
    avatar: string | null
    coverImage: string | null
    provincia: string | null
    city: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    tiktokHandle: string | null
    spotifyUrl: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    isPublic: boolean | null
    followersCount: number | null
    followingCount: number | null
    postsCount: number | null
    verifiedBadge: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    slug: number
    bio: number
    avatar: number
    coverImage: number
    provincia: number
    city: number
    birthDate: number
    gender: number
    interests: number
    favoriteGenres: number
    preferredVenues: number
    tiktokHandle: number
    spotifyUrl: number
    whatsappNumber: number
    telegramHandle: number
    isPublic: number
    followersCount: number
    followingCount: number
    postsCount: number
    verifiedBadge: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    followersCount?: true
    followingCount?: true
    postsCount?: true
  }

  export type UserProfileSumAggregateInputType = {
    followersCount?: true
    followingCount?: true
    postsCount?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    bio?: true
    avatar?: true
    coverImage?: true
    provincia?: true
    city?: true
    birthDate?: true
    gender?: true
    tiktokHandle?: true
    spotifyUrl?: true
    whatsappNumber?: true
    telegramHandle?: true
    isPublic?: true
    followersCount?: true
    followingCount?: true
    postsCount?: true
    verifiedBadge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    bio?: true
    avatar?: true
    coverImage?: true
    provincia?: true
    city?: true
    birthDate?: true
    gender?: true
    tiktokHandle?: true
    spotifyUrl?: true
    whatsappNumber?: true
    telegramHandle?: true
    isPublic?: true
    followersCount?: true
    followingCount?: true
    postsCount?: true
    verifiedBadge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    slug?: true
    bio?: true
    avatar?: true
    coverImage?: true
    provincia?: true
    city?: true
    birthDate?: true
    gender?: true
    interests?: true
    favoriteGenres?: true
    preferredVenues?: true
    tiktokHandle?: true
    spotifyUrl?: true
    whatsappNumber?: true
    telegramHandle?: true
    isPublic?: true
    followersCount?: true
    followingCount?: true
    postsCount?: true
    verifiedBadge?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    slug: string | null
    bio: string | null
    avatar: string | null
    coverImage: string | null
    provincia: string | null
    city: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    interests: string[]
    favoriteGenres: string[]
    preferredVenues: string[]
    tiktokHandle: string | null
    spotifyUrl: string | null
    whatsappNumber: string | null
    telegramHandle: string | null
    isPublic: boolean
    followersCount: number
    followingCount: number
    postsCount: number
    verifiedBadge: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    coverImage?: boolean
    provincia?: boolean
    city?: boolean
    birthDate?: boolean
    gender?: boolean
    interests?: boolean
    favoriteGenres?: boolean
    preferredVenues?: boolean
    tiktokHandle?: boolean
    spotifyUrl?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    isPublic?: boolean
    followersCount?: boolean
    followingCount?: boolean
    postsCount?: boolean
    verifiedBadge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    coverImage?: boolean
    provincia?: boolean
    city?: boolean
    birthDate?: boolean
    gender?: boolean
    interests?: boolean
    favoriteGenres?: boolean
    preferredVenues?: boolean
    tiktokHandle?: boolean
    spotifyUrl?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    isPublic?: boolean
    followersCount?: boolean
    followingCount?: boolean
    postsCount?: boolean
    verifiedBadge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    coverImage?: boolean
    provincia?: boolean
    city?: boolean
    birthDate?: boolean
    gender?: boolean
    interests?: boolean
    favoriteGenres?: boolean
    preferredVenues?: boolean
    tiktokHandle?: boolean
    spotifyUrl?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    isPublic?: boolean
    followersCount?: boolean
    followingCount?: boolean
    postsCount?: boolean
    verifiedBadge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    slug?: boolean
    bio?: boolean
    avatar?: boolean
    coverImage?: boolean
    provincia?: boolean
    city?: boolean
    birthDate?: boolean
    gender?: boolean
    interests?: boolean
    favoriteGenres?: boolean
    preferredVenues?: boolean
    tiktokHandle?: boolean
    spotifyUrl?: boolean
    whatsappNumber?: boolean
    telegramHandle?: boolean
    isPublic?: boolean
    followersCount?: boolean
    followingCount?: boolean
    postsCount?: boolean
    verifiedBadge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "slug" | "bio" | "avatar" | "coverImage" | "provincia" | "city" | "birthDate" | "gender" | "interests" | "favoriteGenres" | "preferredVenues" | "tiktokHandle" | "spotifyUrl" | "whatsappNumber" | "telegramHandle" | "isPublic" | "followersCount" | "followingCount" | "postsCount" | "verifiedBadge" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      slug: string | null
      bio: string | null
      avatar: string | null
      coverImage: string | null
      provincia: string | null
      city: string | null
      birthDate: Date | null
      gender: $Enums.Gender | null
      interests: string[]
      favoriteGenres: string[]
      preferredVenues: string[]
      tiktokHandle: string | null
      spotifyUrl: string | null
      whatsappNumber: string | null
      telegramHandle: string | null
      isPublic: boolean
      followersCount: number
      followingCount: number
      postsCount: number
      verifiedBadge: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly slug: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly avatar: FieldRef<"UserProfile", 'String'>
    readonly coverImage: FieldRef<"UserProfile", 'String'>
    readonly provincia: FieldRef<"UserProfile", 'String'>
    readonly city: FieldRef<"UserProfile", 'String'>
    readonly birthDate: FieldRef<"UserProfile", 'DateTime'>
    readonly gender: FieldRef<"UserProfile", 'Gender'>
    readonly interests: FieldRef<"UserProfile", 'String[]'>
    readonly favoriteGenres: FieldRef<"UserProfile", 'String[]'>
    readonly preferredVenues: FieldRef<"UserProfile", 'String[]'>
    readonly tiktokHandle: FieldRef<"UserProfile", 'String'>
    readonly spotifyUrl: FieldRef<"UserProfile", 'String'>
    readonly whatsappNumber: FieldRef<"UserProfile", 'String'>
    readonly telegramHandle: FieldRef<"UserProfile", 'String'>
    readonly isPublic: FieldRef<"UserProfile", 'Boolean'>
    readonly followersCount: FieldRef<"UserProfile", 'Int'>
    readonly followingCount: FieldRef<"UserProfile", 'Int'>
    readonly postsCount: FieldRef<"UserProfile", 'Int'>
    readonly verifiedBadge: FieldRef<"UserProfile", 'Boolean'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserFollow
   */

  export type AggregateUserFollow = {
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  export type UserFollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type UserFollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type UserFollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type UserFollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type UserFollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type UserFollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollow to aggregate.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFollows
    **/
    _count?: true | UserFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFollowMaxAggregateInputType
  }

  export type GetUserFollowAggregateType<T extends UserFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFollow[P]>
      : GetScalarType<T[P], AggregateUserFollow[P]>
  }




  export type UserFollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithAggregationInput | UserFollowOrderByWithAggregationInput[]
    by: UserFollowScalarFieldEnum[] | UserFollowScalarFieldEnum
    having?: UserFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFollowCountAggregateInputType | true
    _min?: UserFollowMinAggregateInputType
    _max?: UserFollowMaxAggregateInputType
  }

  export type UserFollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  type GetUserFollowGroupByPayload<T extends UserFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
            : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
        }
      >
    >


  export type UserFollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type UserFollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["userFollow"]>
  export type UserFollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFollow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["userFollow"]>
    composites: {}
  }

  type UserFollowGetPayload<S extends boolean | null | undefined | UserFollowDefaultArgs> = $Result.GetResult<Prisma.$UserFollowPayload, S>

  type UserFollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFollowCountAggregateInputType | true
    }

  export interface UserFollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFollow'], meta: { name: 'UserFollow' } }
    /**
     * Find zero or one UserFollow that matches the filter.
     * @param {UserFollowFindUniqueArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFollowFindUniqueArgs>(args: SelectSubset<T, UserFollowFindUniqueArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFollow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFollowFindUniqueOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFollowFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFollowFindFirstArgs>(args?: SelectSubset<T, UserFollowFindFirstArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFollowFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFollows
     * const userFollows = await prisma.userFollow.findMany()
     * 
     * // Get first 10 UserFollows
     * const userFollows = await prisma.userFollow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFollowFindManyArgs>(args?: SelectSubset<T, UserFollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFollow.
     * @param {UserFollowCreateArgs} args - Arguments to create a UserFollow.
     * @example
     * // Create one UserFollow
     * const UserFollow = await prisma.userFollow.create({
     *   data: {
     *     // ... data to create a UserFollow
     *   }
     * })
     * 
     */
    create<T extends UserFollowCreateArgs>(args: SelectSubset<T, UserFollowCreateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFollows.
     * @param {UserFollowCreateManyArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFollowCreateManyArgs>(args?: SelectSubset<T, UserFollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFollows and returns the data saved in the database.
     * @param {UserFollowCreateManyAndReturnArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFollows and only return the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFollowCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFollow.
     * @param {UserFollowDeleteArgs} args - Arguments to delete one UserFollow.
     * @example
     * // Delete one UserFollow
     * const UserFollow = await prisma.userFollow.delete({
     *   where: {
     *     // ... filter to delete one UserFollow
     *   }
     * })
     * 
     */
    delete<T extends UserFollowDeleteArgs>(args: SelectSubset<T, UserFollowDeleteArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFollow.
     * @param {UserFollowUpdateArgs} args - Arguments to update one UserFollow.
     * @example
     * // Update one UserFollow
     * const userFollow = await prisma.userFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFollowUpdateArgs>(args: SelectSubset<T, UserFollowUpdateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFollows.
     * @param {UserFollowDeleteManyArgs} args - Arguments to filter UserFollows to delete.
     * @example
     * // Delete a few UserFollows
     * const { count } = await prisma.userFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFollowDeleteManyArgs>(args?: SelectSubset<T, UserFollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFollowUpdateManyArgs>(args: SelectSubset<T, UserFollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows and returns the data updated in the database.
     * @param {UserFollowUpdateManyAndReturnArgs} args - Arguments to update many UserFollows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFollows and only return the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFollowUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFollow.
     * @param {UserFollowUpsertArgs} args - Arguments to update or create a UserFollow.
     * @example
     * // Update or create a UserFollow
     * const userFollow = await prisma.userFollow.upsert({
     *   create: {
     *     // ... data to create a UserFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFollow we want to update
     *   }
     * })
     */
    upsert<T extends UserFollowUpsertArgs>(args: SelectSubset<T, UserFollowUpsertArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowCountArgs} args - Arguments to filter UserFollows to count.
     * @example
     * // Count the number of UserFollows
     * const count = await prisma.userFollow.count({
     *   where: {
     *     // ... the filter for the UserFollows we want to count
     *   }
     * })
    **/
    count<T extends UserFollowCountArgs>(
      args?: Subset<T, UserFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFollowAggregateArgs>(args: Subset<T, UserFollowAggregateArgs>): Prisma.PrismaPromise<GetUserFollowAggregateType<T>>

    /**
     * Group by UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFollowGroupByArgs['orderBy'] }
        : { orderBy?: UserFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFollow model
   */
  readonly fields: UserFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFollow model
   */
  interface UserFollowFieldRefs {
    readonly id: FieldRef<"UserFollow", 'String'>
    readonly followerId: FieldRef<"UserFollow", 'String'>
    readonly followingId: FieldRef<"UserFollow", 'String'>
    readonly createdAt: FieldRef<"UserFollow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFollow findUnique
   */
  export type UserFollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findUniqueOrThrow
   */
  export type UserFollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findFirst
   */
  export type UserFollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findFirstOrThrow
   */
  export type UserFollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findMany
   */
  export type UserFollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollows to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow create
   */
  export type UserFollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFollow.
     */
    data: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
  }

  /**
   * UserFollow createMany
   */
  export type UserFollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFollow createManyAndReturn
   */
  export type UserFollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow update
   */
  export type UserFollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFollow.
     */
    data: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
    /**
     * Choose, which UserFollow to update.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow updateMany
   */
  export type UserFollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
  }

  /**
   * UserFollow updateManyAndReturn
   */
  export type UserFollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow upsert
   */
  export type UserFollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFollow to update in case it exists.
     */
    where: UserFollowWhereUniqueInput
    /**
     * In case the UserFollow found by the `where` argument doesn't exist, create a new UserFollow with this data.
     */
    create: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
    /**
     * In case the UserFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
  }

  /**
   * UserFollow delete
   */
  export type UserFollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter which UserFollow to delete.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow deleteMany
   */
  export type UserFollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollows to delete
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to delete.
     */
    limit?: number
  }

  /**
   * UserFollow without action
   */
  export type UserFollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
  }


  /**
   * Model FeedItem
   */

  export type AggregateFeedItem = {
    _count: FeedItemCountAggregateOutputType | null
    _avg: FeedItemAvgAggregateOutputType | null
    _sum: FeedItemSumAggregateOutputType | null
    _min: FeedItemMinAggregateOutputType | null
    _max: FeedItemMaxAggregateOutputType | null
  }

  export type FeedItemAvgAggregateOutputType = {
    likesCount: number | null
    commentsCount: number | null
  }

  export type FeedItemSumAggregateOutputType = {
    likesCount: number | null
    commentsCount: number | null
  }

  export type FeedItemMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    type: $Enums.FeedItemType | null
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    eventId: string | null
    visibility: $Enums.Visibility | null
    likesCount: number | null
    commentsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedItemMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    type: $Enums.FeedItemType | null
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    eventId: string | null
    visibility: $Enums.Visibility | null
    likesCount: number | null
    commentsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedItemCountAggregateOutputType = {
    id: number
    authorId: number
    type: number
    content: number
    imageUrl: number
    videoUrl: number
    eventId: number
    visibility: number
    likesCount: number
    commentsCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedItemAvgAggregateInputType = {
    likesCount?: true
    commentsCount?: true
  }

  export type FeedItemSumAggregateInputType = {
    likesCount?: true
    commentsCount?: true
  }

  export type FeedItemMinAggregateInputType = {
    id?: true
    authorId?: true
    type?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    eventId?: true
    visibility?: true
    likesCount?: true
    commentsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedItemMaxAggregateInputType = {
    id?: true
    authorId?: true
    type?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    eventId?: true
    visibility?: true
    likesCount?: true
    commentsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedItemCountAggregateInputType = {
    id?: true
    authorId?: true
    type?: true
    content?: true
    imageUrl?: true
    videoUrl?: true
    eventId?: true
    visibility?: true
    likesCount?: true
    commentsCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedItem to aggregate.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedItems
    **/
    _count?: true | FeedItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedItemMaxAggregateInputType
  }

  export type GetFeedItemAggregateType<T extends FeedItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedItem[P]>
      : GetScalarType<T[P], AggregateFeedItem[P]>
  }




  export type FeedItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedItemWhereInput
    orderBy?: FeedItemOrderByWithAggregationInput | FeedItemOrderByWithAggregationInput[]
    by: FeedItemScalarFieldEnum[] | FeedItemScalarFieldEnum
    having?: FeedItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedItemCountAggregateInputType | true
    _avg?: FeedItemAvgAggregateInputType
    _sum?: FeedItemSumAggregateInputType
    _min?: FeedItemMinAggregateInputType
    _max?: FeedItemMaxAggregateInputType
  }

  export type FeedItemGroupByOutputType = {
    id: string
    authorId: string
    type: $Enums.FeedItemType
    content: string | null
    imageUrl: string | null
    videoUrl: string | null
    eventId: string | null
    visibility: $Enums.Visibility
    likesCount: number
    commentsCount: number
    createdAt: Date
    updatedAt: Date
    _count: FeedItemCountAggregateOutputType | null
    _avg: FeedItemAvgAggregateOutputType | null
    _sum: FeedItemSumAggregateOutputType | null
    _min: FeedItemMinAggregateOutputType | null
    _max: FeedItemMaxAggregateOutputType | null
  }

  type GetFeedItemGroupByPayload<T extends FeedItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedItemGroupByOutputType[P]>
            : GetScalarType<T[P], FeedItemGroupByOutputType[P]>
        }
      >
    >


  export type FeedItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    eventId?: boolean
    visibility?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    likes?: boolean | FeedItem$likesArgs<ExtArgs>
    comments?: boolean | FeedItem$commentsArgs<ExtArgs>
    _count?: boolean | FeedItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedItem"]>

  export type FeedItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    eventId?: boolean
    visibility?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedItem"]>

  export type FeedItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    eventId?: boolean
    visibility?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedItem"]>

  export type FeedItemSelectScalar = {
    id?: boolean
    authorId?: boolean
    type?: boolean
    content?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    eventId?: boolean
    visibility?: boolean
    likesCount?: boolean
    commentsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "type" | "content" | "imageUrl" | "videoUrl" | "eventId" | "visibility" | "likesCount" | "commentsCount" | "createdAt" | "updatedAt", ExtArgs["result"]["feedItem"]>
  export type FeedItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    likes?: boolean | FeedItem$likesArgs<ExtArgs>
    comments?: boolean | FeedItem$commentsArgs<ExtArgs>
    _count?: boolean | FeedItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeedItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedItem"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      likes: Prisma.$FeedLikePayload<ExtArgs>[]
      comments: Prisma.$FeedCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      type: $Enums.FeedItemType
      content: string | null
      imageUrl: string | null
      videoUrl: string | null
      eventId: string | null
      visibility: $Enums.Visibility
      likesCount: number
      commentsCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedItem"]>
    composites: {}
  }

  type FeedItemGetPayload<S extends boolean | null | undefined | FeedItemDefaultArgs> = $Result.GetResult<Prisma.$FeedItemPayload, S>

  type FeedItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedItemCountAggregateInputType | true
    }

  export interface FeedItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedItem'], meta: { name: 'FeedItem' } }
    /**
     * Find zero or one FeedItem that matches the filter.
     * @param {FeedItemFindUniqueArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedItemFindUniqueArgs>(args: SelectSubset<T, FeedItemFindUniqueArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedItemFindUniqueOrThrowArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindFirstArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedItemFindFirstArgs>(args?: SelectSubset<T, FeedItemFindFirstArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindFirstOrThrowArgs} args - Arguments to find a FeedItem
     * @example
     * // Get one FeedItem
     * const feedItem = await prisma.feedItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedItems
     * const feedItems = await prisma.feedItem.findMany()
     * 
     * // Get first 10 FeedItems
     * const feedItems = await prisma.feedItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedItemWithIdOnly = await prisma.feedItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedItemFindManyArgs>(args?: SelectSubset<T, FeedItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedItem.
     * @param {FeedItemCreateArgs} args - Arguments to create a FeedItem.
     * @example
     * // Create one FeedItem
     * const FeedItem = await prisma.feedItem.create({
     *   data: {
     *     // ... data to create a FeedItem
     *   }
     * })
     * 
     */
    create<T extends FeedItemCreateArgs>(args: SelectSubset<T, FeedItemCreateArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedItems.
     * @param {FeedItemCreateManyArgs} args - Arguments to create many FeedItems.
     * @example
     * // Create many FeedItems
     * const feedItem = await prisma.feedItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedItemCreateManyArgs>(args?: SelectSubset<T, FeedItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedItems and returns the data saved in the database.
     * @param {FeedItemCreateManyAndReturnArgs} args - Arguments to create many FeedItems.
     * @example
     * // Create many FeedItems
     * const feedItem = await prisma.feedItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedItems and only return the `id`
     * const feedItemWithIdOnly = await prisma.feedItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedItem.
     * @param {FeedItemDeleteArgs} args - Arguments to delete one FeedItem.
     * @example
     * // Delete one FeedItem
     * const FeedItem = await prisma.feedItem.delete({
     *   where: {
     *     // ... filter to delete one FeedItem
     *   }
     * })
     * 
     */
    delete<T extends FeedItemDeleteArgs>(args: SelectSubset<T, FeedItemDeleteArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedItem.
     * @param {FeedItemUpdateArgs} args - Arguments to update one FeedItem.
     * @example
     * // Update one FeedItem
     * const feedItem = await prisma.feedItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedItemUpdateArgs>(args: SelectSubset<T, FeedItemUpdateArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedItems.
     * @param {FeedItemDeleteManyArgs} args - Arguments to filter FeedItems to delete.
     * @example
     * // Delete a few FeedItems
     * const { count } = await prisma.feedItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedItemDeleteManyArgs>(args?: SelectSubset<T, FeedItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedItems
     * const feedItem = await prisma.feedItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedItemUpdateManyArgs>(args: SelectSubset<T, FeedItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedItems and returns the data updated in the database.
     * @param {FeedItemUpdateManyAndReturnArgs} args - Arguments to update many FeedItems.
     * @example
     * // Update many FeedItems
     * const feedItem = await prisma.feedItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedItems and only return the `id`
     * const feedItemWithIdOnly = await prisma.feedItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedItem.
     * @param {FeedItemUpsertArgs} args - Arguments to update or create a FeedItem.
     * @example
     * // Update or create a FeedItem
     * const feedItem = await prisma.feedItem.upsert({
     *   create: {
     *     // ... data to create a FeedItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedItem we want to update
     *   }
     * })
     */
    upsert<T extends FeedItemUpsertArgs>(args: SelectSubset<T, FeedItemUpsertArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemCountArgs} args - Arguments to filter FeedItems to count.
     * @example
     * // Count the number of FeedItems
     * const count = await prisma.feedItem.count({
     *   where: {
     *     // ... the filter for the FeedItems we want to count
     *   }
     * })
    **/
    count<T extends FeedItemCountArgs>(
      args?: Subset<T, FeedItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedItemAggregateArgs>(args: Subset<T, FeedItemAggregateArgs>): Prisma.PrismaPromise<GetFeedItemAggregateType<T>>

    /**
     * Group by FeedItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedItemGroupByArgs['orderBy'] }
        : { orderBy?: FeedItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedItem model
   */
  readonly fields: FeedItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    likes<T extends FeedItem$likesArgs<ExtArgs> = {}>(args?: Subset<T, FeedItem$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends FeedItem$commentsArgs<ExtArgs> = {}>(args?: Subset<T, FeedItem$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedItem model
   */
  interface FeedItemFieldRefs {
    readonly id: FieldRef<"FeedItem", 'String'>
    readonly authorId: FieldRef<"FeedItem", 'String'>
    readonly type: FieldRef<"FeedItem", 'FeedItemType'>
    readonly content: FieldRef<"FeedItem", 'String'>
    readonly imageUrl: FieldRef<"FeedItem", 'String'>
    readonly videoUrl: FieldRef<"FeedItem", 'String'>
    readonly eventId: FieldRef<"FeedItem", 'String'>
    readonly visibility: FieldRef<"FeedItem", 'Visibility'>
    readonly likesCount: FieldRef<"FeedItem", 'Int'>
    readonly commentsCount: FieldRef<"FeedItem", 'Int'>
    readonly createdAt: FieldRef<"FeedItem", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedItem findUnique
   */
  export type FeedItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem findUniqueOrThrow
   */
  export type FeedItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem findFirst
   */
  export type FeedItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedItems.
     */
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem findFirstOrThrow
   */
  export type FeedItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItem to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedItems.
     */
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem findMany
   */
  export type FeedItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter, which FeedItems to fetch.
     */
    where?: FeedItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedItems to fetch.
     */
    orderBy?: FeedItemOrderByWithRelationInput | FeedItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedItems.
     */
    cursor?: FeedItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedItems.
     */
    skip?: number
    distinct?: FeedItemScalarFieldEnum | FeedItemScalarFieldEnum[]
  }

  /**
   * FeedItem create
   */
  export type FeedItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedItem.
     */
    data: XOR<FeedItemCreateInput, FeedItemUncheckedCreateInput>
  }

  /**
   * FeedItem createMany
   */
  export type FeedItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedItems.
     */
    data: FeedItemCreateManyInput | FeedItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedItem createManyAndReturn
   */
  export type FeedItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * The data used to create many FeedItems.
     */
    data: FeedItemCreateManyInput | FeedItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedItem update
   */
  export type FeedItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedItem.
     */
    data: XOR<FeedItemUpdateInput, FeedItemUncheckedUpdateInput>
    /**
     * Choose, which FeedItem to update.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem updateMany
   */
  export type FeedItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedItems.
     */
    data: XOR<FeedItemUpdateManyMutationInput, FeedItemUncheckedUpdateManyInput>
    /**
     * Filter which FeedItems to update
     */
    where?: FeedItemWhereInput
    /**
     * Limit how many FeedItems to update.
     */
    limit?: number
  }

  /**
   * FeedItem updateManyAndReturn
   */
  export type FeedItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * The data used to update FeedItems.
     */
    data: XOR<FeedItemUpdateManyMutationInput, FeedItemUncheckedUpdateManyInput>
    /**
     * Filter which FeedItems to update
     */
    where?: FeedItemWhereInput
    /**
     * Limit how many FeedItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedItem upsert
   */
  export type FeedItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedItem to update in case it exists.
     */
    where: FeedItemWhereUniqueInput
    /**
     * In case the FeedItem found by the `where` argument doesn't exist, create a new FeedItem with this data.
     */
    create: XOR<FeedItemCreateInput, FeedItemUncheckedCreateInput>
    /**
     * In case the FeedItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedItemUpdateInput, FeedItemUncheckedUpdateInput>
  }

  /**
   * FeedItem delete
   */
  export type FeedItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
    /**
     * Filter which FeedItem to delete.
     */
    where: FeedItemWhereUniqueInput
  }

  /**
   * FeedItem deleteMany
   */
  export type FeedItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedItems to delete
     */
    where?: FeedItemWhereInput
    /**
     * Limit how many FeedItems to delete.
     */
    limit?: number
  }

  /**
   * FeedItem.likes
   */
  export type FeedItem$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    where?: FeedLikeWhereInput
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    cursor?: FeedLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedLikeScalarFieldEnum | FeedLikeScalarFieldEnum[]
  }

  /**
   * FeedItem.comments
   */
  export type FeedItem$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    where?: FeedCommentWhereInput
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    cursor?: FeedCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedCommentScalarFieldEnum | FeedCommentScalarFieldEnum[]
  }

  /**
   * FeedItem without action
   */
  export type FeedItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedItem
     */
    select?: FeedItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedItem
     */
    omit?: FeedItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedItemInclude<ExtArgs> | null
  }


  /**
   * Model FeedLike
   */

  export type AggregateFeedLike = {
    _count: FeedLikeCountAggregateOutputType | null
    _min: FeedLikeMinAggregateOutputType | null
    _max: FeedLikeMaxAggregateOutputType | null
  }

  export type FeedLikeMinAggregateOutputType = {
    id: string | null
    feedItemId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FeedLikeMaxAggregateOutputType = {
    id: string | null
    feedItemId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FeedLikeCountAggregateOutputType = {
    id: number
    feedItemId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type FeedLikeMinAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    createdAt?: true
  }

  export type FeedLikeMaxAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    createdAt?: true
  }

  export type FeedLikeCountAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type FeedLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedLike to aggregate.
     */
    where?: FeedLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedLikes to fetch.
     */
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedLikes
    **/
    _count?: true | FeedLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedLikeMaxAggregateInputType
  }

  export type GetFeedLikeAggregateType<T extends FeedLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedLike[P]>
      : GetScalarType<T[P], AggregateFeedLike[P]>
  }




  export type FeedLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedLikeWhereInput
    orderBy?: FeedLikeOrderByWithAggregationInput | FeedLikeOrderByWithAggregationInput[]
    by: FeedLikeScalarFieldEnum[] | FeedLikeScalarFieldEnum
    having?: FeedLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedLikeCountAggregateInputType | true
    _min?: FeedLikeMinAggregateInputType
    _max?: FeedLikeMaxAggregateInputType
  }

  export type FeedLikeGroupByOutputType = {
    id: string
    feedItemId: string
    userId: string
    createdAt: Date
    _count: FeedLikeCountAggregateOutputType | null
    _min: FeedLikeMinAggregateOutputType | null
    _max: FeedLikeMaxAggregateOutputType | null
  }

  type GetFeedLikeGroupByPayload<T extends FeedLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedLikeGroupByOutputType[P]>
            : GetScalarType<T[P], FeedLikeGroupByOutputType[P]>
        }
      >
    >


  export type FeedLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    createdAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedLike"]>

  export type FeedLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    createdAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedLike"]>

  export type FeedLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    createdAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedLike"]>

  export type FeedLikeSelectScalar = {
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type FeedLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feedItemId" | "userId" | "createdAt", ExtArgs["result"]["feedLike"]>
  export type FeedLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedLike"
    objects: {
      feedItem: Prisma.$FeedItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feedItemId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["feedLike"]>
    composites: {}
  }

  type FeedLikeGetPayload<S extends boolean | null | undefined | FeedLikeDefaultArgs> = $Result.GetResult<Prisma.$FeedLikePayload, S>

  type FeedLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedLikeCountAggregateInputType | true
    }

  export interface FeedLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedLike'], meta: { name: 'FeedLike' } }
    /**
     * Find zero or one FeedLike that matches the filter.
     * @param {FeedLikeFindUniqueArgs} args - Arguments to find a FeedLike
     * @example
     * // Get one FeedLike
     * const feedLike = await prisma.feedLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedLikeFindUniqueArgs>(args: SelectSubset<T, FeedLikeFindUniqueArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedLikeFindUniqueOrThrowArgs} args - Arguments to find a FeedLike
     * @example
     * // Get one FeedLike
     * const feedLike = await prisma.feedLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeFindFirstArgs} args - Arguments to find a FeedLike
     * @example
     * // Get one FeedLike
     * const feedLike = await prisma.feedLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedLikeFindFirstArgs>(args?: SelectSubset<T, FeedLikeFindFirstArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeFindFirstOrThrowArgs} args - Arguments to find a FeedLike
     * @example
     * // Get one FeedLike
     * const feedLike = await prisma.feedLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedLikes
     * const feedLikes = await prisma.feedLike.findMany()
     * 
     * // Get first 10 FeedLikes
     * const feedLikes = await prisma.feedLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedLikeWithIdOnly = await prisma.feedLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedLikeFindManyArgs>(args?: SelectSubset<T, FeedLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedLike.
     * @param {FeedLikeCreateArgs} args - Arguments to create a FeedLike.
     * @example
     * // Create one FeedLike
     * const FeedLike = await prisma.feedLike.create({
     *   data: {
     *     // ... data to create a FeedLike
     *   }
     * })
     * 
     */
    create<T extends FeedLikeCreateArgs>(args: SelectSubset<T, FeedLikeCreateArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedLikes.
     * @param {FeedLikeCreateManyArgs} args - Arguments to create many FeedLikes.
     * @example
     * // Create many FeedLikes
     * const feedLike = await prisma.feedLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedLikeCreateManyArgs>(args?: SelectSubset<T, FeedLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedLikes and returns the data saved in the database.
     * @param {FeedLikeCreateManyAndReturnArgs} args - Arguments to create many FeedLikes.
     * @example
     * // Create many FeedLikes
     * const feedLike = await prisma.feedLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedLikes and only return the `id`
     * const feedLikeWithIdOnly = await prisma.feedLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedLike.
     * @param {FeedLikeDeleteArgs} args - Arguments to delete one FeedLike.
     * @example
     * // Delete one FeedLike
     * const FeedLike = await prisma.feedLike.delete({
     *   where: {
     *     // ... filter to delete one FeedLike
     *   }
     * })
     * 
     */
    delete<T extends FeedLikeDeleteArgs>(args: SelectSubset<T, FeedLikeDeleteArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedLike.
     * @param {FeedLikeUpdateArgs} args - Arguments to update one FeedLike.
     * @example
     * // Update one FeedLike
     * const feedLike = await prisma.feedLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedLikeUpdateArgs>(args: SelectSubset<T, FeedLikeUpdateArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedLikes.
     * @param {FeedLikeDeleteManyArgs} args - Arguments to filter FeedLikes to delete.
     * @example
     * // Delete a few FeedLikes
     * const { count } = await prisma.feedLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedLikeDeleteManyArgs>(args?: SelectSubset<T, FeedLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedLikes
     * const feedLike = await prisma.feedLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedLikeUpdateManyArgs>(args: SelectSubset<T, FeedLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedLikes and returns the data updated in the database.
     * @param {FeedLikeUpdateManyAndReturnArgs} args - Arguments to update many FeedLikes.
     * @example
     * // Update many FeedLikes
     * const feedLike = await prisma.feedLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedLikes and only return the `id`
     * const feedLikeWithIdOnly = await prisma.feedLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedLike.
     * @param {FeedLikeUpsertArgs} args - Arguments to update or create a FeedLike.
     * @example
     * // Update or create a FeedLike
     * const feedLike = await prisma.feedLike.upsert({
     *   create: {
     *     // ... data to create a FeedLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedLike we want to update
     *   }
     * })
     */
    upsert<T extends FeedLikeUpsertArgs>(args: SelectSubset<T, FeedLikeUpsertArgs<ExtArgs>>): Prisma__FeedLikeClient<$Result.GetResult<Prisma.$FeedLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeCountArgs} args - Arguments to filter FeedLikes to count.
     * @example
     * // Count the number of FeedLikes
     * const count = await prisma.feedLike.count({
     *   where: {
     *     // ... the filter for the FeedLikes we want to count
     *   }
     * })
    **/
    count<T extends FeedLikeCountArgs>(
      args?: Subset<T, FeedLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedLikeAggregateArgs>(args: Subset<T, FeedLikeAggregateArgs>): Prisma.PrismaPromise<GetFeedLikeAggregateType<T>>

    /**
     * Group by FeedLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedLikeGroupByArgs['orderBy'] }
        : { orderBy?: FeedLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedLike model
   */
  readonly fields: FeedLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedItem<T extends FeedItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedItemDefaultArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedLike model
   */
  interface FeedLikeFieldRefs {
    readonly id: FieldRef<"FeedLike", 'String'>
    readonly feedItemId: FieldRef<"FeedLike", 'String'>
    readonly userId: FieldRef<"FeedLike", 'String'>
    readonly createdAt: FieldRef<"FeedLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedLike findUnique
   */
  export type FeedLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter, which FeedLike to fetch.
     */
    where: FeedLikeWhereUniqueInput
  }

  /**
   * FeedLike findUniqueOrThrow
   */
  export type FeedLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter, which FeedLike to fetch.
     */
    where: FeedLikeWhereUniqueInput
  }

  /**
   * FeedLike findFirst
   */
  export type FeedLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter, which FeedLike to fetch.
     */
    where?: FeedLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedLikes to fetch.
     */
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedLikes.
     */
    cursor?: FeedLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedLikes.
     */
    distinct?: FeedLikeScalarFieldEnum | FeedLikeScalarFieldEnum[]
  }

  /**
   * FeedLike findFirstOrThrow
   */
  export type FeedLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter, which FeedLike to fetch.
     */
    where?: FeedLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedLikes to fetch.
     */
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedLikes.
     */
    cursor?: FeedLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedLikes.
     */
    distinct?: FeedLikeScalarFieldEnum | FeedLikeScalarFieldEnum[]
  }

  /**
   * FeedLike findMany
   */
  export type FeedLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter, which FeedLikes to fetch.
     */
    where?: FeedLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedLikes to fetch.
     */
    orderBy?: FeedLikeOrderByWithRelationInput | FeedLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedLikes.
     */
    cursor?: FeedLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedLikes.
     */
    skip?: number
    distinct?: FeedLikeScalarFieldEnum | FeedLikeScalarFieldEnum[]
  }

  /**
   * FeedLike create
   */
  export type FeedLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedLike.
     */
    data: XOR<FeedLikeCreateInput, FeedLikeUncheckedCreateInput>
  }

  /**
   * FeedLike createMany
   */
  export type FeedLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedLikes.
     */
    data: FeedLikeCreateManyInput | FeedLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedLike createManyAndReturn
   */
  export type FeedLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * The data used to create many FeedLikes.
     */
    data: FeedLikeCreateManyInput | FeedLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedLike update
   */
  export type FeedLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedLike.
     */
    data: XOR<FeedLikeUpdateInput, FeedLikeUncheckedUpdateInput>
    /**
     * Choose, which FeedLike to update.
     */
    where: FeedLikeWhereUniqueInput
  }

  /**
   * FeedLike updateMany
   */
  export type FeedLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedLikes.
     */
    data: XOR<FeedLikeUpdateManyMutationInput, FeedLikeUncheckedUpdateManyInput>
    /**
     * Filter which FeedLikes to update
     */
    where?: FeedLikeWhereInput
    /**
     * Limit how many FeedLikes to update.
     */
    limit?: number
  }

  /**
   * FeedLike updateManyAndReturn
   */
  export type FeedLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * The data used to update FeedLikes.
     */
    data: XOR<FeedLikeUpdateManyMutationInput, FeedLikeUncheckedUpdateManyInput>
    /**
     * Filter which FeedLikes to update
     */
    where?: FeedLikeWhereInput
    /**
     * Limit how many FeedLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedLike upsert
   */
  export type FeedLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedLike to update in case it exists.
     */
    where: FeedLikeWhereUniqueInput
    /**
     * In case the FeedLike found by the `where` argument doesn't exist, create a new FeedLike with this data.
     */
    create: XOR<FeedLikeCreateInput, FeedLikeUncheckedCreateInput>
    /**
     * In case the FeedLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedLikeUpdateInput, FeedLikeUncheckedUpdateInput>
  }

  /**
   * FeedLike delete
   */
  export type FeedLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
    /**
     * Filter which FeedLike to delete.
     */
    where: FeedLikeWhereUniqueInput
  }

  /**
   * FeedLike deleteMany
   */
  export type FeedLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedLikes to delete
     */
    where?: FeedLikeWhereInput
    /**
     * Limit how many FeedLikes to delete.
     */
    limit?: number
  }

  /**
   * FeedLike without action
   */
  export type FeedLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedLike
     */
    select?: FeedLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedLike
     */
    omit?: FeedLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedLikeInclude<ExtArgs> | null
  }


  /**
   * Model FeedComment
   */

  export type AggregateFeedComment = {
    _count: FeedCommentCountAggregateOutputType | null
    _min: FeedCommentMinAggregateOutputType | null
    _max: FeedCommentMaxAggregateOutputType | null
  }

  export type FeedCommentMinAggregateOutputType = {
    id: string | null
    feedItemId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedCommentMaxAggregateOutputType = {
    id: string | null
    feedItemId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedCommentCountAggregateOutputType = {
    id: number
    feedItemId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedCommentMinAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedCommentMaxAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedCommentCountAggregateInputType = {
    id?: true
    feedItemId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedComment to aggregate.
     */
    where?: FeedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedComments to fetch.
     */
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedComments
    **/
    _count?: true | FeedCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedCommentMaxAggregateInputType
  }

  export type GetFeedCommentAggregateType<T extends FeedCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedComment[P]>
      : GetScalarType<T[P], AggregateFeedComment[P]>
  }




  export type FeedCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedCommentWhereInput
    orderBy?: FeedCommentOrderByWithAggregationInput | FeedCommentOrderByWithAggregationInput[]
    by: FeedCommentScalarFieldEnum[] | FeedCommentScalarFieldEnum
    having?: FeedCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedCommentCountAggregateInputType | true
    _min?: FeedCommentMinAggregateInputType
    _max?: FeedCommentMaxAggregateInputType
  }

  export type FeedCommentGroupByOutputType = {
    id: string
    feedItemId: string
    userId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: FeedCommentCountAggregateOutputType | null
    _min: FeedCommentMinAggregateOutputType | null
    _max: FeedCommentMaxAggregateOutputType | null
  }

  type GetFeedCommentGroupByPayload<T extends FeedCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedCommentGroupByOutputType[P]>
            : GetScalarType<T[P], FeedCommentGroupByOutputType[P]>
        }
      >
    >


  export type FeedCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedComment"]>

  export type FeedCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedComment"]>

  export type FeedCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedComment"]>

  export type FeedCommentSelectScalar = {
    id?: boolean
    feedItemId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feedItemId" | "userId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["feedComment"]>
  export type FeedCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedItem?: boolean | FeedItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedComment"
    objects: {
      feedItem: Prisma.$FeedItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feedItemId: string
      userId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedComment"]>
    composites: {}
  }

  type FeedCommentGetPayload<S extends boolean | null | undefined | FeedCommentDefaultArgs> = $Result.GetResult<Prisma.$FeedCommentPayload, S>

  type FeedCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedCommentCountAggregateInputType | true
    }

  export interface FeedCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedComment'], meta: { name: 'FeedComment' } }
    /**
     * Find zero or one FeedComment that matches the filter.
     * @param {FeedCommentFindUniqueArgs} args - Arguments to find a FeedComment
     * @example
     * // Get one FeedComment
     * const feedComment = await prisma.feedComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedCommentFindUniqueArgs>(args: SelectSubset<T, FeedCommentFindUniqueArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedCommentFindUniqueOrThrowArgs} args - Arguments to find a FeedComment
     * @example
     * // Get one FeedComment
     * const feedComment = await prisma.feedComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentFindFirstArgs} args - Arguments to find a FeedComment
     * @example
     * // Get one FeedComment
     * const feedComment = await prisma.feedComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedCommentFindFirstArgs>(args?: SelectSubset<T, FeedCommentFindFirstArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentFindFirstOrThrowArgs} args - Arguments to find a FeedComment
     * @example
     * // Get one FeedComment
     * const feedComment = await prisma.feedComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedComments
     * const feedComments = await prisma.feedComment.findMany()
     * 
     * // Get first 10 FeedComments
     * const feedComments = await prisma.feedComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedCommentWithIdOnly = await prisma.feedComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedCommentFindManyArgs>(args?: SelectSubset<T, FeedCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedComment.
     * @param {FeedCommentCreateArgs} args - Arguments to create a FeedComment.
     * @example
     * // Create one FeedComment
     * const FeedComment = await prisma.feedComment.create({
     *   data: {
     *     // ... data to create a FeedComment
     *   }
     * })
     * 
     */
    create<T extends FeedCommentCreateArgs>(args: SelectSubset<T, FeedCommentCreateArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedComments.
     * @param {FeedCommentCreateManyArgs} args - Arguments to create many FeedComments.
     * @example
     * // Create many FeedComments
     * const feedComment = await prisma.feedComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedCommentCreateManyArgs>(args?: SelectSubset<T, FeedCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedComments and returns the data saved in the database.
     * @param {FeedCommentCreateManyAndReturnArgs} args - Arguments to create many FeedComments.
     * @example
     * // Create many FeedComments
     * const feedComment = await prisma.feedComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedComments and only return the `id`
     * const feedCommentWithIdOnly = await prisma.feedComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedComment.
     * @param {FeedCommentDeleteArgs} args - Arguments to delete one FeedComment.
     * @example
     * // Delete one FeedComment
     * const FeedComment = await prisma.feedComment.delete({
     *   where: {
     *     // ... filter to delete one FeedComment
     *   }
     * })
     * 
     */
    delete<T extends FeedCommentDeleteArgs>(args: SelectSubset<T, FeedCommentDeleteArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedComment.
     * @param {FeedCommentUpdateArgs} args - Arguments to update one FeedComment.
     * @example
     * // Update one FeedComment
     * const feedComment = await prisma.feedComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedCommentUpdateArgs>(args: SelectSubset<T, FeedCommentUpdateArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedComments.
     * @param {FeedCommentDeleteManyArgs} args - Arguments to filter FeedComments to delete.
     * @example
     * // Delete a few FeedComments
     * const { count } = await prisma.feedComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedCommentDeleteManyArgs>(args?: SelectSubset<T, FeedCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedComments
     * const feedComment = await prisma.feedComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedCommentUpdateManyArgs>(args: SelectSubset<T, FeedCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedComments and returns the data updated in the database.
     * @param {FeedCommentUpdateManyAndReturnArgs} args - Arguments to update many FeedComments.
     * @example
     * // Update many FeedComments
     * const feedComment = await prisma.feedComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedComments and only return the `id`
     * const feedCommentWithIdOnly = await prisma.feedComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedComment.
     * @param {FeedCommentUpsertArgs} args - Arguments to update or create a FeedComment.
     * @example
     * // Update or create a FeedComment
     * const feedComment = await prisma.feedComment.upsert({
     *   create: {
     *     // ... data to create a FeedComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedComment we want to update
     *   }
     * })
     */
    upsert<T extends FeedCommentUpsertArgs>(args: SelectSubset<T, FeedCommentUpsertArgs<ExtArgs>>): Prisma__FeedCommentClient<$Result.GetResult<Prisma.$FeedCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentCountArgs} args - Arguments to filter FeedComments to count.
     * @example
     * // Count the number of FeedComments
     * const count = await prisma.feedComment.count({
     *   where: {
     *     // ... the filter for the FeedComments we want to count
     *   }
     * })
    **/
    count<T extends FeedCommentCountArgs>(
      args?: Subset<T, FeedCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedCommentAggregateArgs>(args: Subset<T, FeedCommentAggregateArgs>): Prisma.PrismaPromise<GetFeedCommentAggregateType<T>>

    /**
     * Group by FeedComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedCommentGroupByArgs['orderBy'] }
        : { orderBy?: FeedCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedComment model
   */
  readonly fields: FeedCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedItem<T extends FeedItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedItemDefaultArgs<ExtArgs>>): Prisma__FeedItemClient<$Result.GetResult<Prisma.$FeedItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedComment model
   */
  interface FeedCommentFieldRefs {
    readonly id: FieldRef<"FeedComment", 'String'>
    readonly feedItemId: FieldRef<"FeedComment", 'String'>
    readonly userId: FieldRef<"FeedComment", 'String'>
    readonly content: FieldRef<"FeedComment", 'String'>
    readonly createdAt: FieldRef<"FeedComment", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedComment findUnique
   */
  export type FeedCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter, which FeedComment to fetch.
     */
    where: FeedCommentWhereUniqueInput
  }

  /**
   * FeedComment findUniqueOrThrow
   */
  export type FeedCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter, which FeedComment to fetch.
     */
    where: FeedCommentWhereUniqueInput
  }

  /**
   * FeedComment findFirst
   */
  export type FeedCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter, which FeedComment to fetch.
     */
    where?: FeedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedComments to fetch.
     */
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedComments.
     */
    cursor?: FeedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedComments.
     */
    distinct?: FeedCommentScalarFieldEnum | FeedCommentScalarFieldEnum[]
  }

  /**
   * FeedComment findFirstOrThrow
   */
  export type FeedCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter, which FeedComment to fetch.
     */
    where?: FeedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedComments to fetch.
     */
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedComments.
     */
    cursor?: FeedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedComments.
     */
    distinct?: FeedCommentScalarFieldEnum | FeedCommentScalarFieldEnum[]
  }

  /**
   * FeedComment findMany
   */
  export type FeedCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter, which FeedComments to fetch.
     */
    where?: FeedCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedComments to fetch.
     */
    orderBy?: FeedCommentOrderByWithRelationInput | FeedCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedComments.
     */
    cursor?: FeedCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedComments.
     */
    skip?: number
    distinct?: FeedCommentScalarFieldEnum | FeedCommentScalarFieldEnum[]
  }

  /**
   * FeedComment create
   */
  export type FeedCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedComment.
     */
    data: XOR<FeedCommentCreateInput, FeedCommentUncheckedCreateInput>
  }

  /**
   * FeedComment createMany
   */
  export type FeedCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedComments.
     */
    data: FeedCommentCreateManyInput | FeedCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedComment createManyAndReturn
   */
  export type FeedCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * The data used to create many FeedComments.
     */
    data: FeedCommentCreateManyInput | FeedCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedComment update
   */
  export type FeedCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedComment.
     */
    data: XOR<FeedCommentUpdateInput, FeedCommentUncheckedUpdateInput>
    /**
     * Choose, which FeedComment to update.
     */
    where: FeedCommentWhereUniqueInput
  }

  /**
   * FeedComment updateMany
   */
  export type FeedCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedComments.
     */
    data: XOR<FeedCommentUpdateManyMutationInput, FeedCommentUncheckedUpdateManyInput>
    /**
     * Filter which FeedComments to update
     */
    where?: FeedCommentWhereInput
    /**
     * Limit how many FeedComments to update.
     */
    limit?: number
  }

  /**
   * FeedComment updateManyAndReturn
   */
  export type FeedCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * The data used to update FeedComments.
     */
    data: XOR<FeedCommentUpdateManyMutationInput, FeedCommentUncheckedUpdateManyInput>
    /**
     * Filter which FeedComments to update
     */
    where?: FeedCommentWhereInput
    /**
     * Limit how many FeedComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedComment upsert
   */
  export type FeedCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedComment to update in case it exists.
     */
    where: FeedCommentWhereUniqueInput
    /**
     * In case the FeedComment found by the `where` argument doesn't exist, create a new FeedComment with this data.
     */
    create: XOR<FeedCommentCreateInput, FeedCommentUncheckedCreateInput>
    /**
     * In case the FeedComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedCommentUpdateInput, FeedCommentUncheckedUpdateInput>
  }

  /**
   * FeedComment delete
   */
  export type FeedCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
    /**
     * Filter which FeedComment to delete.
     */
    where: FeedCommentWhereUniqueInput
  }

  /**
   * FeedComment deleteMany
   */
  export type FeedCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedComments to delete
     */
    where?: FeedCommentWhereInput
    /**
     * Limit how many FeedComments to delete.
     */
    limit?: number
  }

  /**
   * FeedComment without action
   */
  export type FeedCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedComment
     */
    select?: FeedCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedComment
     */
    omit?: FeedCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedCommentInclude<ExtArgs> | null
  }


  /**
   * Model IdentityVerification
   */

  export type AggregateIdentityVerification = {
    _count: IdentityVerificationCountAggregateOutputType | null
    _min: IdentityVerificationMinAggregateOutputType | null
    _max: IdentityVerificationMaxAggregateOutputType | null
  }

  export type IdentityVerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    documentType: $Enums.DocumentType | null
    documentNumber: string | null
    documentFrontUrl: string | null
    documentBackUrl: string | null
    selfieUrl: string | null
    status: $Enums.VerificationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentityVerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    documentType: $Enums.DocumentType | null
    documentNumber: string | null
    documentFrontUrl: string | null
    documentBackUrl: string | null
    selfieUrl: string | null
    status: $Enums.VerificationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdentityVerificationCountAggregateOutputType = {
    id: number
    userId: number
    documentType: number
    documentNumber: number
    documentFrontUrl: number
    documentBackUrl: number
    selfieUrl: number
    status: number
    reviewedBy: number
    reviewedAt: number
    rejectionReason: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdentityVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    documentType?: true
    documentNumber?: true
    documentFrontUrl?: true
    documentBackUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentityVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    documentType?: true
    documentNumber?: true
    documentFrontUrl?: true
    documentBackUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdentityVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    documentType?: true
    documentNumber?: true
    documentFrontUrl?: true
    documentBackUrl?: true
    selfieUrl?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdentityVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentityVerification to aggregate.
     */
    where?: IdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityVerifications to fetch.
     */
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdentityVerifications
    **/
    _count?: true | IdentityVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentityVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentityVerificationMaxAggregateInputType
  }

  export type GetIdentityVerificationAggregateType<T extends IdentityVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentityVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentityVerification[P]>
      : GetScalarType<T[P], AggregateIdentityVerification[P]>
  }




  export type IdentityVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityVerificationWhereInput
    orderBy?: IdentityVerificationOrderByWithAggregationInput | IdentityVerificationOrderByWithAggregationInput[]
    by: IdentityVerificationScalarFieldEnum[] | IdentityVerificationScalarFieldEnum
    having?: IdentityVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentityVerificationCountAggregateInputType | true
    _min?: IdentityVerificationMinAggregateInputType
    _max?: IdentityVerificationMaxAggregateInputType
  }

  export type IdentityVerificationGroupByOutputType = {
    id: string
    userId: string
    documentType: $Enums.DocumentType
    documentNumber: string | null
    documentFrontUrl: string
    documentBackUrl: string | null
    selfieUrl: string
    status: $Enums.VerificationStatus
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IdentityVerificationCountAggregateOutputType | null
    _min: IdentityVerificationMinAggregateOutputType | null
    _max: IdentityVerificationMaxAggregateOutputType | null
  }

  type GetIdentityVerificationGroupByPayload<T extends IdentityVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentityVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentityVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentityVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], IdentityVerificationGroupByOutputType[P]>
        }
      >
    >


  export type IdentityVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentFrontUrl?: boolean
    documentBackUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["identityVerification"]>

  export type IdentityVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentFrontUrl?: boolean
    documentBackUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["identityVerification"]>

  export type IdentityVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentFrontUrl?: boolean
    documentBackUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["identityVerification"]>

  export type IdentityVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    documentType?: boolean
    documentNumber?: boolean
    documentFrontUrl?: boolean
    documentBackUrl?: boolean
    selfieUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdentityVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "documentType" | "documentNumber" | "documentFrontUrl" | "documentBackUrl" | "selfieUrl" | "status" | "reviewedBy" | "reviewedAt" | "rejectionReason" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["identityVerification"]>
  export type IdentityVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }
  export type IdentityVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }
  export type IdentityVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | IdentityVerification$reviewerArgs<ExtArgs>
  }

  export type $IdentityVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdentityVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      documentType: $Enums.DocumentType
      documentNumber: string | null
      documentFrontUrl: string
      documentBackUrl: string | null
      selfieUrl: string
      status: $Enums.VerificationStatus
      reviewedBy: string | null
      reviewedAt: Date | null
      rejectionReason: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["identityVerification"]>
    composites: {}
  }

  type IdentityVerificationGetPayload<S extends boolean | null | undefined | IdentityVerificationDefaultArgs> = $Result.GetResult<Prisma.$IdentityVerificationPayload, S>

  type IdentityVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdentityVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentityVerificationCountAggregateInputType | true
    }

  export interface IdentityVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdentityVerification'], meta: { name: 'IdentityVerification' } }
    /**
     * Find zero or one IdentityVerification that matches the filter.
     * @param {IdentityVerificationFindUniqueArgs} args - Arguments to find a IdentityVerification
     * @example
     * // Get one IdentityVerification
     * const identityVerification = await prisma.identityVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentityVerificationFindUniqueArgs>(args: SelectSubset<T, IdentityVerificationFindUniqueArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdentityVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdentityVerificationFindUniqueOrThrowArgs} args - Arguments to find a IdentityVerification
     * @example
     * // Get one IdentityVerification
     * const identityVerification = await prisma.identityVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentityVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentityVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdentityVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationFindFirstArgs} args - Arguments to find a IdentityVerification
     * @example
     * // Get one IdentityVerification
     * const identityVerification = await prisma.identityVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentityVerificationFindFirstArgs>(args?: SelectSubset<T, IdentityVerificationFindFirstArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdentityVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationFindFirstOrThrowArgs} args - Arguments to find a IdentityVerification
     * @example
     * // Get one IdentityVerification
     * const identityVerification = await prisma.identityVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentityVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentityVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdentityVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdentityVerifications
     * const identityVerifications = await prisma.identityVerification.findMany()
     * 
     * // Get first 10 IdentityVerifications
     * const identityVerifications = await prisma.identityVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identityVerificationWithIdOnly = await prisma.identityVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentityVerificationFindManyArgs>(args?: SelectSubset<T, IdentityVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdentityVerification.
     * @param {IdentityVerificationCreateArgs} args - Arguments to create a IdentityVerification.
     * @example
     * // Create one IdentityVerification
     * const IdentityVerification = await prisma.identityVerification.create({
     *   data: {
     *     // ... data to create a IdentityVerification
     *   }
     * })
     * 
     */
    create<T extends IdentityVerificationCreateArgs>(args: SelectSubset<T, IdentityVerificationCreateArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdentityVerifications.
     * @param {IdentityVerificationCreateManyArgs} args - Arguments to create many IdentityVerifications.
     * @example
     * // Create many IdentityVerifications
     * const identityVerification = await prisma.identityVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentityVerificationCreateManyArgs>(args?: SelectSubset<T, IdentityVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdentityVerifications and returns the data saved in the database.
     * @param {IdentityVerificationCreateManyAndReturnArgs} args - Arguments to create many IdentityVerifications.
     * @example
     * // Create many IdentityVerifications
     * const identityVerification = await prisma.identityVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdentityVerifications and only return the `id`
     * const identityVerificationWithIdOnly = await prisma.identityVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentityVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentityVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdentityVerification.
     * @param {IdentityVerificationDeleteArgs} args - Arguments to delete one IdentityVerification.
     * @example
     * // Delete one IdentityVerification
     * const IdentityVerification = await prisma.identityVerification.delete({
     *   where: {
     *     // ... filter to delete one IdentityVerification
     *   }
     * })
     * 
     */
    delete<T extends IdentityVerificationDeleteArgs>(args: SelectSubset<T, IdentityVerificationDeleteArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdentityVerification.
     * @param {IdentityVerificationUpdateArgs} args - Arguments to update one IdentityVerification.
     * @example
     * // Update one IdentityVerification
     * const identityVerification = await prisma.identityVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentityVerificationUpdateArgs>(args: SelectSubset<T, IdentityVerificationUpdateArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdentityVerifications.
     * @param {IdentityVerificationDeleteManyArgs} args - Arguments to filter IdentityVerifications to delete.
     * @example
     * // Delete a few IdentityVerifications
     * const { count } = await prisma.identityVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentityVerificationDeleteManyArgs>(args?: SelectSubset<T, IdentityVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdentityVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdentityVerifications
     * const identityVerification = await prisma.identityVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentityVerificationUpdateManyArgs>(args: SelectSubset<T, IdentityVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdentityVerifications and returns the data updated in the database.
     * @param {IdentityVerificationUpdateManyAndReturnArgs} args - Arguments to update many IdentityVerifications.
     * @example
     * // Update many IdentityVerifications
     * const identityVerification = await prisma.identityVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdentityVerifications and only return the `id`
     * const identityVerificationWithIdOnly = await prisma.identityVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdentityVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, IdentityVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdentityVerification.
     * @param {IdentityVerificationUpsertArgs} args - Arguments to update or create a IdentityVerification.
     * @example
     * // Update or create a IdentityVerification
     * const identityVerification = await prisma.identityVerification.upsert({
     *   create: {
     *     // ... data to create a IdentityVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdentityVerification we want to update
     *   }
     * })
     */
    upsert<T extends IdentityVerificationUpsertArgs>(args: SelectSubset<T, IdentityVerificationUpsertArgs<ExtArgs>>): Prisma__IdentityVerificationClient<$Result.GetResult<Prisma.$IdentityVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdentityVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationCountArgs} args - Arguments to filter IdentityVerifications to count.
     * @example
     * // Count the number of IdentityVerifications
     * const count = await prisma.identityVerification.count({
     *   where: {
     *     // ... the filter for the IdentityVerifications we want to count
     *   }
     * })
    **/
    count<T extends IdentityVerificationCountArgs>(
      args?: Subset<T, IdentityVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentityVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdentityVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentityVerificationAggregateArgs>(args: Subset<T, IdentityVerificationAggregateArgs>): Prisma.PrismaPromise<GetIdentityVerificationAggregateType<T>>

    /**
     * Group by IdentityVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentityVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentityVerificationGroupByArgs['orderBy'] }
        : { orderBy?: IdentityVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentityVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentityVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdentityVerification model
   */
  readonly fields: IdentityVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdentityVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentityVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends IdentityVerification$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, IdentityVerification$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdentityVerification model
   */
  interface IdentityVerificationFieldRefs {
    readonly id: FieldRef<"IdentityVerification", 'String'>
    readonly userId: FieldRef<"IdentityVerification", 'String'>
    readonly documentType: FieldRef<"IdentityVerification", 'DocumentType'>
    readonly documentNumber: FieldRef<"IdentityVerification", 'String'>
    readonly documentFrontUrl: FieldRef<"IdentityVerification", 'String'>
    readonly documentBackUrl: FieldRef<"IdentityVerification", 'String'>
    readonly selfieUrl: FieldRef<"IdentityVerification", 'String'>
    readonly status: FieldRef<"IdentityVerification", 'VerificationStatus'>
    readonly reviewedBy: FieldRef<"IdentityVerification", 'String'>
    readonly reviewedAt: FieldRef<"IdentityVerification", 'DateTime'>
    readonly rejectionReason: FieldRef<"IdentityVerification", 'String'>
    readonly expiresAt: FieldRef<"IdentityVerification", 'DateTime'>
    readonly createdAt: FieldRef<"IdentityVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"IdentityVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IdentityVerification findUnique
   */
  export type IdentityVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which IdentityVerification to fetch.
     */
    where: IdentityVerificationWhereUniqueInput
  }

  /**
   * IdentityVerification findUniqueOrThrow
   */
  export type IdentityVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which IdentityVerification to fetch.
     */
    where: IdentityVerificationWhereUniqueInput
  }

  /**
   * IdentityVerification findFirst
   */
  export type IdentityVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which IdentityVerification to fetch.
     */
    where?: IdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityVerifications to fetch.
     */
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentityVerifications.
     */
    cursor?: IdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentityVerifications.
     */
    distinct?: IdentityVerificationScalarFieldEnum | IdentityVerificationScalarFieldEnum[]
  }

  /**
   * IdentityVerification findFirstOrThrow
   */
  export type IdentityVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which IdentityVerification to fetch.
     */
    where?: IdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityVerifications to fetch.
     */
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentityVerifications.
     */
    cursor?: IdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentityVerifications.
     */
    distinct?: IdentityVerificationScalarFieldEnum | IdentityVerificationScalarFieldEnum[]
  }

  /**
   * IdentityVerification findMany
   */
  export type IdentityVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which IdentityVerifications to fetch.
     */
    where?: IdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityVerifications to fetch.
     */
    orderBy?: IdentityVerificationOrderByWithRelationInput | IdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdentityVerifications.
     */
    cursor?: IdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityVerifications.
     */
    skip?: number
    distinct?: IdentityVerificationScalarFieldEnum | IdentityVerificationScalarFieldEnum[]
  }

  /**
   * IdentityVerification create
   */
  export type IdentityVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a IdentityVerification.
     */
    data: XOR<IdentityVerificationCreateInput, IdentityVerificationUncheckedCreateInput>
  }

  /**
   * IdentityVerification createMany
   */
  export type IdentityVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdentityVerifications.
     */
    data: IdentityVerificationCreateManyInput | IdentityVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdentityVerification createManyAndReturn
   */
  export type IdentityVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many IdentityVerifications.
     */
    data: IdentityVerificationCreateManyInput | IdentityVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdentityVerification update
   */
  export type IdentityVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a IdentityVerification.
     */
    data: XOR<IdentityVerificationUpdateInput, IdentityVerificationUncheckedUpdateInput>
    /**
     * Choose, which IdentityVerification to update.
     */
    where: IdentityVerificationWhereUniqueInput
  }

  /**
   * IdentityVerification updateMany
   */
  export type IdentityVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdentityVerifications.
     */
    data: XOR<IdentityVerificationUpdateManyMutationInput, IdentityVerificationUncheckedUpdateManyInput>
    /**
     * Filter which IdentityVerifications to update
     */
    where?: IdentityVerificationWhereInput
    /**
     * Limit how many IdentityVerifications to update.
     */
    limit?: number
  }

  /**
   * IdentityVerification updateManyAndReturn
   */
  export type IdentityVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * The data used to update IdentityVerifications.
     */
    data: XOR<IdentityVerificationUpdateManyMutationInput, IdentityVerificationUncheckedUpdateManyInput>
    /**
     * Filter which IdentityVerifications to update
     */
    where?: IdentityVerificationWhereInput
    /**
     * Limit how many IdentityVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdentityVerification upsert
   */
  export type IdentityVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the IdentityVerification to update in case it exists.
     */
    where: IdentityVerificationWhereUniqueInput
    /**
     * In case the IdentityVerification found by the `where` argument doesn't exist, create a new IdentityVerification with this data.
     */
    create: XOR<IdentityVerificationCreateInput, IdentityVerificationUncheckedCreateInput>
    /**
     * In case the IdentityVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentityVerificationUpdateInput, IdentityVerificationUncheckedUpdateInput>
  }

  /**
   * IdentityVerification delete
   */
  export type IdentityVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter which IdentityVerification to delete.
     */
    where: IdentityVerificationWhereUniqueInput
  }

  /**
   * IdentityVerification deleteMany
   */
  export type IdentityVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentityVerifications to delete
     */
    where?: IdentityVerificationWhereInput
    /**
     * Limit how many IdentityVerifications to delete.
     */
    limit?: number
  }

  /**
   * IdentityVerification.reviewer
   */
  export type IdentityVerification$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * IdentityVerification without action
   */
  export type IdentityVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityVerification
     */
    select?: IdentityVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdentityVerification
     */
    omit?: IdentityVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityVerificationInclude<ExtArgs> | null
  }


  /**
   * Model UserPhone
   */

  export type AggregateUserPhone = {
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  export type UserPhoneAvgAggregateOutputType = {
    otpAttempts: number | null
  }

  export type UserPhoneSumAggregateOutputType = {
    otpAttempts: number | null
  }

  export type UserPhoneMinAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    phoneVerified: boolean | null
    phoneVerifiedAt: Date | null
    otpCode: string | null
    otpExpiresAt: Date | null
    otpAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhoneMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    phoneVerified: boolean | null
    phoneVerifiedAt: Date | null
    otpCode: string | null
    otpExpiresAt: Date | null
    otpAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhoneCountAggregateOutputType = {
    id: number
    userId: number
    phoneNumber: number
    phoneVerified: number
    phoneVerifiedAt: number
    otpCode: number
    otpExpiresAt: number
    otpAttempts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPhoneAvgAggregateInputType = {
    otpAttempts?: true
  }

  export type UserPhoneSumAggregateInputType = {
    otpAttempts?: true
  }

  export type UserPhoneMinAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    phoneVerified?: true
    phoneVerifiedAt?: true
    otpCode?: true
    otpExpiresAt?: true
    otpAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhoneMaxAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    phoneVerified?: true
    phoneVerifiedAt?: true
    otpCode?: true
    otpExpiresAt?: true
    otpAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhoneCountAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    phoneVerified?: true
    phoneVerifiedAt?: true
    otpCode?: true
    otpExpiresAt?: true
    otpAttempts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhone to aggregate.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhones
    **/
    _count?: true | UserPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhoneMaxAggregateInputType
  }

  export type GetUserPhoneAggregateType<T extends UserPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhone[P]>
      : GetScalarType<T[P], AggregateUserPhone[P]>
  }




  export type UserPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithAggregationInput | UserPhoneOrderByWithAggregationInput[]
    by: UserPhoneScalarFieldEnum[] | UserPhoneScalarFieldEnum
    having?: UserPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhoneCountAggregateInputType | true
    _avg?: UserPhoneAvgAggregateInputType
    _sum?: UserPhoneSumAggregateInputType
    _min?: UserPhoneMinAggregateInputType
    _max?: UserPhoneMaxAggregateInputType
  }

  export type UserPhoneGroupByOutputType = {
    id: string
    userId: string
    phoneNumber: string
    phoneVerified: boolean
    phoneVerifiedAt: Date | null
    otpCode: string | null
    otpExpiresAt: Date | null
    otpAttempts: number
    createdAt: Date
    updatedAt: Date
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  type GetUserPhoneGroupByPayload<T extends UserPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
        }
      >
    >


  export type UserPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    phoneVerifiedAt?: boolean
    otpCode?: boolean
    otpExpiresAt?: boolean
    otpAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    phoneVerifiedAt?: boolean
    otpCode?: boolean
    otpExpiresAt?: boolean
    otpAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    phoneVerifiedAt?: boolean
    otpCode?: boolean
    otpExpiresAt?: boolean
    otpAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectScalar = {
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    phoneVerified?: boolean
    phoneVerifiedAt?: boolean
    otpCode?: boolean
    otpExpiresAt?: boolean
    otpAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "phoneNumber" | "phoneVerified" | "phoneVerifiedAt" | "otpCode" | "otpExpiresAt" | "otpAttempts" | "createdAt" | "updatedAt", ExtArgs["result"]["userPhone"]>
  export type UserPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      phoneNumber: string
      phoneVerified: boolean
      phoneVerifiedAt: Date | null
      otpCode: string | null
      otpExpiresAt: Date | null
      otpAttempts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPhone"]>
    composites: {}
  }

  type UserPhoneGetPayload<S extends boolean | null | undefined | UserPhoneDefaultArgs> = $Result.GetResult<Prisma.$UserPhonePayload, S>

  type UserPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhoneCountAggregateInputType | true
    }

  export interface UserPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhone'], meta: { name: 'UserPhone' } }
    /**
     * Find zero or one UserPhone that matches the filter.
     * @param {UserPhoneFindUniqueArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhoneFindUniqueArgs>(args: SelectSubset<T, UserPhoneFindUniqueArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhoneFindUniqueOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhoneFindFirstArgs>(args?: SelectSubset<T, UserPhoneFindFirstArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhones
     * const userPhones = await prisma.userPhone.findMany()
     * 
     * // Get first 10 UserPhones
     * const userPhones = await prisma.userPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhoneFindManyArgs>(args?: SelectSubset<T, UserPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhone.
     * @param {UserPhoneCreateArgs} args - Arguments to create a UserPhone.
     * @example
     * // Create one UserPhone
     * const UserPhone = await prisma.userPhone.create({
     *   data: {
     *     // ... data to create a UserPhone
     *   }
     * })
     * 
     */
    create<T extends UserPhoneCreateArgs>(args: SelectSubset<T, UserPhoneCreateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhones.
     * @param {UserPhoneCreateManyArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhoneCreateManyArgs>(args?: SelectSubset<T, UserPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPhones and returns the data saved in the database.
     * @param {UserPhoneCreateManyAndReturnArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPhone.
     * @param {UserPhoneDeleteArgs} args - Arguments to delete one UserPhone.
     * @example
     * // Delete one UserPhone
     * const UserPhone = await prisma.userPhone.delete({
     *   where: {
     *     // ... filter to delete one UserPhone
     *   }
     * })
     * 
     */
    delete<T extends UserPhoneDeleteArgs>(args: SelectSubset<T, UserPhoneDeleteArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhone.
     * @param {UserPhoneUpdateArgs} args - Arguments to update one UserPhone.
     * @example
     * // Update one UserPhone
     * const userPhone = await prisma.userPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhoneUpdateArgs>(args: SelectSubset<T, UserPhoneUpdateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhones.
     * @param {UserPhoneDeleteManyArgs} args - Arguments to filter UserPhones to delete.
     * @example
     * // Delete a few UserPhones
     * const { count } = await prisma.userPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhoneDeleteManyArgs>(args?: SelectSubset<T, UserPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhoneUpdateManyArgs>(args: SelectSubset<T, UserPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones and returns the data updated in the database.
     * @param {UserPhoneUpdateManyAndReturnArgs} args - Arguments to update many UserPhones.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPhoneUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPhoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPhone.
     * @param {UserPhoneUpsertArgs} args - Arguments to update or create a UserPhone.
     * @example
     * // Update or create a UserPhone
     * const userPhone = await prisma.userPhone.upsert({
     *   create: {
     *     // ... data to create a UserPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhone we want to update
     *   }
     * })
     */
    upsert<T extends UserPhoneUpsertArgs>(args: SelectSubset<T, UserPhoneUpsertArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneCountArgs} args - Arguments to filter UserPhones to count.
     * @example
     * // Count the number of UserPhones
     * const count = await prisma.userPhone.count({
     *   where: {
     *     // ... the filter for the UserPhones we want to count
     *   }
     * })
    **/
    count<T extends UserPhoneCountArgs>(
      args?: Subset<T, UserPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhoneAggregateArgs>(args: Subset<T, UserPhoneAggregateArgs>): Prisma.PrismaPromise<GetUserPhoneAggregateType<T>>

    /**
     * Group by UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhoneGroupByArgs['orderBy'] }
        : { orderBy?: UserPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhone model
   */
  readonly fields: UserPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhone model
   */
  interface UserPhoneFieldRefs {
    readonly id: FieldRef<"UserPhone", 'String'>
    readonly userId: FieldRef<"UserPhone", 'String'>
    readonly phoneNumber: FieldRef<"UserPhone", 'String'>
    readonly phoneVerified: FieldRef<"UserPhone", 'Boolean'>
    readonly phoneVerifiedAt: FieldRef<"UserPhone", 'DateTime'>
    readonly otpCode: FieldRef<"UserPhone", 'String'>
    readonly otpExpiresAt: FieldRef<"UserPhone", 'DateTime'>
    readonly otpAttempts: FieldRef<"UserPhone", 'Int'>
    readonly createdAt: FieldRef<"UserPhone", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhone findUnique
   */
  export type UserPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findUniqueOrThrow
   */
  export type UserPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findFirst
   */
  export type UserPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findFirstOrThrow
   */
  export type UserPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findMany
   */
  export type UserPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhones to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone create
   */
  export type UserPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhone.
     */
    data: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
  }

  /**
   * UserPhone createMany
   */
  export type UserPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhone createManyAndReturn
   */
  export type UserPhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone update
   */
  export type UserPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhone.
     */
    data: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
    /**
     * Choose, which UserPhone to update.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone updateMany
   */
  export type UserPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
  }

  /**
   * UserPhone updateManyAndReturn
   */
  export type UserPhoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone upsert
   */
  export type UserPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhone to update in case it exists.
     */
    where: UserPhoneWhereUniqueInput
    /**
     * In case the UserPhone found by the `where` argument doesn't exist, create a new UserPhone with this data.
     */
    create: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
    /**
     * In case the UserPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
  }

  /**
   * UserPhone delete
   */
  export type UserPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter which UserPhone to delete.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone deleteMany
   */
  export type UserPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhones to delete
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to delete.
     */
    limit?: number
  }

  /**
   * UserPhone without action
   */
  export type UserPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
  }


  /**
   * Model UserConsent
   */

  export type AggregateUserConsent = {
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  export type UserConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    termsAccepted: boolean | null
    termsAcceptedAt: Date | null
    privacyAccepted: boolean | null
    privacyAcceptedAt: Date | null
    marketingOptIn: boolean | null
    marketingOptInAt: Date | null
    newsletterOptIn: boolean | null
    newsletterOptInAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    termsAccepted: boolean | null
    termsAcceptedAt: Date | null
    privacyAccepted: boolean | null
    privacyAcceptedAt: Date | null
    marketingOptIn: boolean | null
    marketingOptInAt: Date | null
    newsletterOptIn: boolean | null
    newsletterOptInAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserConsentCountAggregateOutputType = {
    id: number
    userId: number
    termsAccepted: number
    termsAcceptedAt: number
    privacyAccepted: number
    privacyAcceptedAt: number
    marketingOptIn: number
    marketingOptInAt: number
    newsletterOptIn: number
    newsletterOptInAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserConsentMinAggregateInputType = {
    id?: true
    userId?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyAcceptedAt?: true
    marketingOptIn?: true
    marketingOptInAt?: true
    newsletterOptIn?: true
    newsletterOptInAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyAcceptedAt?: true
    marketingOptIn?: true
    marketingOptInAt?: true
    newsletterOptIn?: true
    newsletterOptInAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserConsentCountAggregateInputType = {
    id?: true
    userId?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    privacyAccepted?: true
    privacyAcceptedAt?: true
    marketingOptIn?: true
    marketingOptInAt?: true
    newsletterOptIn?: true
    newsletterOptInAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsent to aggregate.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConsents
    **/
    _count?: true | UserConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConsentMaxAggregateInputType
  }

  export type GetUserConsentAggregateType<T extends UserConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConsent[P]>
      : GetScalarType<T[P], AggregateUserConsent[P]>
  }




  export type UserConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithAggregationInput | UserConsentOrderByWithAggregationInput[]
    by: UserConsentScalarFieldEnum[] | UserConsentScalarFieldEnum
    having?: UserConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConsentCountAggregateInputType | true
    _min?: UserConsentMinAggregateInputType
    _max?: UserConsentMaxAggregateInputType
  }

  export type UserConsentGroupByOutputType = {
    id: string
    userId: string
    termsAccepted: boolean
    termsAcceptedAt: Date | null
    privacyAccepted: boolean
    privacyAcceptedAt: Date | null
    marketingOptIn: boolean
    marketingOptInAt: Date | null
    newsletterOptIn: boolean
    newsletterOptInAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  type GetUserConsentGroupByPayload<T extends UserConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
            : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
        }
      >
    >


  export type UserConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyAcceptedAt?: boolean
    marketingOptIn?: boolean
    marketingOptInAt?: boolean
    newsletterOptIn?: boolean
    newsletterOptInAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyAcceptedAt?: boolean
    marketingOptIn?: boolean
    marketingOptInAt?: boolean
    newsletterOptIn?: boolean
    newsletterOptInAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyAcceptedAt?: boolean
    marketingOptIn?: boolean
    marketingOptInAt?: boolean
    newsletterOptIn?: boolean
    newsletterOptInAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    privacyAccepted?: boolean
    privacyAcceptedAt?: boolean
    marketingOptIn?: boolean
    marketingOptInAt?: boolean
    newsletterOptIn?: boolean
    newsletterOptInAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "termsAccepted" | "termsAcceptedAt" | "privacyAccepted" | "privacyAcceptedAt" | "marketingOptIn" | "marketingOptInAt" | "newsletterOptIn" | "newsletterOptInAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userConsent"]>
  export type UserConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      termsAccepted: boolean
      termsAcceptedAt: Date | null
      privacyAccepted: boolean
      privacyAcceptedAt: Date | null
      marketingOptIn: boolean
      marketingOptInAt: Date | null
      newsletterOptIn: boolean
      newsletterOptInAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userConsent"]>
    composites: {}
  }

  type UserConsentGetPayload<S extends boolean | null | undefined | UserConsentDefaultArgs> = $Result.GetResult<Prisma.$UserConsentPayload, S>

  type UserConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserConsentCountAggregateInputType | true
    }

  export interface UserConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConsent'], meta: { name: 'UserConsent' } }
    /**
     * Find zero or one UserConsent that matches the filter.
     * @param {UserConsentFindUniqueArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConsentFindUniqueArgs>(args: SelectSubset<T, UserConsentFindUniqueArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserConsentFindUniqueOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConsentFindFirstArgs>(args?: SelectSubset<T, UserConsentFindFirstArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConsents
     * const userConsents = await prisma.userConsent.findMany()
     * 
     * // Get first 10 UserConsents
     * const userConsents = await prisma.userConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConsentFindManyArgs>(args?: SelectSubset<T, UserConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserConsent.
     * @param {UserConsentCreateArgs} args - Arguments to create a UserConsent.
     * @example
     * // Create one UserConsent
     * const UserConsent = await prisma.userConsent.create({
     *   data: {
     *     // ... data to create a UserConsent
     *   }
     * })
     * 
     */
    create<T extends UserConsentCreateArgs>(args: SelectSubset<T, UserConsentCreateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserConsents.
     * @param {UserConsentCreateManyArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConsentCreateManyArgs>(args?: SelectSubset<T, UserConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConsents and returns the data saved in the database.
     * @param {UserConsentCreateManyAndReturnArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserConsent.
     * @param {UserConsentDeleteArgs} args - Arguments to delete one UserConsent.
     * @example
     * // Delete one UserConsent
     * const UserConsent = await prisma.userConsent.delete({
     *   where: {
     *     // ... filter to delete one UserConsent
     *   }
     * })
     * 
     */
    delete<T extends UserConsentDeleteArgs>(args: SelectSubset<T, UserConsentDeleteArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserConsent.
     * @param {UserConsentUpdateArgs} args - Arguments to update one UserConsent.
     * @example
     * // Update one UserConsent
     * const userConsent = await prisma.userConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConsentUpdateArgs>(args: SelectSubset<T, UserConsentUpdateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserConsents.
     * @param {UserConsentDeleteManyArgs} args - Arguments to filter UserConsents to delete.
     * @example
     * // Delete a few UserConsents
     * const { count } = await prisma.userConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConsentDeleteManyArgs>(args?: SelectSubset<T, UserConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConsentUpdateManyArgs>(args: SelectSubset<T, UserConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents and returns the data updated in the database.
     * @param {UserConsentUpdateManyAndReturnArgs} args - Arguments to update many UserConsents.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserConsent.
     * @param {UserConsentUpsertArgs} args - Arguments to update or create a UserConsent.
     * @example
     * // Update or create a UserConsent
     * const userConsent = await prisma.userConsent.upsert({
     *   create: {
     *     // ... data to create a UserConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConsent we want to update
     *   }
     * })
     */
    upsert<T extends UserConsentUpsertArgs>(args: SelectSubset<T, UserConsentUpsertArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentCountArgs} args - Arguments to filter UserConsents to count.
     * @example
     * // Count the number of UserConsents
     * const count = await prisma.userConsent.count({
     *   where: {
     *     // ... the filter for the UserConsents we want to count
     *   }
     * })
    **/
    count<T extends UserConsentCountArgs>(
      args?: Subset<T, UserConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConsentAggregateArgs>(args: Subset<T, UserConsentAggregateArgs>): Prisma.PrismaPromise<GetUserConsentAggregateType<T>>

    /**
     * Group by UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConsentGroupByArgs['orderBy'] }
        : { orderBy?: UserConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConsent model
   */
  readonly fields: UserConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConsent model
   */
  interface UserConsentFieldRefs {
    readonly id: FieldRef<"UserConsent", 'String'>
    readonly userId: FieldRef<"UserConsent", 'String'>
    readonly termsAccepted: FieldRef<"UserConsent", 'Boolean'>
    readonly termsAcceptedAt: FieldRef<"UserConsent", 'DateTime'>
    readonly privacyAccepted: FieldRef<"UserConsent", 'Boolean'>
    readonly privacyAcceptedAt: FieldRef<"UserConsent", 'DateTime'>
    readonly marketingOptIn: FieldRef<"UserConsent", 'Boolean'>
    readonly marketingOptInAt: FieldRef<"UserConsent", 'DateTime'>
    readonly newsletterOptIn: FieldRef<"UserConsent", 'Boolean'>
    readonly newsletterOptInAt: FieldRef<"UserConsent", 'DateTime'>
    readonly createdAt: FieldRef<"UserConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"UserConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserConsent findUnique
   */
  export type UserConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findUniqueOrThrow
   */
  export type UserConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findFirst
   */
  export type UserConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findFirstOrThrow
   */
  export type UserConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findMany
   */
  export type UserConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsents to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent create
   */
  export type UserConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConsent.
     */
    data: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
  }

  /**
   * UserConsent createMany
   */
  export type UserConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConsent createManyAndReturn
   */
  export type UserConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent update
   */
  export type UserConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConsent.
     */
    data: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
    /**
     * Choose, which UserConsent to update.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent updateMany
   */
  export type UserConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
  }

  /**
   * UserConsent updateManyAndReturn
   */
  export type UserConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent upsert
   */
  export type UserConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConsent to update in case it exists.
     */
    where: UserConsentWhereUniqueInput
    /**
     * In case the UserConsent found by the `where` argument doesn't exist, create a new UserConsent with this data.
     */
    create: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
    /**
     * In case the UserConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
  }

  /**
   * UserConsent delete
   */
  export type UserConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter which UserConsent to delete.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent deleteMany
   */
  export type UserConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsents to delete
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to delete.
     */
    limit?: number
  }

  /**
   * UserConsent without action
   */
  export type UserConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingProgress
   */

  export type AggregateOnboardingProgress = {
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  export type OnboardingProgressAvgAggregateOutputType = {
    currentStep: number | null
  }

  export type OnboardingProgressSumAggregateOutputType = {
    currentStep: number | null
  }

  export type OnboardingProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStep: number | null
    step1Completed: boolean | null
    step2Completed: boolean | null
    step3Completed: boolean | null
    onboardingComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStep: number | null
    step1Completed: boolean | null
    step2Completed: boolean | null
    step3Completed: boolean | null
    onboardingComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingProgressCountAggregateOutputType = {
    id: number
    userId: number
    currentStep: number
    step1Completed: number
    step2Completed: number
    step3Completed: number
    onboardingComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OnboardingProgressAvgAggregateInputType = {
    currentStep?: true
  }

  export type OnboardingProgressSumAggregateInputType = {
    currentStep?: true
  }

  export type OnboardingProgressMinAggregateInputType = {
    id?: true
    userId?: true
    currentStep?: true
    step1Completed?: true
    step2Completed?: true
    step3Completed?: true
    onboardingComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    currentStep?: true
    step1Completed?: true
    step2Completed?: true
    step3Completed?: true
    onboardingComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingProgressCountAggregateInputType = {
    id?: true
    userId?: true
    currentStep?: true
    step1Completed?: true
    step2Completed?: true
    step3Completed?: true
    onboardingComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OnboardingProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgress to aggregate.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingProgresses
    **/
    _count?: true | OnboardingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type GetOnboardingProgressAggregateType<T extends OnboardingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingProgress[P]>
      : GetScalarType<T[P], AggregateOnboardingProgress[P]>
  }




  export type OnboardingProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingProgressWhereInput
    orderBy?: OnboardingProgressOrderByWithAggregationInput | OnboardingProgressOrderByWithAggregationInput[]
    by: OnboardingProgressScalarFieldEnum[] | OnboardingProgressScalarFieldEnum
    having?: OnboardingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingProgressCountAggregateInputType | true
    _avg?: OnboardingProgressAvgAggregateInputType
    _sum?: OnboardingProgressSumAggregateInputType
    _min?: OnboardingProgressMinAggregateInputType
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type OnboardingProgressGroupByOutputType = {
    id: string
    userId: string
    currentStep: number
    step1Completed: boolean
    step2Completed: boolean
    step3Completed: boolean
    onboardingComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  type GetOnboardingProgressGroupByPayload<T extends OnboardingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStep?: boolean
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStep?: boolean
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStep?: boolean
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    currentStep?: boolean
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OnboardingProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentStep" | "step1Completed" | "step2Completed" | "step3Completed" | "onboardingComplete" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["onboardingProgress"]>
  export type OnboardingProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnboardingProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnboardingProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OnboardingProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentStep: number
      step1Completed: boolean
      step2Completed: boolean
      step3Completed: boolean
      onboardingComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["onboardingProgress"]>
    composites: {}
  }

  type OnboardingProgressGetPayload<S extends boolean | null | undefined | OnboardingProgressDefaultArgs> = $Result.GetResult<Prisma.$OnboardingProgressPayload, S>

  type OnboardingProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OnboardingProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OnboardingProgressCountAggregateInputType | true
    }

  export interface OnboardingProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingProgress'], meta: { name: 'OnboardingProgress' } }
    /**
     * Find zero or one OnboardingProgress that matches the filter.
     * @param {OnboardingProgressFindUniqueArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingProgressFindUniqueArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OnboardingProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnboardingProgressFindUniqueOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingProgressFindFirstArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OnboardingProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OnboardingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany()
     * 
     * // Get first 10 OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingProgressFindManyArgs>(args?: SelectSubset<T, OnboardingProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OnboardingProgress.
     * @param {OnboardingProgressCreateArgs} args - Arguments to create a OnboardingProgress.
     * @example
     * // Create one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.create({
     *   data: {
     *     // ... data to create a OnboardingProgress
     *   }
     * })
     * 
     */
    create<T extends OnboardingProgressCreateArgs>(args: SelectSubset<T, OnboardingProgressCreateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OnboardingProgresses.
     * @param {OnboardingProgressCreateManyArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingProgressCreateManyArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingProgresses and returns the data saved in the database.
     * @param {OnboardingProgressCreateManyAndReturnArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingProgresses and only return the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OnboardingProgress.
     * @param {OnboardingProgressDeleteArgs} args - Arguments to delete one OnboardingProgress.
     * @example
     * // Delete one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.delete({
     *   where: {
     *     // ... filter to delete one OnboardingProgress
     *   }
     * })
     * 
     */
    delete<T extends OnboardingProgressDeleteArgs>(args: SelectSubset<T, OnboardingProgressDeleteArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OnboardingProgress.
     * @param {OnboardingProgressUpdateArgs} args - Arguments to update one OnboardingProgress.
     * @example
     * // Update one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingProgressUpdateArgs>(args: SelectSubset<T, OnboardingProgressUpdateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OnboardingProgresses.
     * @param {OnboardingProgressDeleteManyArgs} args - Arguments to filter OnboardingProgresses to delete.
     * @example
     * // Delete a few OnboardingProgresses
     * const { count } = await prisma.onboardingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingProgressDeleteManyArgs>(args?: SelectSubset<T, OnboardingProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingProgressUpdateManyArgs>(args: SelectSubset<T, OnboardingProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingProgresses and returns the data updated in the database.
     * @param {OnboardingProgressUpdateManyAndReturnArgs} args - Arguments to update many OnboardingProgresses.
     * @example
     * // Update many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OnboardingProgresses and only return the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OnboardingProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, OnboardingProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OnboardingProgress.
     * @param {OnboardingProgressUpsertArgs} args - Arguments to update or create a OnboardingProgress.
     * @example
     * // Update or create a OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.upsert({
     *   create: {
     *     // ... data to create a OnboardingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingProgress we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingProgressUpsertArgs>(args: SelectSubset<T, OnboardingProgressUpsertArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressCountArgs} args - Arguments to filter OnboardingProgresses to count.
     * @example
     * // Count the number of OnboardingProgresses
     * const count = await prisma.onboardingProgress.count({
     *   where: {
     *     // ... the filter for the OnboardingProgresses we want to count
     *   }
     * })
    **/
    count<T extends OnboardingProgressCountArgs>(
      args?: Subset<T, OnboardingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingProgressAggregateArgs>(args: Subset<T, OnboardingProgressAggregateArgs>): Prisma.PrismaPromise<GetOnboardingProgressAggregateType<T>>

    /**
     * Group by OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingProgressGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingProgress model
   */
  readonly fields: OnboardingProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingProgress model
   */
  interface OnboardingProgressFieldRefs {
    readonly id: FieldRef<"OnboardingProgress", 'String'>
    readonly userId: FieldRef<"OnboardingProgress", 'String'>
    readonly currentStep: FieldRef<"OnboardingProgress", 'Int'>
    readonly step1Completed: FieldRef<"OnboardingProgress", 'Boolean'>
    readonly step2Completed: FieldRef<"OnboardingProgress", 'Boolean'>
    readonly step3Completed: FieldRef<"OnboardingProgress", 'Boolean'>
    readonly onboardingComplete: FieldRef<"OnboardingProgress", 'Boolean'>
    readonly completedAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly createdAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"OnboardingProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingProgress findUnique
   */
  export type OnboardingProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findUniqueOrThrow
   */
  export type OnboardingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findFirst
   */
  export type OnboardingProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findFirstOrThrow
   */
  export type OnboardingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findMany
   */
  export type OnboardingProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgresses to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress create
   */
  export type OnboardingProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingProgress.
     */
    data: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
  }

  /**
   * OnboardingProgress createMany
   */
  export type OnboardingProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingProgress createManyAndReturn
   */
  export type OnboardingProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingProgress update
   */
  export type OnboardingProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingProgress.
     */
    data: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
    /**
     * Choose, which OnboardingProgress to update.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress updateMany
   */
  export type OnboardingProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingProgresses.
     */
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingProgresses to update
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to update.
     */
    limit?: number
  }

  /**
   * OnboardingProgress updateManyAndReturn
   */
  export type OnboardingProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * The data used to update OnboardingProgresses.
     */
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingProgresses to update
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingProgress upsert
   */
  export type OnboardingProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingProgress to update in case it exists.
     */
    where: OnboardingProgressWhereUniqueInput
    /**
     * In case the OnboardingProgress found by the `where` argument doesn't exist, create a new OnboardingProgress with this data.
     */
    create: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
    /**
     * In case the OnboardingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
  }

  /**
   * OnboardingProgress delete
   */
  export type OnboardingProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter which OnboardingProgress to delete.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress deleteMany
   */
  export type OnboardingProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgresses to delete
     */
    where?: OnboardingProgressWhereInput
    /**
     * Limit how many OnboardingProgresses to delete.
     */
    limit?: number
  }

  /**
   * OnboardingProgress without action
   */
  export type OnboardingProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OnboardingProgress
     */
    omit?: OnboardingProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    passwordHash: 'passwordHash',
    role: 'role',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    username: 'username',
    displayName: 'displayName',
    birthDate: 'birthDate',
    age: 'age',
    ageVerified: 'ageVerified',
    ageConsent: 'ageConsent',
    identityVerified: 'identityVerified',
    identityVerifiedAt: 'identityVerifiedAt',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ClubScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    logo: 'logo',
    coverImage: 'coverImage',
    gallery: 'gallery',
    website: 'website',
    phone: 'phone',
    email: 'email',
    instagram: 'instagram',
    facebook: 'facebook',
    openingHours: 'openingHours',
    priceRange: 'priceRange',
    amenities: 'amenities',
    musicGenres: 'musicGenres',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClubScalarFieldEnum = (typeof ClubScalarFieldEnum)[keyof typeof ClubScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    address: 'address',
    city: 'city',
    capacity: 'capacity',
    whatsappNumber: 'whatsappNumber',
    telegramHandle: 'telegramHandle',
    clubId: 'clubId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    coverUrl: 'coverUrl',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    status: 'status',
    minAge: 'minAge',
    dressCode: 'dressCode',
    venueId: 'venueId',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const PRProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    referralCode: 'referralCode',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PRProfileScalarFieldEnum = (typeof PRProfileScalarFieldEnum)[keyof typeof PRProfileScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    prProfileId: 'prProfileId',
    quotaTotal: 'quotaTotal',
    quotaFemale: 'quotaFemale',
    quotaMale: 'quotaMale',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const ListScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    type: 'type',
    quotaTotal: 'quotaTotal',
    quotaFemale: 'quotaFemale',
    quotaMale: 'quotaMale',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListScalarFieldEnum = (typeof ListScalarFieldEnum)[keyof typeof ListScalarFieldEnum]


  export const GuestScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    nickname: 'nickname',
    birthDate: 'birthDate',
    city: 'city',
    occupation: 'occupation',
    instagram: 'instagram',
    telegramChatId: 'telegramChatId',
    whatsappPhone: 'whatsappPhone',
    totalEvents: 'totalEvents',
    lastEventDate: 'lastEventDate',
    customerSegment: 'customerSegment',
    preferredDays: 'preferredDays',
    averageArrivalTime: 'averageArrivalTime',
    prefersTable: 'prefersTable',
    averageGroupSize: 'averageGroupSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuestScalarFieldEnum = (typeof GuestScalarFieldEnum)[keyof typeof GuestScalarFieldEnum]


  export const ListEntryScalarFieldEnum: {
    id: 'id',
    listId: 'listId',
    guestId: 'guestId',
    addedByUserId: 'addedByUserId',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    gender: 'gender',
    note: 'note',
    createdVia: 'createdVia',
    status: 'status',
    plusOne: 'plusOne',
    bookingMethod: 'bookingMethod',
    referralSource: 'referralSource',
    groupSize: 'groupSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListEntryScalarFieldEnum = (typeof ListEntryScalarFieldEnum)[keyof typeof ListEntryScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    guestId: 'guestId',
    listEntryId: 'listEntryId',
    issuedByUserId: 'issuedByUserId',
    type: 'type',
    price: 'price',
    currency: 'currency',
    code: 'code',
    qrData: 'qrData',
    status: 'status',
    issuedAt: 'issuedAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const CheckInScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    scannedByUserId: 'scannedByUserId',
    scannedAt: 'scannedAt',
    gate: 'gate',
    ok: 'ok',
    notes: 'notes',
    arrivalTime: 'arrivalTime',
    groupSize: 'groupSize'
  };

  export type CheckInScalarFieldEnum = (typeof CheckInScalarFieldEnum)[keyof typeof CheckInScalarFieldEnum]


  export const InviteLinkScalarFieldEnum: {
    id: 'id',
    createdByUserId: 'createdByUserId',
    eventId: 'eventId',
    prProfileId: 'prProfileId',
    slug: 'slug',
    maxUses: 'maxUses',
    uses: 'uses',
    expiresAt: 'expiresAt',
    utmSource: 'utmSource',
    utmMedium: 'utmMedium',
    utmCampaign: 'utmCampaign',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InviteLinkScalarFieldEnum = (typeof InviteLinkScalarFieldEnum)[keyof typeof InviteLinkScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ConsumptionScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    eventId: 'eventId',
    amount: 'amount',
    category: 'category',
    items: 'items',
    createdAt: 'createdAt'
  };

  export type ConsumptionScalarFieldEnum = (typeof ConsumptionScalarFieldEnum)[keyof typeof ConsumptionScalarFieldEnum]


  export const FunnelTrackingScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    eventId: 'eventId',
    step: 'step',
    metadata: 'metadata',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    referer: 'referer',
    timestamp: 'timestamp'
  };

  export type FunnelTrackingScalarFieldEnum = (typeof FunnelTrackingScalarFieldEnum)[keyof typeof FunnelTrackingScalarFieldEnum]


  export const EventFeedbackScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    ticketId: 'ticketId',
    guestId: 'guestId',
    overallRating: 'overallRating',
    musicRating: 'musicRating',
    serviceRating: 'serviceRating',
    venueRating: 'venueRating',
    comment: 'comment',
    wouldReturn: 'wouldReturn',
    interests: 'interests',
    createdAt: 'createdAt'
  };

  export type EventFeedbackScalarFieldEnum = (typeof EventFeedbackScalarFieldEnum)[keyof typeof EventFeedbackScalarFieldEnum]


  export const SecurityNoteScalarFieldEnum: {
    id: 'id',
    guestId: 'guestId',
    eventId: 'eventId',
    ticketId: 'ticketId',
    severity: 'severity',
    type: 'type',
    description: 'description',
    reportedByUserId: 'reportedByUserId',
    actionTaken: 'actionTaken',
    createdAt: 'createdAt'
  };

  export type SecurityNoteScalarFieldEnum = (typeof SecurityNoteScalarFieldEnum)[keyof typeof SecurityNoteScalarFieldEnum]


  export const CustomerPreferencesScalarFieldEnum: {
    id: 'id',
    guestId: 'guestId',
    musicGenres: 'musicGenres',
    dressStyle: 'dressStyle',
    drinkPreferences: 'drinkPreferences',
    avgSpending: 'avgSpending',
    responseToPromo: 'responseToPromo',
    socialEngagement: 'socialEngagement',
    conversionScore: 'conversionScore',
    lifetimeValue: 'lifetimeValue',
    consents: 'consents',
    updatedAt: 'updatedAt'
  };

  export type CustomerPreferencesScalarFieldEnum = (typeof CustomerPreferencesScalarFieldEnum)[keyof typeof CustomerPreferencesScalarFieldEnum]


  export const OrganizationProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    slug: 'slug',
    organizationName: 'organizationName',
    bio: 'bio',
    website: 'website',
    instagram: 'instagram',
    facebook: 'facebook',
    twitter: 'twitter',
    whatsappNumber: 'whatsappNumber',
    telegramHandle: 'telegramHandle',
    logo: 'logo',
    coverImage: 'coverImage',
    verified: 'verified',
    totalEvents: 'totalEvents',
    totalAttendees: 'totalAttendees',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationProfileScalarFieldEnum = (typeof OrganizationProfileScalarFieldEnum)[keyof typeof OrganizationProfileScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    role: 'role',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const ArtistProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    artistName: 'artistName',
    artistType: 'artistType',
    bio: 'bio',
    genres: 'genres',
    website: 'website',
    instagram: 'instagram',
    facebook: 'facebook',
    twitter: 'twitter',
    soundcloud: 'soundcloud',
    spotify: 'spotify',
    youtube: 'youtube',
    avatar: 'avatar',
    coverImage: 'coverImage',
    verified: 'verified',
    totalGigs: 'totalGigs',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArtistProfileScalarFieldEnum = (typeof ArtistProfileScalarFieldEnum)[keyof typeof ArtistProfileScalarFieldEnum]


  export const PerformanceScalarFieldEnum: {
    id: 'id',
    artistId: 'artistId',
    eventId: 'eventId',
    eventName: 'eventName',
    eventDate: 'eventDate',
    venueName: 'venueName',
    city: 'city',
    description: 'description',
    fee: 'fee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceScalarFieldEnum = (typeof PerformanceScalarFieldEnum)[keyof typeof PerformanceScalarFieldEnum]


  export const ArtistMediaScalarFieldEnum: {
    id: 'id',
    artistId: 'artistId',
    type: 'type',
    title: 'title',
    description: 'description',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArtistMediaScalarFieldEnum = (typeof ArtistMediaScalarFieldEnum)[keyof typeof ArtistMediaScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    slug: 'slug',
    bio: 'bio',
    avatar: 'avatar',
    coverImage: 'coverImage',
    provincia: 'provincia',
    city: 'city',
    birthDate: 'birthDate',
    gender: 'gender',
    interests: 'interests',
    favoriteGenres: 'favoriteGenres',
    preferredVenues: 'preferredVenues',
    tiktokHandle: 'tiktokHandle',
    spotifyUrl: 'spotifyUrl',
    whatsappNumber: 'whatsappNumber',
    telegramHandle: 'telegramHandle',
    isPublic: 'isPublic',
    followersCount: 'followersCount',
    followingCount: 'followingCount',
    postsCount: 'postsCount',
    verifiedBadge: 'verifiedBadge',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserFollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type UserFollowScalarFieldEnum = (typeof UserFollowScalarFieldEnum)[keyof typeof UserFollowScalarFieldEnum]


  export const FeedItemScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    type: 'type',
    content: 'content',
    imageUrl: 'imageUrl',
    videoUrl: 'videoUrl',
    eventId: 'eventId',
    visibility: 'visibility',
    likesCount: 'likesCount',
    commentsCount: 'commentsCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedItemScalarFieldEnum = (typeof FeedItemScalarFieldEnum)[keyof typeof FeedItemScalarFieldEnum]


  export const FeedLikeScalarFieldEnum: {
    id: 'id',
    feedItemId: 'feedItemId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type FeedLikeScalarFieldEnum = (typeof FeedLikeScalarFieldEnum)[keyof typeof FeedLikeScalarFieldEnum]


  export const FeedCommentScalarFieldEnum: {
    id: 'id',
    feedItemId: 'feedItemId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedCommentScalarFieldEnum = (typeof FeedCommentScalarFieldEnum)[keyof typeof FeedCommentScalarFieldEnum]


  export const IdentityVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    documentType: 'documentType',
    documentNumber: 'documentNumber',
    documentFrontUrl: 'documentFrontUrl',
    documentBackUrl: 'documentBackUrl',
    selfieUrl: 'selfieUrl',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    rejectionReason: 'rejectionReason',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdentityVerificationScalarFieldEnum = (typeof IdentityVerificationScalarFieldEnum)[keyof typeof IdentityVerificationScalarFieldEnum]


  export const UserPhoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    phoneVerified: 'phoneVerified',
    phoneVerifiedAt: 'phoneVerifiedAt',
    otpCode: 'otpCode',
    otpExpiresAt: 'otpExpiresAt',
    otpAttempts: 'otpAttempts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPhoneScalarFieldEnum = (typeof UserPhoneScalarFieldEnum)[keyof typeof UserPhoneScalarFieldEnum]


  export const UserConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    termsAccepted: 'termsAccepted',
    termsAcceptedAt: 'termsAcceptedAt',
    privacyAccepted: 'privacyAccepted',
    privacyAcceptedAt: 'privacyAcceptedAt',
    marketingOptIn: 'marketingOptIn',
    marketingOptInAt: 'marketingOptInAt',
    newsletterOptIn: 'newsletterOptIn',
    newsletterOptInAt: 'newsletterOptInAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserConsentScalarFieldEnum = (typeof UserConsentScalarFieldEnum)[keyof typeof UserConsentScalarFieldEnum]


  export const OnboardingProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentStep: 'currentStep',
    step1Completed: 'step1Completed',
    step2Completed: 'step2Completed',
    step3Completed: 'step3Completed',
    onboardingComplete: 'onboardingComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OnboardingProgressScalarFieldEnum = (typeof OnboardingProgressScalarFieldEnum)[keyof typeof OnboardingProgressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ClubType'
   */
  export type EnumClubTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubType'>
    


  /**
   * Reference to a field of type 'ClubType[]'
   */
  export type ListEnumClubTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubType[]'>
    


  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


  /**
   * Reference to a field of type 'EventStatus[]'
   */
  export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus[]'>
    


  /**
   * Reference to a field of type 'ListType'
   */
  export type EnumListTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListType'>
    


  /**
   * Reference to a field of type 'ListType[]'
   */
  export type ListEnumListTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListType[]'>
    


  /**
   * Reference to a field of type 'CustomerSegment'
   */
  export type EnumCustomerSegmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerSegment'>
    


  /**
   * Reference to a field of type 'CustomerSegment[]'
   */
  export type ListEnumCustomerSegmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerSegment[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'CreatedVia'
   */
  export type EnumCreatedViaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedVia'>
    


  /**
   * Reference to a field of type 'CreatedVia[]'
   */
  export type ListEnumCreatedViaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedVia[]'>
    


  /**
   * Reference to a field of type 'EntryStatus'
   */
  export type EnumEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryStatus'>
    


  /**
   * Reference to a field of type 'EntryStatus[]'
   */
  export type ListEnumEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryStatus[]'>
    


  /**
   * Reference to a field of type 'BookingMethod'
   */
  export type EnumBookingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingMethod'>
    


  /**
   * Reference to a field of type 'BookingMethod[]'
   */
  export type ListEnumBookingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingMethod[]'>
    


  /**
   * Reference to a field of type 'TicketType'
   */
  export type EnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType'>
    


  /**
   * Reference to a field of type 'TicketType[]'
   */
  export type ListEnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'Gate'
   */
  export type EnumGateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gate'>
    


  /**
   * Reference to a field of type 'Gate[]'
   */
  export type ListEnumGateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gate[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ArtistType'
   */
  export type EnumArtistTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistType'>
    


  /**
   * Reference to a field of type 'ArtistType[]'
   */
  export type ListEnumArtistTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistType[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'FeedItemType'
   */
  export type EnumFeedItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedItemType'>
    


  /**
   * Reference to a field of type 'FeedItemType[]'
   */
  export type ListEnumFeedItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedItemType[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    age?: IntNullableFilter<"User"> | number | null
    ageVerified?: BoolFilter<"User"> | boolean
    ageConsent?: BoolFilter<"User"> | boolean
    identityVerified?: BoolFilter<"User"> | boolean
    identityVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckInListRelationFilter
    eventsCreated?: EventListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    listEntries?: ListEntryListRelationFilter
    prProfile?: XOR<PRProfileNullableScalarRelationFilter, PRProfileWhereInput> | null
    securityReports?: SecurityNoteListRelationFilter
    ticketsIssued?: TicketListRelationFilter
    ticketsOwned?: TicketListRelationFilter
    clubsOwned?: ClubListRelationFilter
    organizationProfile?: XOR<OrganizationProfileNullableScalarRelationFilter, OrganizationProfileWhereInput> | null
    artistProfile?: XOR<ArtistProfileNullableScalarRelationFilter, ArtistProfileWhereInput> | null
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    feedItems?: FeedItemListRelationFilter
    feedLikes?: FeedLikeListRelationFilter
    feedComments?: FeedCommentListRelationFilter
    followedBy?: UserFollowListRelationFilter
    following?: UserFollowListRelationFilter
    identityVerifications?: IdentityVerificationListRelationFilter
    reviewedVerifications?: IdentityVerificationListRelationFilter
    phoneVerification?: XOR<UserPhoneNullableScalarRelationFilter, UserPhoneWhereInput> | null
    consents?: XOR<UserConsentNullableScalarRelationFilter, UserConsentWhereInput> | null
    onboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageVerified?: SortOrder
    ageConsent?: SortOrder
    identityVerified?: SortOrder
    identityVerifiedAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    checkins?: CheckInOrderByRelationAggregateInput
    eventsCreated?: EventOrderByRelationAggregateInput
    inviteLinks?: InviteLinkOrderByRelationAggregateInput
    listEntries?: ListEntryOrderByRelationAggregateInput
    prProfile?: PRProfileOrderByWithRelationInput
    securityReports?: SecurityNoteOrderByRelationAggregateInput
    ticketsIssued?: TicketOrderByRelationAggregateInput
    ticketsOwned?: TicketOrderByRelationAggregateInput
    clubsOwned?: ClubOrderByRelationAggregateInput
    organizationProfile?: OrganizationProfileOrderByWithRelationInput
    artistProfile?: ArtistProfileOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
    feedItems?: FeedItemOrderByRelationAggregateInput
    feedLikes?: FeedLikeOrderByRelationAggregateInput
    feedComments?: FeedCommentOrderByRelationAggregateInput
    followedBy?: UserFollowOrderByRelationAggregateInput
    following?: UserFollowOrderByRelationAggregateInput
    identityVerifications?: IdentityVerificationOrderByRelationAggregateInput
    reviewedVerifications?: IdentityVerificationOrderByRelationAggregateInput
    phoneVerification?: UserPhoneOrderByWithRelationInput
    consents?: UserConsentOrderByWithRelationInput
    onboardingProgress?: OnboardingProgressOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    age?: IntNullableFilter<"User"> | number | null
    ageVerified?: BoolFilter<"User"> | boolean
    ageConsent?: BoolFilter<"User"> | boolean
    identityVerified?: BoolFilter<"User"> | boolean
    identityVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    checkins?: CheckInListRelationFilter
    eventsCreated?: EventListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    listEntries?: ListEntryListRelationFilter
    prProfile?: XOR<PRProfileNullableScalarRelationFilter, PRProfileWhereInput> | null
    securityReports?: SecurityNoteListRelationFilter
    ticketsIssued?: TicketListRelationFilter
    ticketsOwned?: TicketListRelationFilter
    clubsOwned?: ClubListRelationFilter
    organizationProfile?: XOR<OrganizationProfileNullableScalarRelationFilter, OrganizationProfileWhereInput> | null
    artistProfile?: XOR<ArtistProfileNullableScalarRelationFilter, ArtistProfileWhereInput> | null
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    feedItems?: FeedItemListRelationFilter
    feedLikes?: FeedLikeListRelationFilter
    feedComments?: FeedCommentListRelationFilter
    followedBy?: UserFollowListRelationFilter
    following?: UserFollowListRelationFilter
    identityVerifications?: IdentityVerificationListRelationFilter
    reviewedVerifications?: IdentityVerificationListRelationFilter
    phoneVerification?: XOR<UserPhoneNullableScalarRelationFilter, UserPhoneWhereInput> | null
    consents?: XOR<UserConsentNullableScalarRelationFilter, UserConsentWhereInput> | null
    onboardingProgress?: XOR<OnboardingProgressNullableScalarRelationFilter, OnboardingProgressWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    ageVerified?: SortOrder
    ageConsent?: SortOrder
    identityVerified?: SortOrder
    identityVerifiedAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    ageVerified?: BoolWithAggregatesFilter<"User"> | boolean
    ageConsent?: BoolWithAggregatesFilter<"User"> | boolean
    identityVerified?: BoolWithAggregatesFilter<"User"> | boolean
    identityVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ClubWhereInput = {
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    id?: StringFilter<"Club"> | string
    name?: StringFilter<"Club"> | string
    type?: EnumClubTypeFilter<"Club"> | $Enums.ClubType
    description?: StringNullableFilter<"Club"> | string | null
    logo?: StringNullableFilter<"Club"> | string | null
    coverImage?: StringNullableFilter<"Club"> | string | null
    gallery?: StringNullableListFilter<"Club">
    website?: StringNullableFilter<"Club"> | string | null
    phone?: StringNullableFilter<"Club"> | string | null
    email?: StringNullableFilter<"Club"> | string | null
    instagram?: StringNullableFilter<"Club"> | string | null
    facebook?: StringNullableFilter<"Club"> | string | null
    openingHours?: StringNullableFilter<"Club"> | string | null
    priceRange?: StringNullableFilter<"Club"> | string | null
    amenities?: StringNullableListFilter<"Club">
    musicGenres?: StringNullableListFilter<"Club">
    ownerId?: StringFilter<"Club"> | string
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    venues?: VenueListRelationFilter
  }

  export type ClubOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    amenities?: SortOrder
    musicGenres?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    venues?: VenueOrderByRelationAggregateInput
  }

  export type ClubWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    name?: StringFilter<"Club"> | string
    type?: EnumClubTypeFilter<"Club"> | $Enums.ClubType
    description?: StringNullableFilter<"Club"> | string | null
    logo?: StringNullableFilter<"Club"> | string | null
    coverImage?: StringNullableFilter<"Club"> | string | null
    gallery?: StringNullableListFilter<"Club">
    website?: StringNullableFilter<"Club"> | string | null
    phone?: StringNullableFilter<"Club"> | string | null
    email?: StringNullableFilter<"Club"> | string | null
    instagram?: StringNullableFilter<"Club"> | string | null
    facebook?: StringNullableFilter<"Club"> | string | null
    openingHours?: StringNullableFilter<"Club"> | string | null
    priceRange?: StringNullableFilter<"Club"> | string | null
    amenities?: StringNullableListFilter<"Club">
    musicGenres?: StringNullableListFilter<"Club">
    ownerId?: StringFilter<"Club"> | string
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    venues?: VenueListRelationFilter
  }, "id">

  export type ClubOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    gallery?: SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    amenities?: SortOrder
    musicGenres?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClubCountOrderByAggregateInput
    _max?: ClubMaxOrderByAggregateInput
    _min?: ClubMinOrderByAggregateInput
  }

  export type ClubScalarWhereWithAggregatesInput = {
    AND?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    OR?: ClubScalarWhereWithAggregatesInput[]
    NOT?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Club"> | string
    name?: StringWithAggregatesFilter<"Club"> | string
    type?: EnumClubTypeWithAggregatesFilter<"Club"> | $Enums.ClubType
    description?: StringNullableWithAggregatesFilter<"Club"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Club"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Club"> | string | null
    gallery?: StringNullableListFilter<"Club">
    website?: StringNullableWithAggregatesFilter<"Club"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Club"> | string | null
    email?: StringNullableWithAggregatesFilter<"Club"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Club"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"Club"> | string | null
    openingHours?: StringNullableWithAggregatesFilter<"Club"> | string | null
    priceRange?: StringNullableWithAggregatesFilter<"Club"> | string | null
    amenities?: StringNullableListFilter<"Club">
    musicGenres?: StringNullableListFilter<"Club">
    ownerId?: StringWithAggregatesFilter<"Club"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Club"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Club"> | Date | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    slug?: StringNullableFilter<"Venue"> | string | null
    address?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    capacity?: IntNullableFilter<"Venue"> | number | null
    whatsappNumber?: StringNullableFilter<"Venue"> | string | null
    telegramHandle?: StringNullableFilter<"Venue"> | string | null
    clubId?: StringNullableFilter<"Venue"> | string | null
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
    events?: EventListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    capacity?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    club?: ClubOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    name?: StringFilter<"Venue"> | string
    address?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    capacity?: IntNullableFilter<"Venue"> | number | null
    whatsappNumber?: StringNullableFilter<"Venue"> | string | null
    telegramHandle?: StringNullableFilter<"Venue"> | string | null
    clubId?: StringNullableFilter<"Venue"> | string | null
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    club?: XOR<ClubNullableScalarRelationFilter, ClubWhereInput> | null
    events?: EventListRelationFilter
  }, "id" | "slug">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    address?: SortOrder
    city?: SortOrder
    capacity?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Venue"> | string
    name?: StringWithAggregatesFilter<"Venue"> | string
    slug?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    address?: StringWithAggregatesFilter<"Venue"> | string
    city?: StringWithAggregatesFilter<"Venue"> | string
    capacity?: IntNullableWithAggregatesFilter<"Venue"> | number | null
    whatsappNumber?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    telegramHandle?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    clubId?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    coverUrl?: StringNullableFilter<"Event"> | string | null
    dateStart?: DateTimeFilter<"Event"> | Date | string
    dateEnd?: DateTimeNullableFilter<"Event"> | Date | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    minAge?: IntNullableFilter<"Event"> | number | null
    dressCode?: StringNullableFilter<"Event"> | string | null
    venueId?: StringFilter<"Event"> | string
    createdByUserId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    assignments?: AssignmentListRelationFilter
    consumptions?: ConsumptionListRelationFilter
    feedbacks?: EventFeedbackListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    funnelTracking?: FunnelTrackingListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    lists?: ListListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    minAge?: SortOrderInput | SortOrder
    dressCode?: SortOrderInput | SortOrder
    venueId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    consumptions?: ConsumptionOrderByRelationAggregateInput
    feedbacks?: EventFeedbackOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    funnelTracking?: FunnelTrackingOrderByRelationAggregateInput
    inviteLinks?: InviteLinkOrderByRelationAggregateInput
    lists?: ListOrderByRelationAggregateInput
    securityNotes?: SecurityNoteOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    coverUrl?: StringNullableFilter<"Event"> | string | null
    dateStart?: DateTimeFilter<"Event"> | Date | string
    dateEnd?: DateTimeNullableFilter<"Event"> | Date | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    minAge?: IntNullableFilter<"Event"> | number | null
    dressCode?: StringNullableFilter<"Event"> | string | null
    venueId?: StringFilter<"Event"> | string
    createdByUserId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    assignments?: AssignmentListRelationFilter
    consumptions?: ConsumptionListRelationFilter
    feedbacks?: EventFeedbackListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    funnelTracking?: FunnelTrackingListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    lists?: ListListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    minAge?: SortOrderInput | SortOrder
    dressCode?: SortOrderInput | SortOrder
    venueId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Event"> | string | null
    dateStart?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    dateEnd?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    status?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus
    minAge?: IntNullableWithAggregatesFilter<"Event"> | number | null
    dressCode?: StringNullableWithAggregatesFilter<"Event"> | string | null
    venueId?: StringWithAggregatesFilter<"Event"> | string
    createdByUserId?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type PRProfileWhereInput = {
    AND?: PRProfileWhereInput | PRProfileWhereInput[]
    OR?: PRProfileWhereInput[]
    NOT?: PRProfileWhereInput | PRProfileWhereInput[]
    id?: StringFilter<"PRProfile"> | string
    userId?: StringFilter<"PRProfile"> | string
    displayName?: StringNullableFilter<"PRProfile"> | string | null
    referralCode?: StringFilter<"PRProfile"> | string
    phone?: StringNullableFilter<"PRProfile"> | string | null
    createdAt?: DateTimeFilter<"PRProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PRProfile"> | Date | string
    assignments?: AssignmentListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PRProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    inviteLinks?: InviteLinkOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type PRProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    referralCode?: string
    AND?: PRProfileWhereInput | PRProfileWhereInput[]
    OR?: PRProfileWhereInput[]
    NOT?: PRProfileWhereInput | PRProfileWhereInput[]
    displayName?: StringNullableFilter<"PRProfile"> | string | null
    phone?: StringNullableFilter<"PRProfile"> | string | null
    createdAt?: DateTimeFilter<"PRProfile"> | Date | string
    updatedAt?: DateTimeFilter<"PRProfile"> | Date | string
    assignments?: AssignmentListRelationFilter
    inviteLinks?: InviteLinkListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "referralCode">

  export type PRProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PRProfileCountOrderByAggregateInput
    _max?: PRProfileMaxOrderByAggregateInput
    _min?: PRProfileMinOrderByAggregateInput
  }

  export type PRProfileScalarWhereWithAggregatesInput = {
    AND?: PRProfileScalarWhereWithAggregatesInput | PRProfileScalarWhereWithAggregatesInput[]
    OR?: PRProfileScalarWhereWithAggregatesInput[]
    NOT?: PRProfileScalarWhereWithAggregatesInput | PRProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PRProfile"> | string
    userId?: StringWithAggregatesFilter<"PRProfile"> | string
    displayName?: StringNullableWithAggregatesFilter<"PRProfile"> | string | null
    referralCode?: StringWithAggregatesFilter<"PRProfile"> | string
    phone?: StringNullableWithAggregatesFilter<"PRProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PRProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PRProfile"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    eventId?: StringFilter<"Assignment"> | string
    prProfileId?: StringFilter<"Assignment"> | string
    quotaTotal?: IntNullableFilter<"Assignment"> | number | null
    quotaFemale?: IntNullableFilter<"Assignment"> | number | null
    quotaMale?: IntNullableFilter<"Assignment"> | number | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    prProfile?: XOR<PRProfileScalarRelationFilter, PRProfileWhereInput>
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    quotaTotal?: SortOrderInput | SortOrder
    quotaFemale?: SortOrderInput | SortOrder
    quotaMale?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    prProfile?: PRProfileOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_prProfileId?: AssignmentEventIdPrProfileIdCompoundUniqueInput
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    eventId?: StringFilter<"Assignment"> | string
    prProfileId?: StringFilter<"Assignment"> | string
    quotaTotal?: IntNullableFilter<"Assignment"> | number | null
    quotaFemale?: IntNullableFilter<"Assignment"> | number | null
    quotaMale?: IntNullableFilter<"Assignment"> | number | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    prProfile?: XOR<PRProfileScalarRelationFilter, PRProfileWhereInput>
  }, "id" | "eventId_prProfileId">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    quotaTotal?: SortOrderInput | SortOrder
    quotaFemale?: SortOrderInput | SortOrder
    quotaMale?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    eventId?: StringWithAggregatesFilter<"Assignment"> | string
    prProfileId?: StringWithAggregatesFilter<"Assignment"> | string
    quotaTotal?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    quotaFemale?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    quotaMale?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type ListWhereInput = {
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    id?: StringFilter<"List"> | string
    eventId?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    quotaTotal?: IntNullableFilter<"List"> | number | null
    quotaFemale?: IntNullableFilter<"List"> | number | null
    quotaMale?: IntNullableFilter<"List"> | number | null
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    entries?: ListEntryListRelationFilter
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type ListOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quotaTotal?: SortOrderInput | SortOrder
    quotaFemale?: SortOrderInput | SortOrder
    quotaMale?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entries?: ListEntryOrderByRelationAggregateInput
    event?: EventOrderByWithRelationInput
  }

  export type ListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListWhereInput | ListWhereInput[]
    OR?: ListWhereInput[]
    NOT?: ListWhereInput | ListWhereInput[]
    eventId?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    quotaTotal?: IntNullableFilter<"List"> | number | null
    quotaFemale?: IntNullableFilter<"List"> | number | null
    quotaMale?: IntNullableFilter<"List"> | number | null
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
    entries?: ListEntryListRelationFilter
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id">

  export type ListOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quotaTotal?: SortOrderInput | SortOrder
    quotaFemale?: SortOrderInput | SortOrder
    quotaMale?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ListCountOrderByAggregateInput
    _avg?: ListAvgOrderByAggregateInput
    _max?: ListMaxOrderByAggregateInput
    _min?: ListMinOrderByAggregateInput
    _sum?: ListSumOrderByAggregateInput
  }

  export type ListScalarWhereWithAggregatesInput = {
    AND?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    OR?: ListScalarWhereWithAggregatesInput[]
    NOT?: ListScalarWhereWithAggregatesInput | ListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"List"> | string
    eventId?: StringWithAggregatesFilter<"List"> | string
    name?: StringWithAggregatesFilter<"List"> | string
    type?: EnumListTypeWithAggregatesFilter<"List"> | $Enums.ListType
    quotaTotal?: IntNullableWithAggregatesFilter<"List"> | number | null
    quotaFemale?: IntNullableWithAggregatesFilter<"List"> | number | null
    quotaMale?: IntNullableWithAggregatesFilter<"List"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"List"> | Date | string
  }

  export type GuestWhereInput = {
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    id?: StringFilter<"Guest"> | string
    firstName?: StringFilter<"Guest"> | string
    lastName?: StringFilter<"Guest"> | string
    phone?: StringNullableFilter<"Guest"> | string | null
    email?: StringNullableFilter<"Guest"> | string | null
    nickname?: StringNullableFilter<"Guest"> | string | null
    birthDate?: DateTimeNullableFilter<"Guest"> | Date | string | null
    city?: StringNullableFilter<"Guest"> | string | null
    occupation?: StringNullableFilter<"Guest"> | string | null
    instagram?: StringNullableFilter<"Guest"> | string | null
    telegramChatId?: StringNullableFilter<"Guest"> | string | null
    whatsappPhone?: StringNullableFilter<"Guest"> | string | null
    totalEvents?: IntFilter<"Guest"> | number
    lastEventDate?: DateTimeNullableFilter<"Guest"> | Date | string | null
    customerSegment?: EnumCustomerSegmentFilter<"Guest"> | $Enums.CustomerSegment
    preferredDays?: StringNullableFilter<"Guest"> | string | null
    averageArrivalTime?: StringNullableFilter<"Guest"> | string | null
    prefersTable?: BoolFilter<"Guest"> | boolean
    averageGroupSize?: IntFilter<"Guest"> | number
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    preferences?: XOR<CustomerPreferencesNullableScalarRelationFilter, CustomerPreferencesWhereInput> | null
    feedbacks?: EventFeedbackListRelationFilter
    listEntries?: ListEntryListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type GuestOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    totalEvents?: SortOrder
    lastEventDate?: SortOrderInput | SortOrder
    customerSegment?: SortOrder
    preferredDays?: SortOrderInput | SortOrder
    averageArrivalTime?: SortOrderInput | SortOrder
    prefersTable?: SortOrder
    averageGroupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preferences?: CustomerPreferencesOrderByWithRelationInput
    feedbacks?: EventFeedbackOrderByRelationAggregateInput
    listEntries?: ListEntryOrderByRelationAggregateInput
    securityNotes?: SecurityNoteOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type GuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    firstName?: StringFilter<"Guest"> | string
    lastName?: StringFilter<"Guest"> | string
    phone?: StringNullableFilter<"Guest"> | string | null
    email?: StringNullableFilter<"Guest"> | string | null
    nickname?: StringNullableFilter<"Guest"> | string | null
    birthDate?: DateTimeNullableFilter<"Guest"> | Date | string | null
    city?: StringNullableFilter<"Guest"> | string | null
    occupation?: StringNullableFilter<"Guest"> | string | null
    instagram?: StringNullableFilter<"Guest"> | string | null
    telegramChatId?: StringNullableFilter<"Guest"> | string | null
    whatsappPhone?: StringNullableFilter<"Guest"> | string | null
    totalEvents?: IntFilter<"Guest"> | number
    lastEventDate?: DateTimeNullableFilter<"Guest"> | Date | string | null
    customerSegment?: EnumCustomerSegmentFilter<"Guest"> | $Enums.CustomerSegment
    preferredDays?: StringNullableFilter<"Guest"> | string | null
    averageArrivalTime?: StringNullableFilter<"Guest"> | string | null
    prefersTable?: BoolFilter<"Guest"> | boolean
    averageGroupSize?: IntFilter<"Guest"> | number
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    preferences?: XOR<CustomerPreferencesNullableScalarRelationFilter, CustomerPreferencesWhereInput> | null
    feedbacks?: EventFeedbackListRelationFilter
    listEntries?: ListEntryListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type GuestOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    telegramChatId?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    totalEvents?: SortOrder
    lastEventDate?: SortOrderInput | SortOrder
    customerSegment?: SortOrder
    preferredDays?: SortOrderInput | SortOrder
    averageArrivalTime?: SortOrderInput | SortOrder
    prefersTable?: SortOrder
    averageGroupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuestCountOrderByAggregateInput
    _avg?: GuestAvgOrderByAggregateInput
    _max?: GuestMaxOrderByAggregateInput
    _min?: GuestMinOrderByAggregateInput
    _sum?: GuestSumOrderByAggregateInput
  }

  export type GuestScalarWhereWithAggregatesInput = {
    AND?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    OR?: GuestScalarWhereWithAggregatesInput[]
    NOT?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guest"> | string
    firstName?: StringWithAggregatesFilter<"Guest"> | string
    lastName?: StringWithAggregatesFilter<"Guest"> | string
    phone?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    email?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    nickname?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Guest"> | Date | string | null
    city?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    telegramChatId?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    whatsappPhone?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    totalEvents?: IntWithAggregatesFilter<"Guest"> | number
    lastEventDate?: DateTimeNullableWithAggregatesFilter<"Guest"> | Date | string | null
    customerSegment?: EnumCustomerSegmentWithAggregatesFilter<"Guest"> | $Enums.CustomerSegment
    preferredDays?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    averageArrivalTime?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    prefersTable?: BoolWithAggregatesFilter<"Guest"> | boolean
    averageGroupSize?: IntWithAggregatesFilter<"Guest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
  }

  export type ListEntryWhereInput = {
    AND?: ListEntryWhereInput | ListEntryWhereInput[]
    OR?: ListEntryWhereInput[]
    NOT?: ListEntryWhereInput | ListEntryWhereInput[]
    id?: StringFilter<"ListEntry"> | string
    listId?: StringFilter<"ListEntry"> | string
    guestId?: StringNullableFilter<"ListEntry"> | string | null
    addedByUserId?: StringFilter<"ListEntry"> | string
    firstName?: StringFilter<"ListEntry"> | string
    lastName?: StringFilter<"ListEntry"> | string
    phone?: StringNullableFilter<"ListEntry"> | string | null
    email?: StringNullableFilter<"ListEntry"> | string | null
    gender?: EnumGenderFilter<"ListEntry"> | $Enums.Gender
    note?: StringNullableFilter<"ListEntry"> | string | null
    createdVia?: EnumCreatedViaFilter<"ListEntry"> | $Enums.CreatedVia
    status?: EnumEntryStatusFilter<"ListEntry"> | $Enums.EntryStatus
    plusOne?: BoolFilter<"ListEntry"> | boolean
    bookingMethod?: EnumBookingMethodFilter<"ListEntry"> | $Enums.BookingMethod
    referralSource?: StringNullableFilter<"ListEntry"> | string | null
    groupSize?: IntFilter<"ListEntry"> | number
    createdAt?: DateTimeFilter<"ListEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ListEntry"> | Date | string
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type ListEntryOrderByWithRelationInput = {
    id?: SortOrder
    listId?: SortOrder
    guestId?: SortOrderInput | SortOrder
    addedByUserId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrder
    note?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    status?: SortOrder
    plusOne?: SortOrder
    bookingMethod?: SortOrder
    referralSource?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedBy?: UserOrderByWithRelationInput
    guest?: GuestOrderByWithRelationInput
    list?: ListOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type ListEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListEntryWhereInput | ListEntryWhereInput[]
    OR?: ListEntryWhereInput[]
    NOT?: ListEntryWhereInput | ListEntryWhereInput[]
    listId?: StringFilter<"ListEntry"> | string
    guestId?: StringNullableFilter<"ListEntry"> | string | null
    addedByUserId?: StringFilter<"ListEntry"> | string
    firstName?: StringFilter<"ListEntry"> | string
    lastName?: StringFilter<"ListEntry"> | string
    phone?: StringNullableFilter<"ListEntry"> | string | null
    email?: StringNullableFilter<"ListEntry"> | string | null
    gender?: EnumGenderFilter<"ListEntry"> | $Enums.Gender
    note?: StringNullableFilter<"ListEntry"> | string | null
    createdVia?: EnumCreatedViaFilter<"ListEntry"> | $Enums.CreatedVia
    status?: EnumEntryStatusFilter<"ListEntry"> | $Enums.EntryStatus
    plusOne?: BoolFilter<"ListEntry"> | boolean
    bookingMethod?: EnumBookingMethodFilter<"ListEntry"> | $Enums.BookingMethod
    referralSource?: StringNullableFilter<"ListEntry"> | string | null
    groupSize?: IntFilter<"ListEntry"> | number
    createdAt?: DateTimeFilter<"ListEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ListEntry"> | Date | string
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    list?: XOR<ListScalarRelationFilter, ListWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type ListEntryOrderByWithAggregationInput = {
    id?: SortOrder
    listId?: SortOrder
    guestId?: SortOrderInput | SortOrder
    addedByUserId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrder
    note?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    status?: SortOrder
    plusOne?: SortOrder
    bookingMethod?: SortOrder
    referralSource?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ListEntryCountOrderByAggregateInput
    _avg?: ListEntryAvgOrderByAggregateInput
    _max?: ListEntryMaxOrderByAggregateInput
    _min?: ListEntryMinOrderByAggregateInput
    _sum?: ListEntrySumOrderByAggregateInput
  }

  export type ListEntryScalarWhereWithAggregatesInput = {
    AND?: ListEntryScalarWhereWithAggregatesInput | ListEntryScalarWhereWithAggregatesInput[]
    OR?: ListEntryScalarWhereWithAggregatesInput[]
    NOT?: ListEntryScalarWhereWithAggregatesInput | ListEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListEntry"> | string
    listId?: StringWithAggregatesFilter<"ListEntry"> | string
    guestId?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    addedByUserId?: StringWithAggregatesFilter<"ListEntry"> | string
    firstName?: StringWithAggregatesFilter<"ListEntry"> | string
    lastName?: StringWithAggregatesFilter<"ListEntry"> | string
    phone?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    email?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"ListEntry"> | $Enums.Gender
    note?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    createdVia?: EnumCreatedViaWithAggregatesFilter<"ListEntry"> | $Enums.CreatedVia
    status?: EnumEntryStatusWithAggregatesFilter<"ListEntry"> | $Enums.EntryStatus
    plusOne?: BoolWithAggregatesFilter<"ListEntry"> | boolean
    bookingMethod?: EnumBookingMethodWithAggregatesFilter<"ListEntry"> | $Enums.BookingMethod
    referralSource?: StringNullableWithAggregatesFilter<"ListEntry"> | string | null
    groupSize?: IntWithAggregatesFilter<"ListEntry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ListEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ListEntry"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    userId?: StringNullableFilter<"Ticket"> | string | null
    guestId?: StringNullableFilter<"Ticket"> | string | null
    listEntryId?: StringNullableFilter<"Ticket"> | string | null
    issuedByUserId?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    price?: FloatNullableFilter<"Ticket"> | number | null
    currency?: StringNullableFilter<"Ticket"> | string | null
    code?: StringFilter<"Ticket"> | string
    qrData?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    issuedAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    checkins?: CheckInListRelationFilter
    consumptions?: ConsumptionListRelationFilter
    feedbacks?: EventFeedbackListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    issuedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    listEntry?: XOR<ListEntryNullableScalarRelationFilter, ListEntryWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    listEntryId?: SortOrderInput | SortOrder
    issuedByUserId?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    code?: SortOrder
    qrData?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    updatedAt?: SortOrder
    checkins?: CheckInOrderByRelationAggregateInput
    consumptions?: ConsumptionOrderByRelationAggregateInput
    feedbacks?: EventFeedbackOrderByRelationAggregateInput
    securityNotes?: SecurityNoteOrderByRelationAggregateInput
    event?: EventOrderByWithRelationInput
    guest?: GuestOrderByWithRelationInput
    issuedBy?: UserOrderByWithRelationInput
    listEntry?: ListEntryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    eventId?: StringFilter<"Ticket"> | string
    userId?: StringNullableFilter<"Ticket"> | string | null
    guestId?: StringNullableFilter<"Ticket"> | string | null
    listEntryId?: StringNullableFilter<"Ticket"> | string | null
    issuedByUserId?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    price?: FloatNullableFilter<"Ticket"> | number | null
    currency?: StringNullableFilter<"Ticket"> | string | null
    qrData?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    issuedAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    checkins?: CheckInListRelationFilter
    consumptions?: ConsumptionListRelationFilter
    feedbacks?: EventFeedbackListRelationFilter
    securityNotes?: SecurityNoteListRelationFilter
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    issuedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    listEntry?: XOR<ListEntryNullableScalarRelationFilter, ListEntryWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "code">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    listEntryId?: SortOrderInput | SortOrder
    issuedByUserId?: SortOrderInput | SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    code?: SortOrder
    qrData?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    eventId?: StringWithAggregatesFilter<"Ticket"> | string
    userId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    guestId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    listEntryId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    issuedByUserId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    type?: EnumTicketTypeWithAggregatesFilter<"Ticket"> | $Enums.TicketType
    price?: FloatNullableWithAggregatesFilter<"Ticket"> | number | null
    currency?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    code?: StringWithAggregatesFilter<"Ticket"> | string
    qrData?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    issuedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type CheckInWhereInput = {
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    ticketId?: StringFilter<"CheckIn"> | string
    scannedByUserId?: StringFilter<"CheckIn"> | string
    scannedAt?: DateTimeFilter<"CheckIn"> | Date | string
    gate?: EnumGateFilter<"CheckIn"> | $Enums.Gate
    ok?: BoolFilter<"CheckIn"> | boolean
    notes?: StringNullableFilter<"CheckIn"> | string | null
    arrivalTime?: StringNullableFilter<"CheckIn"> | string | null
    groupSize?: IntFilter<"CheckIn"> | number
    scannedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type CheckInOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    scannedByUserId?: SortOrder
    scannedAt?: SortOrder
    gate?: SortOrder
    ok?: SortOrder
    notes?: SortOrderInput | SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    scannedBy?: UserOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type CheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    ticketId?: StringFilter<"CheckIn"> | string
    scannedByUserId?: StringFilter<"CheckIn"> | string
    scannedAt?: DateTimeFilter<"CheckIn"> | Date | string
    gate?: EnumGateFilter<"CheckIn"> | $Enums.Gate
    ok?: BoolFilter<"CheckIn"> | boolean
    notes?: StringNullableFilter<"CheckIn"> | string | null
    arrivalTime?: StringNullableFilter<"CheckIn"> | string | null
    groupSize?: IntFilter<"CheckIn"> | number
    scannedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type CheckInOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    scannedByUserId?: SortOrder
    scannedAt?: SortOrder
    gate?: SortOrder
    ok?: SortOrder
    notes?: SortOrderInput | SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    _count?: CheckInCountOrderByAggregateInput
    _avg?: CheckInAvgOrderByAggregateInput
    _max?: CheckInMaxOrderByAggregateInput
    _min?: CheckInMinOrderByAggregateInput
    _sum?: CheckInSumOrderByAggregateInput
  }

  export type CheckInScalarWhereWithAggregatesInput = {
    AND?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    OR?: CheckInScalarWhereWithAggregatesInput[]
    NOT?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckIn"> | string
    ticketId?: StringWithAggregatesFilter<"CheckIn"> | string
    scannedByUserId?: StringWithAggregatesFilter<"CheckIn"> | string
    scannedAt?: DateTimeWithAggregatesFilter<"CheckIn"> | Date | string
    gate?: EnumGateWithAggregatesFilter<"CheckIn"> | $Enums.Gate
    ok?: BoolWithAggregatesFilter<"CheckIn"> | boolean
    notes?: StringNullableWithAggregatesFilter<"CheckIn"> | string | null
    arrivalTime?: StringNullableWithAggregatesFilter<"CheckIn"> | string | null
    groupSize?: IntWithAggregatesFilter<"CheckIn"> | number
  }

  export type InviteLinkWhereInput = {
    AND?: InviteLinkWhereInput | InviteLinkWhereInput[]
    OR?: InviteLinkWhereInput[]
    NOT?: InviteLinkWhereInput | InviteLinkWhereInput[]
    id?: StringFilter<"InviteLink"> | string
    createdByUserId?: StringFilter<"InviteLink"> | string
    eventId?: StringFilter<"InviteLink"> | string
    prProfileId?: StringNullableFilter<"InviteLink"> | string | null
    slug?: StringFilter<"InviteLink"> | string
    maxUses?: IntNullableFilter<"InviteLink"> | number | null
    uses?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    utmSource?: StringNullableFilter<"InviteLink"> | string | null
    utmMedium?: StringNullableFilter<"InviteLink"> | string | null
    utmCampaign?: StringNullableFilter<"InviteLink"> | string | null
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    prProfile?: XOR<PRProfileNullableScalarRelationFilter, PRProfileWhereInput> | null
  }

  export type InviteLinkOrderByWithRelationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrderInput | SortOrder
    slug?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    prProfile?: PRProfileOrderByWithRelationInput
  }

  export type InviteLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: InviteLinkWhereInput | InviteLinkWhereInput[]
    OR?: InviteLinkWhereInput[]
    NOT?: InviteLinkWhereInput | InviteLinkWhereInput[]
    createdByUserId?: StringFilter<"InviteLink"> | string
    eventId?: StringFilter<"InviteLink"> | string
    prProfileId?: StringNullableFilter<"InviteLink"> | string | null
    maxUses?: IntNullableFilter<"InviteLink"> | number | null
    uses?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    utmSource?: StringNullableFilter<"InviteLink"> | string | null
    utmMedium?: StringNullableFilter<"InviteLink"> | string | null
    utmCampaign?: StringNullableFilter<"InviteLink"> | string | null
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    prProfile?: XOR<PRProfileNullableScalarRelationFilter, PRProfileWhereInput> | null
  }, "id" | "slug">

  export type InviteLinkOrderByWithAggregationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrderInput | SortOrder
    slug?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InviteLinkCountOrderByAggregateInput
    _avg?: InviteLinkAvgOrderByAggregateInput
    _max?: InviteLinkMaxOrderByAggregateInput
    _min?: InviteLinkMinOrderByAggregateInput
    _sum?: InviteLinkSumOrderByAggregateInput
  }

  export type InviteLinkScalarWhereWithAggregatesInput = {
    AND?: InviteLinkScalarWhereWithAggregatesInput | InviteLinkScalarWhereWithAggregatesInput[]
    OR?: InviteLinkScalarWhereWithAggregatesInput[]
    NOT?: InviteLinkScalarWhereWithAggregatesInput | InviteLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InviteLink"> | string
    createdByUserId?: StringWithAggregatesFilter<"InviteLink"> | string
    eventId?: StringWithAggregatesFilter<"InviteLink"> | string
    prProfileId?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    slug?: StringWithAggregatesFilter<"InviteLink"> | string
    maxUses?: IntNullableWithAggregatesFilter<"InviteLink"> | number | null
    uses?: IntWithAggregatesFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"InviteLink"> | Date | string | null
    utmSource?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    utmMedium?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    utmCampaign?: StringNullableWithAggregatesFilter<"InviteLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InviteLink"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ConsumptionWhereInput = {
    AND?: ConsumptionWhereInput | ConsumptionWhereInput[]
    OR?: ConsumptionWhereInput[]
    NOT?: ConsumptionWhereInput | ConsumptionWhereInput[]
    id?: StringFilter<"Consumption"> | string
    ticketId?: StringFilter<"Consumption"> | string
    eventId?: StringFilter<"Consumption"> | string
    amount?: FloatFilter<"Consumption"> | number
    category?: StringFilter<"Consumption"> | string
    items?: JsonNullableFilter<"Consumption">
    createdAt?: DateTimeFilter<"Consumption"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type ConsumptionOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    items?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type ConsumptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsumptionWhereInput | ConsumptionWhereInput[]
    OR?: ConsumptionWhereInput[]
    NOT?: ConsumptionWhereInput | ConsumptionWhereInput[]
    ticketId?: StringFilter<"Consumption"> | string
    eventId?: StringFilter<"Consumption"> | string
    amount?: FloatFilter<"Consumption"> | number
    category?: StringFilter<"Consumption"> | string
    items?: JsonNullableFilter<"Consumption">
    createdAt?: DateTimeFilter<"Consumption"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type ConsumptionOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    items?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConsumptionCountOrderByAggregateInput
    _avg?: ConsumptionAvgOrderByAggregateInput
    _max?: ConsumptionMaxOrderByAggregateInput
    _min?: ConsumptionMinOrderByAggregateInput
    _sum?: ConsumptionSumOrderByAggregateInput
  }

  export type ConsumptionScalarWhereWithAggregatesInput = {
    AND?: ConsumptionScalarWhereWithAggregatesInput | ConsumptionScalarWhereWithAggregatesInput[]
    OR?: ConsumptionScalarWhereWithAggregatesInput[]
    NOT?: ConsumptionScalarWhereWithAggregatesInput | ConsumptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consumption"> | string
    ticketId?: StringWithAggregatesFilter<"Consumption"> | string
    eventId?: StringWithAggregatesFilter<"Consumption"> | string
    amount?: FloatWithAggregatesFilter<"Consumption"> | number
    category?: StringWithAggregatesFilter<"Consumption"> | string
    items?: JsonNullableWithAggregatesFilter<"Consumption">
    createdAt?: DateTimeWithAggregatesFilter<"Consumption"> | Date | string
  }

  export type FunnelTrackingWhereInput = {
    AND?: FunnelTrackingWhereInput | FunnelTrackingWhereInput[]
    OR?: FunnelTrackingWhereInput[]
    NOT?: FunnelTrackingWhereInput | FunnelTrackingWhereInput[]
    id?: StringFilter<"FunnelTracking"> | string
    sessionId?: StringFilter<"FunnelTracking"> | string
    guestEmail?: StringNullableFilter<"FunnelTracking"> | string | null
    guestPhone?: StringNullableFilter<"FunnelTracking"> | string | null
    eventId?: StringFilter<"FunnelTracking"> | string
    step?: StringFilter<"FunnelTracking"> | string
    metadata?: JsonNullableFilter<"FunnelTracking">
    userAgent?: StringNullableFilter<"FunnelTracking"> | string | null
    ipAddress?: StringNullableFilter<"FunnelTracking"> | string | null
    referer?: StringNullableFilter<"FunnelTracking"> | string | null
    timestamp?: DateTimeFilter<"FunnelTracking"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type FunnelTrackingOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    eventId?: SortOrder
    step?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type FunnelTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunnelTrackingWhereInput | FunnelTrackingWhereInput[]
    OR?: FunnelTrackingWhereInput[]
    NOT?: FunnelTrackingWhereInput | FunnelTrackingWhereInput[]
    sessionId?: StringFilter<"FunnelTracking"> | string
    guestEmail?: StringNullableFilter<"FunnelTracking"> | string | null
    guestPhone?: StringNullableFilter<"FunnelTracking"> | string | null
    eventId?: StringFilter<"FunnelTracking"> | string
    step?: StringFilter<"FunnelTracking"> | string
    metadata?: JsonNullableFilter<"FunnelTracking">
    userAgent?: StringNullableFilter<"FunnelTracking"> | string | null
    ipAddress?: StringNullableFilter<"FunnelTracking"> | string | null
    referer?: StringNullableFilter<"FunnelTracking"> | string | null
    timestamp?: DateTimeFilter<"FunnelTracking"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id">

  export type FunnelTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    eventId?: SortOrder
    step?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: FunnelTrackingCountOrderByAggregateInput
    _max?: FunnelTrackingMaxOrderByAggregateInput
    _min?: FunnelTrackingMinOrderByAggregateInput
  }

  export type FunnelTrackingScalarWhereWithAggregatesInput = {
    AND?: FunnelTrackingScalarWhereWithAggregatesInput | FunnelTrackingScalarWhereWithAggregatesInput[]
    OR?: FunnelTrackingScalarWhereWithAggregatesInput[]
    NOT?: FunnelTrackingScalarWhereWithAggregatesInput | FunnelTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FunnelTracking"> | string
    sessionId?: StringWithAggregatesFilter<"FunnelTracking"> | string
    guestEmail?: StringNullableWithAggregatesFilter<"FunnelTracking"> | string | null
    guestPhone?: StringNullableWithAggregatesFilter<"FunnelTracking"> | string | null
    eventId?: StringWithAggregatesFilter<"FunnelTracking"> | string
    step?: StringWithAggregatesFilter<"FunnelTracking"> | string
    metadata?: JsonNullableWithAggregatesFilter<"FunnelTracking">
    userAgent?: StringNullableWithAggregatesFilter<"FunnelTracking"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"FunnelTracking"> | string | null
    referer?: StringNullableWithAggregatesFilter<"FunnelTracking"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"FunnelTracking"> | Date | string
  }

  export type EventFeedbackWhereInput = {
    AND?: EventFeedbackWhereInput | EventFeedbackWhereInput[]
    OR?: EventFeedbackWhereInput[]
    NOT?: EventFeedbackWhereInput | EventFeedbackWhereInput[]
    id?: StringFilter<"EventFeedback"> | string
    eventId?: StringFilter<"EventFeedback"> | string
    ticketId?: StringNullableFilter<"EventFeedback"> | string | null
    guestId?: StringNullableFilter<"EventFeedback"> | string | null
    overallRating?: IntFilter<"EventFeedback"> | number
    musicRating?: IntNullableFilter<"EventFeedback"> | number | null
    serviceRating?: IntNullableFilter<"EventFeedback"> | number | null
    venueRating?: IntNullableFilter<"EventFeedback"> | number | null
    comment?: StringNullableFilter<"EventFeedback"> | string | null
    wouldReturn?: BoolNullableFilter<"EventFeedback"> | boolean | null
    interests?: JsonNullableFilter<"EventFeedback">
    createdAt?: DateTimeFilter<"EventFeedback"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }

  export type EventFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    overallRating?: SortOrder
    musicRating?: SortOrderInput | SortOrder
    serviceRating?: SortOrderInput | SortOrder
    venueRating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    wouldReturn?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    guest?: GuestOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type EventFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventFeedbackWhereInput | EventFeedbackWhereInput[]
    OR?: EventFeedbackWhereInput[]
    NOT?: EventFeedbackWhereInput | EventFeedbackWhereInput[]
    eventId?: StringFilter<"EventFeedback"> | string
    ticketId?: StringNullableFilter<"EventFeedback"> | string | null
    guestId?: StringNullableFilter<"EventFeedback"> | string | null
    overallRating?: IntFilter<"EventFeedback"> | number
    musicRating?: IntNullableFilter<"EventFeedback"> | number | null
    serviceRating?: IntNullableFilter<"EventFeedback"> | number | null
    venueRating?: IntNullableFilter<"EventFeedback"> | number | null
    comment?: StringNullableFilter<"EventFeedback"> | string | null
    wouldReturn?: BoolNullableFilter<"EventFeedback"> | boolean | null
    interests?: JsonNullableFilter<"EventFeedback">
    createdAt?: DateTimeFilter<"EventFeedback"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }, "id">

  export type EventFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    overallRating?: SortOrder
    musicRating?: SortOrderInput | SortOrder
    serviceRating?: SortOrderInput | SortOrder
    venueRating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    wouldReturn?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventFeedbackCountOrderByAggregateInput
    _avg?: EventFeedbackAvgOrderByAggregateInput
    _max?: EventFeedbackMaxOrderByAggregateInput
    _min?: EventFeedbackMinOrderByAggregateInput
    _sum?: EventFeedbackSumOrderByAggregateInput
  }

  export type EventFeedbackScalarWhereWithAggregatesInput = {
    AND?: EventFeedbackScalarWhereWithAggregatesInput | EventFeedbackScalarWhereWithAggregatesInput[]
    OR?: EventFeedbackScalarWhereWithAggregatesInput[]
    NOT?: EventFeedbackScalarWhereWithAggregatesInput | EventFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventFeedback"> | string
    eventId?: StringWithAggregatesFilter<"EventFeedback"> | string
    ticketId?: StringNullableWithAggregatesFilter<"EventFeedback"> | string | null
    guestId?: StringNullableWithAggregatesFilter<"EventFeedback"> | string | null
    overallRating?: IntWithAggregatesFilter<"EventFeedback"> | number
    musicRating?: IntNullableWithAggregatesFilter<"EventFeedback"> | number | null
    serviceRating?: IntNullableWithAggregatesFilter<"EventFeedback"> | number | null
    venueRating?: IntNullableWithAggregatesFilter<"EventFeedback"> | number | null
    comment?: StringNullableWithAggregatesFilter<"EventFeedback"> | string | null
    wouldReturn?: BoolNullableWithAggregatesFilter<"EventFeedback"> | boolean | null
    interests?: JsonNullableWithAggregatesFilter<"EventFeedback">
    createdAt?: DateTimeWithAggregatesFilter<"EventFeedback"> | Date | string
  }

  export type SecurityNoteWhereInput = {
    AND?: SecurityNoteWhereInput | SecurityNoteWhereInput[]
    OR?: SecurityNoteWhereInput[]
    NOT?: SecurityNoteWhereInput | SecurityNoteWhereInput[]
    id?: StringFilter<"SecurityNote"> | string
    guestId?: StringNullableFilter<"SecurityNote"> | string | null
    eventId?: StringNullableFilter<"SecurityNote"> | string | null
    ticketId?: StringNullableFilter<"SecurityNote"> | string | null
    severity?: StringFilter<"SecurityNote"> | string
    type?: StringFilter<"SecurityNote"> | string
    description?: StringFilter<"SecurityNote"> | string
    reportedByUserId?: StringFilter<"SecurityNote"> | string
    actionTaken?: StringNullableFilter<"SecurityNote"> | string | null
    createdAt?: DateTimeFilter<"SecurityNote"> | Date | string
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }

  export type SecurityNoteOrderByWithRelationInput = {
    id?: SortOrder
    guestId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    severity?: SortOrder
    type?: SortOrder
    description?: SortOrder
    reportedByUserId?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    guest?: GuestOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type SecurityNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityNoteWhereInput | SecurityNoteWhereInput[]
    OR?: SecurityNoteWhereInput[]
    NOT?: SecurityNoteWhereInput | SecurityNoteWhereInput[]
    guestId?: StringNullableFilter<"SecurityNote"> | string | null
    eventId?: StringNullableFilter<"SecurityNote"> | string | null
    ticketId?: StringNullableFilter<"SecurityNote"> | string | null
    severity?: StringFilter<"SecurityNote"> | string
    type?: StringFilter<"SecurityNote"> | string
    description?: StringFilter<"SecurityNote"> | string
    reportedByUserId?: StringFilter<"SecurityNote"> | string
    actionTaken?: StringNullableFilter<"SecurityNote"> | string | null
    createdAt?: DateTimeFilter<"SecurityNote"> | Date | string
    event?: XOR<EventNullableScalarRelationFilter, EventWhereInput> | null
    guest?: XOR<GuestNullableScalarRelationFilter, GuestWhereInput> | null
    reportedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }, "id">

  export type SecurityNoteOrderByWithAggregationInput = {
    id?: SortOrder
    guestId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    severity?: SortOrder
    type?: SortOrder
    description?: SortOrder
    reportedByUserId?: SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityNoteCountOrderByAggregateInput
    _max?: SecurityNoteMaxOrderByAggregateInput
    _min?: SecurityNoteMinOrderByAggregateInput
  }

  export type SecurityNoteScalarWhereWithAggregatesInput = {
    AND?: SecurityNoteScalarWhereWithAggregatesInput | SecurityNoteScalarWhereWithAggregatesInput[]
    OR?: SecurityNoteScalarWhereWithAggregatesInput[]
    NOT?: SecurityNoteScalarWhereWithAggregatesInput | SecurityNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityNote"> | string
    guestId?: StringNullableWithAggregatesFilter<"SecurityNote"> | string | null
    eventId?: StringNullableWithAggregatesFilter<"SecurityNote"> | string | null
    ticketId?: StringNullableWithAggregatesFilter<"SecurityNote"> | string | null
    severity?: StringWithAggregatesFilter<"SecurityNote"> | string
    type?: StringWithAggregatesFilter<"SecurityNote"> | string
    description?: StringWithAggregatesFilter<"SecurityNote"> | string
    reportedByUserId?: StringWithAggregatesFilter<"SecurityNote"> | string
    actionTaken?: StringNullableWithAggregatesFilter<"SecurityNote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityNote"> | Date | string
  }

  export type CustomerPreferencesWhereInput = {
    AND?: CustomerPreferencesWhereInput | CustomerPreferencesWhereInput[]
    OR?: CustomerPreferencesWhereInput[]
    NOT?: CustomerPreferencesWhereInput | CustomerPreferencesWhereInput[]
    id?: StringFilter<"CustomerPreferences"> | string
    guestId?: StringFilter<"CustomerPreferences"> | string
    musicGenres?: JsonNullableFilter<"CustomerPreferences">
    dressStyle?: StringNullableFilter<"CustomerPreferences"> | string | null
    drinkPreferences?: JsonNullableFilter<"CustomerPreferences">
    avgSpending?: FloatNullableFilter<"CustomerPreferences"> | number | null
    responseToPromo?: StringNullableFilter<"CustomerPreferences"> | string | null
    socialEngagement?: StringNullableFilter<"CustomerPreferences"> | string | null
    conversionScore?: FloatNullableFilter<"CustomerPreferences"> | number | null
    lifetimeValue?: FloatNullableFilter<"CustomerPreferences"> | number | null
    consents?: JsonNullableFilter<"CustomerPreferences">
    updatedAt?: DateTimeFilter<"CustomerPreferences"> | Date | string
    guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
  }

  export type CustomerPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    guestId?: SortOrder
    musicGenres?: SortOrderInput | SortOrder
    dressStyle?: SortOrderInput | SortOrder
    drinkPreferences?: SortOrderInput | SortOrder
    avgSpending?: SortOrderInput | SortOrder
    responseToPromo?: SortOrderInput | SortOrder
    socialEngagement?: SortOrderInput | SortOrder
    conversionScore?: SortOrderInput | SortOrder
    lifetimeValue?: SortOrderInput | SortOrder
    consents?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    guest?: GuestOrderByWithRelationInput
  }

  export type CustomerPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guestId?: string
    AND?: CustomerPreferencesWhereInput | CustomerPreferencesWhereInput[]
    OR?: CustomerPreferencesWhereInput[]
    NOT?: CustomerPreferencesWhereInput | CustomerPreferencesWhereInput[]
    musicGenres?: JsonNullableFilter<"CustomerPreferences">
    dressStyle?: StringNullableFilter<"CustomerPreferences"> | string | null
    drinkPreferences?: JsonNullableFilter<"CustomerPreferences">
    avgSpending?: FloatNullableFilter<"CustomerPreferences"> | number | null
    responseToPromo?: StringNullableFilter<"CustomerPreferences"> | string | null
    socialEngagement?: StringNullableFilter<"CustomerPreferences"> | string | null
    conversionScore?: FloatNullableFilter<"CustomerPreferences"> | number | null
    lifetimeValue?: FloatNullableFilter<"CustomerPreferences"> | number | null
    consents?: JsonNullableFilter<"CustomerPreferences">
    updatedAt?: DateTimeFilter<"CustomerPreferences"> | Date | string
    guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
  }, "id" | "guestId">

  export type CustomerPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    guestId?: SortOrder
    musicGenres?: SortOrderInput | SortOrder
    dressStyle?: SortOrderInput | SortOrder
    drinkPreferences?: SortOrderInput | SortOrder
    avgSpending?: SortOrderInput | SortOrder
    responseToPromo?: SortOrderInput | SortOrder
    socialEngagement?: SortOrderInput | SortOrder
    conversionScore?: SortOrderInput | SortOrder
    lifetimeValue?: SortOrderInput | SortOrder
    consents?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPreferencesCountOrderByAggregateInput
    _avg?: CustomerPreferencesAvgOrderByAggregateInput
    _max?: CustomerPreferencesMaxOrderByAggregateInput
    _min?: CustomerPreferencesMinOrderByAggregateInput
    _sum?: CustomerPreferencesSumOrderByAggregateInput
  }

  export type CustomerPreferencesScalarWhereWithAggregatesInput = {
    AND?: CustomerPreferencesScalarWhereWithAggregatesInput | CustomerPreferencesScalarWhereWithAggregatesInput[]
    OR?: CustomerPreferencesScalarWhereWithAggregatesInput[]
    NOT?: CustomerPreferencesScalarWhereWithAggregatesInput | CustomerPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerPreferences"> | string
    guestId?: StringWithAggregatesFilter<"CustomerPreferences"> | string
    musicGenres?: JsonNullableWithAggregatesFilter<"CustomerPreferences">
    dressStyle?: StringNullableWithAggregatesFilter<"CustomerPreferences"> | string | null
    drinkPreferences?: JsonNullableWithAggregatesFilter<"CustomerPreferences">
    avgSpending?: FloatNullableWithAggregatesFilter<"CustomerPreferences"> | number | null
    responseToPromo?: StringNullableWithAggregatesFilter<"CustomerPreferences"> | string | null
    socialEngagement?: StringNullableWithAggregatesFilter<"CustomerPreferences"> | string | null
    conversionScore?: FloatNullableWithAggregatesFilter<"CustomerPreferences"> | number | null
    lifetimeValue?: FloatNullableWithAggregatesFilter<"CustomerPreferences"> | number | null
    consents?: JsonNullableWithAggregatesFilter<"CustomerPreferences">
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPreferences"> | Date | string
  }

  export type OrganizationProfileWhereInput = {
    AND?: OrganizationProfileWhereInput | OrganizationProfileWhereInput[]
    OR?: OrganizationProfileWhereInput[]
    NOT?: OrganizationProfileWhereInput | OrganizationProfileWhereInput[]
    id?: StringFilter<"OrganizationProfile"> | string
    userId?: StringFilter<"OrganizationProfile"> | string
    slug?: StringNullableFilter<"OrganizationProfile"> | string | null
    organizationName?: StringFilter<"OrganizationProfile"> | string
    bio?: StringNullableFilter<"OrganizationProfile"> | string | null
    website?: StringNullableFilter<"OrganizationProfile"> | string | null
    instagram?: StringNullableFilter<"OrganizationProfile"> | string | null
    facebook?: StringNullableFilter<"OrganizationProfile"> | string | null
    twitter?: StringNullableFilter<"OrganizationProfile"> | string | null
    whatsappNumber?: StringNullableFilter<"OrganizationProfile"> | string | null
    telegramHandle?: StringNullableFilter<"OrganizationProfile"> | string | null
    logo?: StringNullableFilter<"OrganizationProfile"> | string | null
    coverImage?: StringNullableFilter<"OrganizationProfile"> | string | null
    verified?: BoolFilter<"OrganizationProfile"> | boolean
    totalEvents?: IntFilter<"OrganizationProfile"> | number
    totalAttendees?: IntFilter<"OrganizationProfile"> | number
    createdAt?: DateTimeFilter<"OrganizationProfile"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    teamMembers?: OrganizationMemberListRelationFilter
  }

  export type OrganizationProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    organizationName?: SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    verified?: SortOrder
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    teamMembers?: OrganizationMemberOrderByRelationAggregateInput
  }

  export type OrganizationProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    slug?: string
    AND?: OrganizationProfileWhereInput | OrganizationProfileWhereInput[]
    OR?: OrganizationProfileWhereInput[]
    NOT?: OrganizationProfileWhereInput | OrganizationProfileWhereInput[]
    organizationName?: StringFilter<"OrganizationProfile"> | string
    bio?: StringNullableFilter<"OrganizationProfile"> | string | null
    website?: StringNullableFilter<"OrganizationProfile"> | string | null
    instagram?: StringNullableFilter<"OrganizationProfile"> | string | null
    facebook?: StringNullableFilter<"OrganizationProfile"> | string | null
    twitter?: StringNullableFilter<"OrganizationProfile"> | string | null
    whatsappNumber?: StringNullableFilter<"OrganizationProfile"> | string | null
    telegramHandle?: StringNullableFilter<"OrganizationProfile"> | string | null
    logo?: StringNullableFilter<"OrganizationProfile"> | string | null
    coverImage?: StringNullableFilter<"OrganizationProfile"> | string | null
    verified?: BoolFilter<"OrganizationProfile"> | boolean
    totalEvents?: IntFilter<"OrganizationProfile"> | number
    totalAttendees?: IntFilter<"OrganizationProfile"> | number
    createdAt?: DateTimeFilter<"OrganizationProfile"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    teamMembers?: OrganizationMemberListRelationFilter
  }, "id" | "userId" | "slug">

  export type OrganizationProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    organizationName?: SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    verified?: SortOrder
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationProfileCountOrderByAggregateInput
    _avg?: OrganizationProfileAvgOrderByAggregateInput
    _max?: OrganizationProfileMaxOrderByAggregateInput
    _min?: OrganizationProfileMinOrderByAggregateInput
    _sum?: OrganizationProfileSumOrderByAggregateInput
  }

  export type OrganizationProfileScalarWhereWithAggregatesInput = {
    AND?: OrganizationProfileScalarWhereWithAggregatesInput | OrganizationProfileScalarWhereWithAggregatesInput[]
    OR?: OrganizationProfileScalarWhereWithAggregatesInput[]
    NOT?: OrganizationProfileScalarWhereWithAggregatesInput | OrganizationProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationProfile"> | string
    userId?: StringWithAggregatesFilter<"OrganizationProfile"> | string
    slug?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    organizationName?: StringWithAggregatesFilter<"OrganizationProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    whatsappNumber?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    telegramHandle?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    logo?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"OrganizationProfile"> | string | null
    verified?: BoolWithAggregatesFilter<"OrganizationProfile"> | boolean
    totalEvents?: IntWithAggregatesFilter<"OrganizationProfile"> | number
    totalAttendees?: IntWithAggregatesFilter<"OrganizationProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationProfile"> | Date | string
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    name?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    email?: StringNullableFilter<"OrganizationMember"> | string | null
    phone?: StringNullableFilter<"OrganizationMember"> | string | null
    avatar?: StringNullableFilter<"OrganizationMember"> | string | null
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationProfileScalarRelationFilter, OrganizationProfileWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationProfileOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    organizationId?: StringFilter<"OrganizationMember"> | string
    name?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    email?: StringNullableFilter<"OrganizationMember"> | string | null
    phone?: StringNullableFilter<"OrganizationMember"> | string | null
    avatar?: StringNullableFilter<"OrganizationMember"> | string | null
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationProfileScalarRelationFilter, OrganizationProfileWhereInput>
  }, "id">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMember"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    name?: StringWithAggregatesFilter<"OrganizationMember"> | string
    role?: StringWithAggregatesFilter<"OrganizationMember"> | string
    email?: StringNullableWithAggregatesFilter<"OrganizationMember"> | string | null
    phone?: StringNullableWithAggregatesFilter<"OrganizationMember"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"OrganizationMember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
  }

  export type ArtistProfileWhereInput = {
    AND?: ArtistProfileWhereInput | ArtistProfileWhereInput[]
    OR?: ArtistProfileWhereInput[]
    NOT?: ArtistProfileWhereInput | ArtistProfileWhereInput[]
    id?: StringFilter<"ArtistProfile"> | string
    userId?: StringFilter<"ArtistProfile"> | string
    artistName?: StringFilter<"ArtistProfile"> | string
    artistType?: EnumArtistTypeFilter<"ArtistProfile"> | $Enums.ArtistType
    bio?: StringNullableFilter<"ArtistProfile"> | string | null
    genres?: StringNullableListFilter<"ArtistProfile">
    website?: StringNullableFilter<"ArtistProfile"> | string | null
    instagram?: StringNullableFilter<"ArtistProfile"> | string | null
    facebook?: StringNullableFilter<"ArtistProfile"> | string | null
    twitter?: StringNullableFilter<"ArtistProfile"> | string | null
    soundcloud?: StringNullableFilter<"ArtistProfile"> | string | null
    spotify?: StringNullableFilter<"ArtistProfile"> | string | null
    youtube?: StringNullableFilter<"ArtistProfile"> | string | null
    avatar?: StringNullableFilter<"ArtistProfile"> | string | null
    coverImage?: StringNullableFilter<"ArtistProfile"> | string | null
    verified?: BoolFilter<"ArtistProfile"> | boolean
    totalGigs?: IntFilter<"ArtistProfile"> | number
    rating?: FloatNullableFilter<"ArtistProfile"> | number | null
    createdAt?: DateTimeFilter<"ArtistProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ArtistProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    performances?: PerformanceListRelationFilter
    mediaGallery?: ArtistMediaListRelationFilter
  }

  export type ArtistProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    artistName?: SortOrder
    artistType?: SortOrder
    bio?: SortOrderInput | SortOrder
    genres?: SortOrder
    website?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    soundcloud?: SortOrderInput | SortOrder
    spotify?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    verified?: SortOrder
    totalGigs?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    performances?: PerformanceOrderByRelationAggregateInput
    mediaGallery?: ArtistMediaOrderByRelationAggregateInput
  }

  export type ArtistProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ArtistProfileWhereInput | ArtistProfileWhereInput[]
    OR?: ArtistProfileWhereInput[]
    NOT?: ArtistProfileWhereInput | ArtistProfileWhereInput[]
    artistName?: StringFilter<"ArtistProfile"> | string
    artistType?: EnumArtistTypeFilter<"ArtistProfile"> | $Enums.ArtistType
    bio?: StringNullableFilter<"ArtistProfile"> | string | null
    genres?: StringNullableListFilter<"ArtistProfile">
    website?: StringNullableFilter<"ArtistProfile"> | string | null
    instagram?: StringNullableFilter<"ArtistProfile"> | string | null
    facebook?: StringNullableFilter<"ArtistProfile"> | string | null
    twitter?: StringNullableFilter<"ArtistProfile"> | string | null
    soundcloud?: StringNullableFilter<"ArtistProfile"> | string | null
    spotify?: StringNullableFilter<"ArtistProfile"> | string | null
    youtube?: StringNullableFilter<"ArtistProfile"> | string | null
    avatar?: StringNullableFilter<"ArtistProfile"> | string | null
    coverImage?: StringNullableFilter<"ArtistProfile"> | string | null
    verified?: BoolFilter<"ArtistProfile"> | boolean
    totalGigs?: IntFilter<"ArtistProfile"> | number
    rating?: FloatNullableFilter<"ArtistProfile"> | number | null
    createdAt?: DateTimeFilter<"ArtistProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ArtistProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    performances?: PerformanceListRelationFilter
    mediaGallery?: ArtistMediaListRelationFilter
  }, "id" | "userId">

  export type ArtistProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    artistName?: SortOrder
    artistType?: SortOrder
    bio?: SortOrderInput | SortOrder
    genres?: SortOrder
    website?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    soundcloud?: SortOrderInput | SortOrder
    spotify?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    verified?: SortOrder
    totalGigs?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArtistProfileCountOrderByAggregateInput
    _avg?: ArtistProfileAvgOrderByAggregateInput
    _max?: ArtistProfileMaxOrderByAggregateInput
    _min?: ArtistProfileMinOrderByAggregateInput
    _sum?: ArtistProfileSumOrderByAggregateInput
  }

  export type ArtistProfileScalarWhereWithAggregatesInput = {
    AND?: ArtistProfileScalarWhereWithAggregatesInput | ArtistProfileScalarWhereWithAggregatesInput[]
    OR?: ArtistProfileScalarWhereWithAggregatesInput[]
    NOT?: ArtistProfileScalarWhereWithAggregatesInput | ArtistProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArtistProfile"> | string
    userId?: StringWithAggregatesFilter<"ArtistProfile"> | string
    artistName?: StringWithAggregatesFilter<"ArtistProfile"> | string
    artistType?: EnumArtistTypeWithAggregatesFilter<"ArtistProfile"> | $Enums.ArtistType
    bio?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    genres?: StringNullableListFilter<"ArtistProfile">
    website?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    soundcloud?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    spotify?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"ArtistProfile"> | string | null
    verified?: BoolWithAggregatesFilter<"ArtistProfile"> | boolean
    totalGigs?: IntWithAggregatesFilter<"ArtistProfile"> | number
    rating?: FloatNullableWithAggregatesFilter<"ArtistProfile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ArtistProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ArtistProfile"> | Date | string
  }

  export type PerformanceWhereInput = {
    AND?: PerformanceWhereInput | PerformanceWhereInput[]
    OR?: PerformanceWhereInput[]
    NOT?: PerformanceWhereInput | PerformanceWhereInput[]
    id?: StringFilter<"Performance"> | string
    artistId?: StringFilter<"Performance"> | string
    eventId?: StringNullableFilter<"Performance"> | string | null
    eventName?: StringFilter<"Performance"> | string
    eventDate?: DateTimeFilter<"Performance"> | Date | string
    venueName?: StringFilter<"Performance"> | string
    city?: StringNullableFilter<"Performance"> | string | null
    description?: StringNullableFilter<"Performance"> | string | null
    fee?: FloatNullableFilter<"Performance"> | number | null
    createdAt?: DateTimeFilter<"Performance"> | Date | string
    updatedAt?: DateTimeFilter<"Performance"> | Date | string
    artist?: XOR<ArtistProfileScalarRelationFilter, ArtistProfileWhereInput>
  }

  export type PerformanceOrderByWithRelationInput = {
    id?: SortOrder
    artistId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    venueName?: SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artist?: ArtistProfileOrderByWithRelationInput
  }

  export type PerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceWhereInput | PerformanceWhereInput[]
    OR?: PerformanceWhereInput[]
    NOT?: PerformanceWhereInput | PerformanceWhereInput[]
    artistId?: StringFilter<"Performance"> | string
    eventId?: StringNullableFilter<"Performance"> | string | null
    eventName?: StringFilter<"Performance"> | string
    eventDate?: DateTimeFilter<"Performance"> | Date | string
    venueName?: StringFilter<"Performance"> | string
    city?: StringNullableFilter<"Performance"> | string | null
    description?: StringNullableFilter<"Performance"> | string | null
    fee?: FloatNullableFilter<"Performance"> | number | null
    createdAt?: DateTimeFilter<"Performance"> | Date | string
    updatedAt?: DateTimeFilter<"Performance"> | Date | string
    artist?: XOR<ArtistProfileScalarRelationFilter, ArtistProfileWhereInput>
  }, "id">

  export type PerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    artistId?: SortOrder
    eventId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    venueName?: SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    fee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceCountOrderByAggregateInput
    _avg?: PerformanceAvgOrderByAggregateInput
    _max?: PerformanceMaxOrderByAggregateInput
    _min?: PerformanceMinOrderByAggregateInput
    _sum?: PerformanceSumOrderByAggregateInput
  }

  export type PerformanceScalarWhereWithAggregatesInput = {
    AND?: PerformanceScalarWhereWithAggregatesInput | PerformanceScalarWhereWithAggregatesInput[]
    OR?: PerformanceScalarWhereWithAggregatesInput[]
    NOT?: PerformanceScalarWhereWithAggregatesInput | PerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Performance"> | string
    artistId?: StringWithAggregatesFilter<"Performance"> | string
    eventId?: StringNullableWithAggregatesFilter<"Performance"> | string | null
    eventName?: StringWithAggregatesFilter<"Performance"> | string
    eventDate?: DateTimeWithAggregatesFilter<"Performance"> | Date | string
    venueName?: StringWithAggregatesFilter<"Performance"> | string
    city?: StringNullableWithAggregatesFilter<"Performance"> | string | null
    description?: StringNullableWithAggregatesFilter<"Performance"> | string | null
    fee?: FloatNullableWithAggregatesFilter<"Performance"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Performance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Performance"> | Date | string
  }

  export type ArtistMediaWhereInput = {
    AND?: ArtistMediaWhereInput | ArtistMediaWhereInput[]
    OR?: ArtistMediaWhereInput[]
    NOT?: ArtistMediaWhereInput | ArtistMediaWhereInput[]
    id?: StringFilter<"ArtistMedia"> | string
    artistId?: StringFilter<"ArtistMedia"> | string
    type?: EnumMediaTypeFilter<"ArtistMedia"> | $Enums.MediaType
    title?: StringNullableFilter<"ArtistMedia"> | string | null
    description?: StringNullableFilter<"ArtistMedia"> | string | null
    url?: StringFilter<"ArtistMedia"> | string
    thumbnailUrl?: StringNullableFilter<"ArtistMedia"> | string | null
    order?: IntFilter<"ArtistMedia"> | number
    createdAt?: DateTimeFilter<"ArtistMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ArtistMedia"> | Date | string
    artist?: XOR<ArtistProfileScalarRelationFilter, ArtistProfileWhereInput>
  }

  export type ArtistMediaOrderByWithRelationInput = {
    id?: SortOrder
    artistId?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artist?: ArtistProfileOrderByWithRelationInput
  }

  export type ArtistMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArtistMediaWhereInput | ArtistMediaWhereInput[]
    OR?: ArtistMediaWhereInput[]
    NOT?: ArtistMediaWhereInput | ArtistMediaWhereInput[]
    artistId?: StringFilter<"ArtistMedia"> | string
    type?: EnumMediaTypeFilter<"ArtistMedia"> | $Enums.MediaType
    title?: StringNullableFilter<"ArtistMedia"> | string | null
    description?: StringNullableFilter<"ArtistMedia"> | string | null
    url?: StringFilter<"ArtistMedia"> | string
    thumbnailUrl?: StringNullableFilter<"ArtistMedia"> | string | null
    order?: IntFilter<"ArtistMedia"> | number
    createdAt?: DateTimeFilter<"ArtistMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ArtistMedia"> | Date | string
    artist?: XOR<ArtistProfileScalarRelationFilter, ArtistProfileWhereInput>
  }, "id">

  export type ArtistMediaOrderByWithAggregationInput = {
    id?: SortOrder
    artistId?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArtistMediaCountOrderByAggregateInput
    _avg?: ArtistMediaAvgOrderByAggregateInput
    _max?: ArtistMediaMaxOrderByAggregateInput
    _min?: ArtistMediaMinOrderByAggregateInput
    _sum?: ArtistMediaSumOrderByAggregateInput
  }

  export type ArtistMediaScalarWhereWithAggregatesInput = {
    AND?: ArtistMediaScalarWhereWithAggregatesInput | ArtistMediaScalarWhereWithAggregatesInput[]
    OR?: ArtistMediaScalarWhereWithAggregatesInput[]
    NOT?: ArtistMediaScalarWhereWithAggregatesInput | ArtistMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArtistMedia"> | string
    artistId?: StringWithAggregatesFilter<"ArtistMedia"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"ArtistMedia"> | $Enums.MediaType
    title?: StringNullableWithAggregatesFilter<"ArtistMedia"> | string | null
    description?: StringNullableWithAggregatesFilter<"ArtistMedia"> | string | null
    url?: StringWithAggregatesFilter<"ArtistMedia"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"ArtistMedia"> | string | null
    order?: IntWithAggregatesFilter<"ArtistMedia"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ArtistMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ArtistMedia"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    slug?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    coverImage?: StringNullableFilter<"UserProfile"> | string | null
    provincia?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    birthDate?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    gender?: EnumGenderNullableFilter<"UserProfile"> | $Enums.Gender | null
    interests?: StringNullableListFilter<"UserProfile">
    favoriteGenres?: StringNullableListFilter<"UserProfile">
    preferredVenues?: StringNullableListFilter<"UserProfile">
    tiktokHandle?: StringNullableFilter<"UserProfile"> | string | null
    spotifyUrl?: StringNullableFilter<"UserProfile"> | string | null
    whatsappNumber?: StringNullableFilter<"UserProfile"> | string | null
    telegramHandle?: StringNullableFilter<"UserProfile"> | string | null
    isPublic?: BoolFilter<"UserProfile"> | boolean
    followersCount?: IntFilter<"UserProfile"> | number
    followingCount?: IntFilter<"UserProfile"> | number
    postsCount?: IntFilter<"UserProfile"> | number
    verifiedBadge?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    provincia?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    interests?: SortOrder
    favoriteGenres?: SortOrder
    preferredVenues?: SortOrder
    tiktokHandle?: SortOrderInput | SortOrder
    spotifyUrl?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
    verifiedBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    slug?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    bio?: StringNullableFilter<"UserProfile"> | string | null
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    coverImage?: StringNullableFilter<"UserProfile"> | string | null
    provincia?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    birthDate?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    gender?: EnumGenderNullableFilter<"UserProfile"> | $Enums.Gender | null
    interests?: StringNullableListFilter<"UserProfile">
    favoriteGenres?: StringNullableListFilter<"UserProfile">
    preferredVenues?: StringNullableListFilter<"UserProfile">
    tiktokHandle?: StringNullableFilter<"UserProfile"> | string | null
    spotifyUrl?: StringNullableFilter<"UserProfile"> | string | null
    whatsappNumber?: StringNullableFilter<"UserProfile"> | string | null
    telegramHandle?: StringNullableFilter<"UserProfile"> | string | null
    isPublic?: BoolFilter<"UserProfile"> | boolean
    followersCount?: IntFilter<"UserProfile"> | number
    followingCount?: IntFilter<"UserProfile"> | number
    postsCount?: IntFilter<"UserProfile"> | number
    verifiedBadge?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "slug">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    provincia?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    interests?: SortOrder
    favoriteGenres?: SortOrder
    preferredVenues?: SortOrder
    tiktokHandle?: SortOrderInput | SortOrder
    spotifyUrl?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    telegramHandle?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
    verifiedBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    slug?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    provincia?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"UserProfile"> | $Enums.Gender | null
    interests?: StringNullableListFilter<"UserProfile">
    favoriteGenres?: StringNullableListFilter<"UserProfile">
    preferredVenues?: StringNullableListFilter<"UserProfile">
    tiktokHandle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    spotifyUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    whatsappNumber?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    telegramHandle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    isPublic?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    followersCount?: IntWithAggregatesFilter<"UserProfile"> | number
    followingCount?: IntWithAggregatesFilter<"UserProfile"> | number
    postsCount?: IntWithAggregatesFilter<"UserProfile"> | number
    verifiedBadge?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type UserFollowWhereInput = {
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type UserFollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: UserFollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type UserFollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFollowCountOrderByAggregateInput
    _max?: UserFollowMaxOrderByAggregateInput
    _min?: UserFollowMinOrderByAggregateInput
  }

  export type UserFollowScalarWhereWithAggregatesInput = {
    AND?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    OR?: UserFollowScalarWhereWithAggregatesInput[]
    NOT?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFollow"> | string
    followerId?: StringWithAggregatesFilter<"UserFollow"> | string
    followingId?: StringWithAggregatesFilter<"UserFollow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFollow"> | Date | string
  }

  export type FeedItemWhereInput = {
    AND?: FeedItemWhereInput | FeedItemWhereInput[]
    OR?: FeedItemWhereInput[]
    NOT?: FeedItemWhereInput | FeedItemWhereInput[]
    id?: StringFilter<"FeedItem"> | string
    authorId?: StringFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    content?: StringNullableFilter<"FeedItem"> | string | null
    imageUrl?: StringNullableFilter<"FeedItem"> | string | null
    videoUrl?: StringNullableFilter<"FeedItem"> | string | null
    eventId?: StringNullableFilter<"FeedItem"> | string | null
    visibility?: EnumVisibilityFilter<"FeedItem"> | $Enums.Visibility
    likesCount?: IntFilter<"FeedItem"> | number
    commentsCount?: IntFilter<"FeedItem"> | number
    createdAt?: DateTimeFilter<"FeedItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeedItem"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    likes?: FeedLikeListRelationFilter
    comments?: FeedCommentListRelationFilter
  }

  export type FeedItemOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    visibility?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    likes?: FeedLikeOrderByRelationAggregateInput
    comments?: FeedCommentOrderByRelationAggregateInput
  }

  export type FeedItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedItemWhereInput | FeedItemWhereInput[]
    OR?: FeedItemWhereInput[]
    NOT?: FeedItemWhereInput | FeedItemWhereInput[]
    authorId?: StringFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    content?: StringNullableFilter<"FeedItem"> | string | null
    imageUrl?: StringNullableFilter<"FeedItem"> | string | null
    videoUrl?: StringNullableFilter<"FeedItem"> | string | null
    eventId?: StringNullableFilter<"FeedItem"> | string | null
    visibility?: EnumVisibilityFilter<"FeedItem"> | $Enums.Visibility
    likesCount?: IntFilter<"FeedItem"> | number
    commentsCount?: IntFilter<"FeedItem"> | number
    createdAt?: DateTimeFilter<"FeedItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeedItem"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    likes?: FeedLikeListRelationFilter
    comments?: FeedCommentListRelationFilter
  }, "id">

  export type FeedItemOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    visibility?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedItemCountOrderByAggregateInput
    _avg?: FeedItemAvgOrderByAggregateInput
    _max?: FeedItemMaxOrderByAggregateInput
    _min?: FeedItemMinOrderByAggregateInput
    _sum?: FeedItemSumOrderByAggregateInput
  }

  export type FeedItemScalarWhereWithAggregatesInput = {
    AND?: FeedItemScalarWhereWithAggregatesInput | FeedItemScalarWhereWithAggregatesInput[]
    OR?: FeedItemScalarWhereWithAggregatesInput[]
    NOT?: FeedItemScalarWhereWithAggregatesInput | FeedItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedItem"> | string
    authorId?: StringWithAggregatesFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeWithAggregatesFilter<"FeedItem"> | $Enums.FeedItemType
    content?: StringNullableWithAggregatesFilter<"FeedItem"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"FeedItem"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"FeedItem"> | string | null
    eventId?: StringNullableWithAggregatesFilter<"FeedItem"> | string | null
    visibility?: EnumVisibilityWithAggregatesFilter<"FeedItem"> | $Enums.Visibility
    likesCount?: IntWithAggregatesFilter<"FeedItem"> | number
    commentsCount?: IntWithAggregatesFilter<"FeedItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FeedItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedItem"> | Date | string
  }

  export type FeedLikeWhereInput = {
    AND?: FeedLikeWhereInput | FeedLikeWhereInput[]
    OR?: FeedLikeWhereInput[]
    NOT?: FeedLikeWhereInput | FeedLikeWhereInput[]
    id?: StringFilter<"FeedLike"> | string
    feedItemId?: StringFilter<"FeedLike"> | string
    userId?: StringFilter<"FeedLike"> | string
    createdAt?: DateTimeFilter<"FeedLike"> | Date | string
    feedItem?: XOR<FeedItemScalarRelationFilter, FeedItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedLikeOrderByWithRelationInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    feedItem?: FeedItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FeedLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    feedItemId_userId?: FeedLikeFeedItemIdUserIdCompoundUniqueInput
    AND?: FeedLikeWhereInput | FeedLikeWhereInput[]
    OR?: FeedLikeWhereInput[]
    NOT?: FeedLikeWhereInput | FeedLikeWhereInput[]
    feedItemId?: StringFilter<"FeedLike"> | string
    userId?: StringFilter<"FeedLike"> | string
    createdAt?: DateTimeFilter<"FeedLike"> | Date | string
    feedItem?: XOR<FeedItemScalarRelationFilter, FeedItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "feedItemId_userId">

  export type FeedLikeOrderByWithAggregationInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: FeedLikeCountOrderByAggregateInput
    _max?: FeedLikeMaxOrderByAggregateInput
    _min?: FeedLikeMinOrderByAggregateInput
  }

  export type FeedLikeScalarWhereWithAggregatesInput = {
    AND?: FeedLikeScalarWhereWithAggregatesInput | FeedLikeScalarWhereWithAggregatesInput[]
    OR?: FeedLikeScalarWhereWithAggregatesInput[]
    NOT?: FeedLikeScalarWhereWithAggregatesInput | FeedLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedLike"> | string
    feedItemId?: StringWithAggregatesFilter<"FeedLike"> | string
    userId?: StringWithAggregatesFilter<"FeedLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeedLike"> | Date | string
  }

  export type FeedCommentWhereInput = {
    AND?: FeedCommentWhereInput | FeedCommentWhereInput[]
    OR?: FeedCommentWhereInput[]
    NOT?: FeedCommentWhereInput | FeedCommentWhereInput[]
    id?: StringFilter<"FeedComment"> | string
    feedItemId?: StringFilter<"FeedComment"> | string
    userId?: StringFilter<"FeedComment"> | string
    content?: StringFilter<"FeedComment"> | string
    createdAt?: DateTimeFilter<"FeedComment"> | Date | string
    updatedAt?: DateTimeFilter<"FeedComment"> | Date | string
    feedItem?: XOR<FeedItemScalarRelationFilter, FeedItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedCommentOrderByWithRelationInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feedItem?: FeedItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FeedCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedCommentWhereInput | FeedCommentWhereInput[]
    OR?: FeedCommentWhereInput[]
    NOT?: FeedCommentWhereInput | FeedCommentWhereInput[]
    feedItemId?: StringFilter<"FeedComment"> | string
    userId?: StringFilter<"FeedComment"> | string
    content?: StringFilter<"FeedComment"> | string
    createdAt?: DateTimeFilter<"FeedComment"> | Date | string
    updatedAt?: DateTimeFilter<"FeedComment"> | Date | string
    feedItem?: XOR<FeedItemScalarRelationFilter, FeedItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedCommentOrderByWithAggregationInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedCommentCountOrderByAggregateInput
    _max?: FeedCommentMaxOrderByAggregateInput
    _min?: FeedCommentMinOrderByAggregateInput
  }

  export type FeedCommentScalarWhereWithAggregatesInput = {
    AND?: FeedCommentScalarWhereWithAggregatesInput | FeedCommentScalarWhereWithAggregatesInput[]
    OR?: FeedCommentScalarWhereWithAggregatesInput[]
    NOT?: FeedCommentScalarWhereWithAggregatesInput | FeedCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedComment"> | string
    feedItemId?: StringWithAggregatesFilter<"FeedComment"> | string
    userId?: StringWithAggregatesFilter<"FeedComment"> | string
    content?: StringWithAggregatesFilter<"FeedComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeedComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedComment"> | Date | string
  }

  export type IdentityVerificationWhereInput = {
    AND?: IdentityVerificationWhereInput | IdentityVerificationWhereInput[]
    OR?: IdentityVerificationWhereInput[]
    NOT?: IdentityVerificationWhereInput | IdentityVerificationWhereInput[]
    id?: StringFilter<"IdentityVerification"> | string
    userId?: StringFilter<"IdentityVerification"> | string
    documentType?: EnumDocumentTypeFilter<"IdentityVerification"> | $Enums.DocumentType
    documentNumber?: StringNullableFilter<"IdentityVerification"> | string | null
    documentFrontUrl?: StringFilter<"IdentityVerification"> | string
    documentBackUrl?: StringNullableFilter<"IdentityVerification"> | string | null
    selfieUrl?: StringFilter<"IdentityVerification"> | string
    status?: EnumVerificationStatusFilter<"IdentityVerification"> | $Enums.VerificationStatus
    reviewedBy?: StringNullableFilter<"IdentityVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableFilter<"IdentityVerification"> | string | null
    expiresAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"IdentityVerification"> | Date | string
    updatedAt?: DateTimeFilter<"IdentityVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type IdentityVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrderInput | SortOrder
    documentFrontUrl?: SortOrder
    documentBackUrl?: SortOrderInput | SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type IdentityVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IdentityVerificationWhereInput | IdentityVerificationWhereInput[]
    OR?: IdentityVerificationWhereInput[]
    NOT?: IdentityVerificationWhereInput | IdentityVerificationWhereInput[]
    userId?: StringFilter<"IdentityVerification"> | string
    documentType?: EnumDocumentTypeFilter<"IdentityVerification"> | $Enums.DocumentType
    documentNumber?: StringNullableFilter<"IdentityVerification"> | string | null
    documentFrontUrl?: StringFilter<"IdentityVerification"> | string
    documentBackUrl?: StringNullableFilter<"IdentityVerification"> | string | null
    selfieUrl?: StringFilter<"IdentityVerification"> | string
    status?: EnumVerificationStatusFilter<"IdentityVerification"> | $Enums.VerificationStatus
    reviewedBy?: StringNullableFilter<"IdentityVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableFilter<"IdentityVerification"> | string | null
    expiresAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"IdentityVerification"> | Date | string
    updatedAt?: DateTimeFilter<"IdentityVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type IdentityVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrderInput | SortOrder
    documentFrontUrl?: SortOrder
    documentBackUrl?: SortOrderInput | SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdentityVerificationCountOrderByAggregateInput
    _max?: IdentityVerificationMaxOrderByAggregateInput
    _min?: IdentityVerificationMinOrderByAggregateInput
  }

  export type IdentityVerificationScalarWhereWithAggregatesInput = {
    AND?: IdentityVerificationScalarWhereWithAggregatesInput | IdentityVerificationScalarWhereWithAggregatesInput[]
    OR?: IdentityVerificationScalarWhereWithAggregatesInput[]
    NOT?: IdentityVerificationScalarWhereWithAggregatesInput | IdentityVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IdentityVerification"> | string
    userId?: StringWithAggregatesFilter<"IdentityVerification"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"IdentityVerification"> | $Enums.DocumentType
    documentNumber?: StringNullableWithAggregatesFilter<"IdentityVerification"> | string | null
    documentFrontUrl?: StringWithAggregatesFilter<"IdentityVerification"> | string
    documentBackUrl?: StringNullableWithAggregatesFilter<"IdentityVerification"> | string | null
    selfieUrl?: StringWithAggregatesFilter<"IdentityVerification"> | string
    status?: EnumVerificationStatusWithAggregatesFilter<"IdentityVerification"> | $Enums.VerificationStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"IdentityVerification"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"IdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"IdentityVerification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"IdentityVerification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IdentityVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdentityVerification"> | Date | string
  }

  export type UserPhoneWhereInput = {
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    id?: StringFilter<"UserPhone"> | string
    userId?: StringFilter<"UserPhone"> | string
    phoneNumber?: StringFilter<"UserPhone"> | string
    phoneVerified?: BoolFilter<"UserPhone"> | boolean
    phoneVerifiedAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    otpCode?: StringNullableFilter<"UserPhone"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    otpAttempts?: IntFilter<"UserPhone"> | number
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPhoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    phoneVerifiedAt?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    otpAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    phoneNumber?: string
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    phoneVerified?: BoolFilter<"UserPhone"> | boolean
    phoneVerifiedAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    otpCode?: StringNullableFilter<"UserPhone"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    otpAttempts?: IntFilter<"UserPhone"> | number
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "phoneNumber">

  export type UserPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    phoneVerifiedAt?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    otpAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPhoneCountOrderByAggregateInput
    _avg?: UserPhoneAvgOrderByAggregateInput
    _max?: UserPhoneMaxOrderByAggregateInput
    _min?: UserPhoneMinOrderByAggregateInput
    _sum?: UserPhoneSumOrderByAggregateInput
  }

  export type UserPhoneScalarWhereWithAggregatesInput = {
    AND?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    OR?: UserPhoneScalarWhereWithAggregatesInput[]
    NOT?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPhone"> | string
    userId?: StringWithAggregatesFilter<"UserPhone"> | string
    phoneNumber?: StringWithAggregatesFilter<"UserPhone"> | string
    phoneVerified?: BoolWithAggregatesFilter<"UserPhone"> | boolean
    phoneVerifiedAt?: DateTimeNullableWithAggregatesFilter<"UserPhone"> | Date | string | null
    otpCode?: StringNullableWithAggregatesFilter<"UserPhone"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"UserPhone"> | Date | string | null
    otpAttempts?: IntWithAggregatesFilter<"UserPhone"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserPhone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPhone"> | Date | string
  }

  export type UserConsentWhereInput = {
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    id?: StringFilter<"UserConsent"> | string
    userId?: StringFilter<"UserConsent"> | string
    termsAccepted?: BoolFilter<"UserConsent"> | boolean
    termsAcceptedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    privacyAccepted?: BoolFilter<"UserConsent"> | boolean
    privacyAcceptedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    marketingOptIn?: BoolFilter<"UserConsent"> | boolean
    marketingOptInAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    newsletterOptIn?: BoolFilter<"UserConsent"> | boolean
    newsletterOptInAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    createdAt?: DateTimeFilter<"UserConsent"> | Date | string
    updatedAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    privacyAccepted?: SortOrder
    privacyAcceptedAt?: SortOrderInput | SortOrder
    marketingOptIn?: SortOrder
    marketingOptInAt?: SortOrderInput | SortOrder
    newsletterOptIn?: SortOrder
    newsletterOptInAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    termsAccepted?: BoolFilter<"UserConsent"> | boolean
    termsAcceptedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    privacyAccepted?: BoolFilter<"UserConsent"> | boolean
    privacyAcceptedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    marketingOptIn?: BoolFilter<"UserConsent"> | boolean
    marketingOptInAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    newsletterOptIn?: BoolFilter<"UserConsent"> | boolean
    newsletterOptInAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    createdAt?: DateTimeFilter<"UserConsent"> | Date | string
    updatedAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    privacyAccepted?: SortOrder
    privacyAcceptedAt?: SortOrderInput | SortOrder
    marketingOptIn?: SortOrder
    marketingOptInAt?: SortOrderInput | SortOrder
    newsletterOptIn?: SortOrder
    newsletterOptInAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserConsentCountOrderByAggregateInput
    _max?: UserConsentMaxOrderByAggregateInput
    _min?: UserConsentMinOrderByAggregateInput
  }

  export type UserConsentScalarWhereWithAggregatesInput = {
    AND?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    OR?: UserConsentScalarWhereWithAggregatesInput[]
    NOT?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserConsent"> | string
    userId?: StringWithAggregatesFilter<"UserConsent"> | string
    termsAccepted?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    termsAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    privacyAccepted?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    privacyAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    marketingOptIn?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    marketingOptInAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    newsletterOptIn?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    newsletterOptInAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
  }

  export type OnboardingProgressWhereInput = {
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    id?: StringFilter<"OnboardingProgress"> | string
    userId?: StringFilter<"OnboardingProgress"> | string
    currentStep?: IntFilter<"OnboardingProgress"> | number
    step1Completed?: BoolFilter<"OnboardingProgress"> | boolean
    step2Completed?: BoolFilter<"OnboardingProgress"> | boolean
    step3Completed?: BoolFilter<"OnboardingProgress"> | boolean
    onboardingComplete?: BoolFilter<"OnboardingProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OnboardingProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStep?: SortOrder
    step1Completed?: SortOrder
    step2Completed?: SortOrder
    step3Completed?: SortOrder
    onboardingComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OnboardingProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    currentStep?: IntFilter<"OnboardingProgress"> | number
    step1Completed?: BoolFilter<"OnboardingProgress"> | boolean
    step2Completed?: BoolFilter<"OnboardingProgress"> | boolean
    step3Completed?: BoolFilter<"OnboardingProgress"> | boolean
    onboardingComplete?: BoolFilter<"OnboardingProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type OnboardingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStep?: SortOrder
    step1Completed?: SortOrder
    step2Completed?: SortOrder
    step3Completed?: SortOrder
    onboardingComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OnboardingProgressCountOrderByAggregateInput
    _avg?: OnboardingProgressAvgOrderByAggregateInput
    _max?: OnboardingProgressMaxOrderByAggregateInput
    _min?: OnboardingProgressMinOrderByAggregateInput
    _sum?: OnboardingProgressSumOrderByAggregateInput
  }

  export type OnboardingProgressScalarWhereWithAggregatesInput = {
    AND?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    OR?: OnboardingProgressScalarWhereWithAggregatesInput[]
    NOT?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingProgress"> | string
    userId?: StringWithAggregatesFilter<"OnboardingProgress"> | string
    currentStep?: IntWithAggregatesFilter<"OnboardingProgress"> | number
    step1Completed?: BoolWithAggregatesFilter<"OnboardingProgress"> | boolean
    step2Completed?: BoolWithAggregatesFilter<"OnboardingProgress"> | boolean
    step3Completed?: BoolWithAggregatesFilter<"OnboardingProgress"> | boolean
    onboardingComplete?: BoolWithAggregatesFilter<"OnboardingProgress"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubCreateInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutClubsOwnedInput
    venues?: VenueCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutClubsOwnedNestedInput
    venues?: VenueUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    club?: ClubCreateNestedOneWithoutVenuesInput
    events?: EventCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutVenuesNestedInput
    events?: EventUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRProfileCreateInput = {
    id?: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutPrProfileInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutPrProfileInput
    user: UserCreateNestedOneWithoutPrProfileInput
  }

  export type PRProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutPrProfileInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutPrProfileInput
  }

  export type PRProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutPrProfileNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutPrProfileNestedInput
    user?: UserUpdateOneRequiredWithoutPrProfileNestedInput
  }

  export type PRProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutPrProfileNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutPrProfileNestedInput
  }

  export type PRProfileCreateManyInput = {
    id?: string
    userId: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PRProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    id?: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutAssignmentsInput
    prProfile: PRProfileCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    eventId: string
    prProfileId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutAssignmentsNestedInput
    prProfile?: PRProfileUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyInput = {
    id?: string
    eventId: string
    prProfileId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListCreateInput = {
    id?: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: ListEntryCreateNestedManyWithoutListInput
    event: EventCreateNestedOneWithoutListsInput
  }

  export type ListUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: ListEntryUncheckedCreateNestedManyWithoutListInput
  }

  export type ListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ListEntryUpdateManyWithoutListNestedInput
    event?: EventUpdateOneRequiredWithoutListsNestedInput
  }

  export type ListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ListEntryUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListCreateManyInput = {
    id?: string
    eventId: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutGuestInput
    tickets?: TicketCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutGuestInput
    tickets?: TicketUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutGuestNestedInput
    tickets?: TicketUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type GuestCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListEntryCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutListEntriesInput
    guest?: GuestCreateNestedOneWithoutListEntriesInput
    list: ListCreateNestedOneWithoutEntriesInput
    tickets?: TicketCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryUncheckedCreateInput = {
    id?: string
    listId: string
    guestId?: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutListEntriesNestedInput
    guest?: GuestUpdateOneWithoutListEntriesNestedInput
    list?: ListUpdateOneRequiredWithoutEntriesNestedInput
    tickets?: TicketUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryCreateManyInput = {
    id?: string
    listId: string
    guestId?: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInCreateInput = {
    id?: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
    scannedBy: UserCreateNestedOneWithoutCheckinsInput
    ticket: TicketCreateNestedOneWithoutCheckinsInput
  }

  export type CheckInUncheckedCreateInput = {
    id?: string
    ticketId: string
    scannedByUserId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type CheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    scannedBy?: UserUpdateOneRequiredWithoutCheckinsNestedInput
    ticket?: TicketUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type CheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    scannedByUserId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInCreateManyInput = {
    id?: string
    ticketId: string
    scannedByUserId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type CheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    scannedByUserId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type InviteLinkCreateInput = {
    id?: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutInviteLinksInput
    event: EventCreateNestedOneWithoutInviteLinksInput
    prProfile?: PRProfileCreateNestedOneWithoutInviteLinksInput
  }

  export type InviteLinkUncheckedCreateInput = {
    id?: string
    createdByUserId: string
    eventId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutInviteLinksNestedInput
    event?: EventUpdateOneRequiredWithoutInviteLinksNestedInput
    prProfile?: PRProfileUpdateOneWithoutInviteLinksNestedInput
  }

  export type InviteLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkCreateManyInput = {
    id?: string
    createdByUserId: string
    eventId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionCreateInput = {
    id?: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutConsumptionsInput
    ticket: TicketCreateNestedOneWithoutConsumptionsInput
  }

  export type ConsumptionUncheckedCreateInput = {
    id?: string
    ticketId: string
    eventId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsumptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutConsumptionsNestedInput
    ticket?: TicketUpdateOneRequiredWithoutConsumptionsNestedInput
  }

  export type ConsumptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionCreateManyInput = {
    id?: string
    ticketId: string
    eventId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsumptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingCreateInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
    event: EventCreateNestedOneWithoutFunnelTrackingInput
  }

  export type FunnelTrackingUncheckedCreateInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    eventId: string
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
  }

  export type FunnelTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutFunnelTrackingNestedInput
  }

  export type FunnelTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingCreateManyInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    eventId: string
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
  }

  export type FunnelTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: StringFieldUpdateOperationsInput | string
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackCreateInput = {
    id?: string
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutFeedbacksInput
    guest?: GuestCreateNestedOneWithoutFeedbacksInput
    ticket?: TicketCreateNestedOneWithoutFeedbacksInput
  }

  export type EventFeedbackUncheckedCreateInput = {
    id?: string
    eventId: string
    ticketId?: string | null
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutFeedbacksNestedInput
    guest?: GuestUpdateOneWithoutFeedbacksNestedInput
    ticket?: TicketUpdateOneWithoutFeedbacksNestedInput
  }

  export type EventFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackCreateManyInput = {
    id?: string
    eventId: string
    ticketId?: string | null
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteCreateInput = {
    id?: string
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
    event?: EventCreateNestedOneWithoutSecurityNotesInput
    guest?: GuestCreateNestedOneWithoutSecurityNotesInput
    reportedBy: UserCreateNestedOneWithoutSecurityReportsInput
    ticket?: TicketCreateNestedOneWithoutSecurityNotesInput
  }

  export type SecurityNoteUncheckedCreateInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneWithoutSecurityNotesNestedInput
    guest?: GuestUpdateOneWithoutSecurityNotesNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSecurityReportsNestedInput
    ticket?: TicketUpdateOneWithoutSecurityNotesNestedInput
  }

  export type SecurityNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteCreateManyInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPreferencesCreateInput = {
    id?: string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: number | null
    responseToPromo?: string | null
    socialEngagement?: string | null
    conversionScore?: number | null
    lifetimeValue?: number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    guest: GuestCreateNestedOneWithoutPreferencesInput
  }

  export type CustomerPreferencesUncheckedCreateInput = {
    id?: string
    guestId: string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: number | null
    responseToPromo?: string | null
    socialEngagement?: string | null
    conversionScore?: number | null
    lifetimeValue?: number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type CustomerPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: GuestUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type CustomerPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPreferencesCreateManyInput = {
    id?: string
    guestId: string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: number | null
    responseToPromo?: string | null
    socialEngagement?: string | null
    conversionScore?: number | null
    lifetimeValue?: number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type CustomerPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationProfileCreateInput = {
    id?: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationProfileInput
    teamMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationProfileUncheckedCreateInput = {
    id?: string
    userId: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationProfileNestedInput
    teamMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationProfileCreateManyInput = {
    id?: string
    userId: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationProfileCreateNestedOneWithoutTeamMembersInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationProfileUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistProfileCreateInput = {
    id?: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutArtistProfileInput
    performances?: PerformanceCreateNestedManyWithoutArtistInput
    mediaGallery?: ArtistMediaCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileUncheckedCreateInput = {
    id?: string
    userId: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performances?: PerformanceUncheckedCreateNestedManyWithoutArtistInput
    mediaGallery?: ArtistMediaUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutArtistProfileNestedInput
    performances?: PerformanceUpdateManyWithoutArtistNestedInput
    mediaGallery?: ArtistMediaUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performances?: PerformanceUncheckedUpdateManyWithoutArtistNestedInput
    mediaGallery?: ArtistMediaUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileCreateManyInput = {
    id?: string
    userId: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCreateInput = {
    id?: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistProfileCreateNestedOneWithoutPerformancesInput
  }

  export type PerformanceUncheckedCreateInput = {
    id?: string
    artistId: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistProfileUpdateOneRequiredWithoutPerformancesNestedInput
  }

  export type PerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCreateManyInput = {
    id?: string
    artistId: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaCreateInput = {
    id?: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistProfileCreateNestedOneWithoutMediaGalleryInput
  }

  export type ArtistMediaUncheckedCreateInput = {
    id?: string
    artistId: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistProfileUpdateOneRequiredWithoutMediaGalleryNestedInput
  }

  export type ArtistMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaCreateManyInput = {
    id?: string
    artistId: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    slug?: string | null
    bio?: string | null
    avatar?: string | null
    coverImage?: string | null
    provincia?: string | null
    city?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    interests?: UserProfileCreateinterestsInput | string[]
    favoriteGenres?: UserProfileCreatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileCreatepreferredVenuesInput | string[]
    tiktokHandle?: string | null
    spotifyUrl?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    isPublic?: boolean
    followersCount?: number
    followingCount?: number
    postsCount?: number
    verifiedBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    slug?: string | null
    bio?: string | null
    avatar?: string | null
    coverImage?: string | null
    provincia?: string | null
    city?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    interests?: UserProfileCreateinterestsInput | string[]
    favoriteGenres?: UserProfileCreatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileCreatepreferredVenuesInput | string[]
    tiktokHandle?: string | null
    spotifyUrl?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    isPublic?: boolean
    followersCount?: number
    followingCount?: number
    postsCount?: number
    verifiedBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    slug?: string | null
    bio?: string | null
    avatar?: string | null
    coverImage?: string | null
    provincia?: string | null
    city?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    interests?: UserProfileCreateinterestsInput | string[]
    favoriteGenres?: UserProfileCreatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileCreatepreferredVenuesInput | string[]
    tiktokHandle?: string | null
    spotifyUrl?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    isPublic?: boolean
    followersCount?: number
    followingCount?: number
    postsCount?: number
    verifiedBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type UserFollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type UserFollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemCreateInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedItemsInput
    likes?: FeedLikeCreateNestedManyWithoutFeedItemInput
    comments?: FeedCommentCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemUncheckedCreateInput = {
    id?: string
    authorId: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FeedLikeUncheckedCreateNestedManyWithoutFeedItemInput
    comments?: FeedCommentUncheckedCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedItemsNestedInput
    likes?: FeedLikeUpdateManyWithoutFeedItemNestedInput
    comments?: FeedCommentUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FeedLikeUncheckedUpdateManyWithoutFeedItemNestedInput
    comments?: FeedCommentUncheckedUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemCreateManyInput = {
    id?: string
    authorId: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    feedItem: FeedItemCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutFeedLikesInput
  }

  export type FeedLikeUncheckedCreateInput = {
    id?: string
    feedItemId: string
    userId: string
    createdAt?: Date | string
  }

  export type FeedLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedItem?: FeedItemUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutFeedLikesNestedInput
  }

  export type FeedLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeCreateManyInput = {
    id?: string
    feedItemId: string
    userId: string
    createdAt?: Date | string
  }

  export type FeedLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feedItem: FeedItemCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutFeedCommentsInput
  }

  export type FeedCommentUncheckedCreateInput = {
    id?: string
    feedItemId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedItem?: FeedItemUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutFeedCommentsNestedInput
  }

  export type FeedCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentCreateManyInput = {
    id?: string
    feedItemId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdentityVerificationsInput
    reviewer?: UserCreateNestedOneWithoutReviewedVerificationsInput
  }

  export type IdentityVerificationUncheckedCreateInput = {
    id?: string
    userId: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdentityVerificationsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedVerificationsNestedInput
  }

  export type IdentityVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationCreateManyInput = {
    id?: string
    userId: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateInput = {
    id?: string
    phoneNumber: string
    phoneVerified?: boolean
    phoneVerifiedAt?: Date | string | null
    otpCode?: string | null
    otpExpiresAt?: Date | string | null
    otpAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPhoneVerificationInput
  }

  export type UserPhoneUncheckedCreateInput = {
    id?: string
    userId: string
    phoneNumber: string
    phoneVerified?: boolean
    phoneVerifiedAt?: Date | string | null
    otpCode?: string | null
    otpExpiresAt?: Date | string | null
    otpAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPhoneVerificationNestedInput
  }

  export type UserPhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateManyInput = {
    id?: string
    userId: string
    phoneNumber: string
    phoneVerified?: boolean
    phoneVerifiedAt?: Date | string | null
    otpCode?: string | null
    otpExpiresAt?: Date | string | null
    otpAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateInput = {
    id?: string
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyAcceptedAt?: Date | string | null
    marketingOptIn?: boolean
    marketingOptInAt?: Date | string | null
    newsletterOptIn?: boolean
    newsletterOptInAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConsentsInput
  }

  export type UserConsentUncheckedCreateInput = {
    id?: string
    userId: string
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyAcceptedAt?: Date | string | null
    marketingOptIn?: boolean
    marketingOptInAt?: Date | string | null
    newsletterOptIn?: boolean
    newsletterOptInAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type UserConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateManyInput = {
    id?: string
    userId: string
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyAcceptedAt?: Date | string | null
    marketingOptIn?: boolean
    marketingOptInAt?: Date | string | null
    newsletterOptIn?: boolean
    newsletterOptInAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressCreateInput = {
    id?: string
    currentStep?: number
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
  }

  export type OnboardingProgressUncheckedCreateInput = {
    id?: string
    userId: string
    currentStep?: number
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
  }

  export type OnboardingProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressCreateManyInput = {
    id?: string
    userId: string
    currentStep?: number
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type CheckInListRelationFilter = {
    every?: CheckInWhereInput
    some?: CheckInWhereInput
    none?: CheckInWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type InviteLinkListRelationFilter = {
    every?: InviteLinkWhereInput
    some?: InviteLinkWhereInput
    none?: InviteLinkWhereInput
  }

  export type ListEntryListRelationFilter = {
    every?: ListEntryWhereInput
    some?: ListEntryWhereInput
    none?: ListEntryWhereInput
  }

  export type PRProfileNullableScalarRelationFilter = {
    is?: PRProfileWhereInput | null
    isNot?: PRProfileWhereInput | null
  }

  export type SecurityNoteListRelationFilter = {
    every?: SecurityNoteWhereInput
    some?: SecurityNoteWhereInput
    none?: SecurityNoteWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type ClubListRelationFilter = {
    every?: ClubWhereInput
    some?: ClubWhereInput
    none?: ClubWhereInput
  }

  export type OrganizationProfileNullableScalarRelationFilter = {
    is?: OrganizationProfileWhereInput | null
    isNot?: OrganizationProfileWhereInput | null
  }

  export type ArtistProfileNullableScalarRelationFilter = {
    is?: ArtistProfileWhereInput | null
    isNot?: ArtistProfileWhereInput | null
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type FeedItemListRelationFilter = {
    every?: FeedItemWhereInput
    some?: FeedItemWhereInput
    none?: FeedItemWhereInput
  }

  export type FeedLikeListRelationFilter = {
    every?: FeedLikeWhereInput
    some?: FeedLikeWhereInput
    none?: FeedLikeWhereInput
  }

  export type FeedCommentListRelationFilter = {
    every?: FeedCommentWhereInput
    some?: FeedCommentWhereInput
    none?: FeedCommentWhereInput
  }

  export type UserFollowListRelationFilter = {
    every?: UserFollowWhereInput
    some?: UserFollowWhereInput
    none?: UserFollowWhereInput
  }

  export type IdentityVerificationListRelationFilter = {
    every?: IdentityVerificationWhereInput
    some?: IdentityVerificationWhereInput
    none?: IdentityVerificationWhereInput
  }

  export type UserPhoneNullableScalarRelationFilter = {
    is?: UserPhoneWhereInput | null
    isNot?: UserPhoneWhereInput | null
  }

  export type UserConsentNullableScalarRelationFilter = {
    is?: UserConsentWhereInput | null
    isNot?: UserConsentWhereInput | null
  }

  export type OnboardingProgressNullableScalarRelationFilter = {
    is?: OnboardingProgressWhereInput | null
    isNot?: OnboardingProgressWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdentityVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    age?: SortOrder
    ageVerified?: SortOrder
    ageConsent?: SortOrder
    identityVerified?: SortOrder
    identityVerifiedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    age?: SortOrder
    ageVerified?: SortOrder
    ageConsent?: SortOrder
    identityVerified?: SortOrder
    identityVerifiedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    age?: SortOrder
    ageVerified?: SortOrder
    ageConsent?: SortOrder
    identityVerified?: SortOrder
    identityVerifiedAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumClubTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubType | EnumClubTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClubTypeFilter<$PrismaModel> | $Enums.ClubType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    gallery?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    openingHours?: SortOrder
    priceRange?: SortOrder
    amenities?: SortOrder
    musicGenres?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    openingHours?: SortOrder
    priceRange?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    openingHours?: SortOrder
    priceRange?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClubTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubType | EnumClubTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClubTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClubType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClubTypeFilter<$PrismaModel>
    _max?: NestedEnumClubTypeFilter<$PrismaModel>
  }

  export type ClubNullableScalarRelationFilter = {
    is?: ClubWhereInput | null
    isNot?: ClubWhereInput | null
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    capacity?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    capacity?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    city?: SortOrder
    capacity?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type ConsumptionListRelationFilter = {
    every?: ConsumptionWhereInput
    some?: ConsumptionWhereInput
    none?: ConsumptionWhereInput
  }

  export type EventFeedbackListRelationFilter = {
    every?: EventFeedbackWhereInput
    some?: EventFeedbackWhereInput
    none?: EventFeedbackWhereInput
  }

  export type VenueScalarRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type FunnelTrackingListRelationFilter = {
    every?: FunnelTrackingWhereInput
    some?: FunnelTrackingWhereInput
    none?: FunnelTrackingWhereInput
  }

  export type ListListRelationFilter = {
    every?: ListWhereInput
    some?: ListWhereInput
    none?: ListWhereInput
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsumptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    minAge?: SortOrder
    dressCode?: SortOrder
    venueId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    minAge?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    minAge?: SortOrder
    dressCode?: SortOrder
    venueId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    status?: SortOrder
    minAge?: SortOrder
    dressCode?: SortOrder
    venueId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    minAge?: SortOrder
  }

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type PRProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    referralCode?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PRProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    referralCode?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PRProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    referralCode?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type PRProfileScalarRelationFilter = {
    is?: PRProfileWhereInput
    isNot?: PRProfileWhereInput
  }

  export type AssignmentEventIdPrProfileIdCompoundUniqueInput = {
    eventId: string
    prProfileId: string
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
  }

  export type EnumListTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeFilter<$PrismaModel> | $Enums.ListType
  }

  export type ListCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListAvgOrderByAggregateInput = {
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
  }

  export type ListMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListSumOrderByAggregateInput = {
    quotaTotal?: SortOrder
    quotaFemale?: SortOrder
    quotaMale?: SortOrder
  }

  export type EnumListTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListTypeFilter<$PrismaModel>
    _max?: NestedEnumListTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCustomerSegmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentFilter<$PrismaModel> | $Enums.CustomerSegment
  }

  export type CustomerPreferencesNullableScalarRelationFilter = {
    is?: CustomerPreferencesWhereInput | null
    isNot?: CustomerPreferencesWhereInput | null
  }

  export type GuestCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    occupation?: SortOrder
    instagram?: SortOrder
    telegramChatId?: SortOrder
    whatsappPhone?: SortOrder
    totalEvents?: SortOrder
    lastEventDate?: SortOrder
    customerSegment?: SortOrder
    preferredDays?: SortOrder
    averageArrivalTime?: SortOrder
    prefersTable?: SortOrder
    averageGroupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestAvgOrderByAggregateInput = {
    totalEvents?: SortOrder
    averageGroupSize?: SortOrder
  }

  export type GuestMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    occupation?: SortOrder
    instagram?: SortOrder
    telegramChatId?: SortOrder
    whatsappPhone?: SortOrder
    totalEvents?: SortOrder
    lastEventDate?: SortOrder
    customerSegment?: SortOrder
    preferredDays?: SortOrder
    averageArrivalTime?: SortOrder
    prefersTable?: SortOrder
    averageGroupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    nickname?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    occupation?: SortOrder
    instagram?: SortOrder
    telegramChatId?: SortOrder
    whatsappPhone?: SortOrder
    totalEvents?: SortOrder
    lastEventDate?: SortOrder
    customerSegment?: SortOrder
    preferredDays?: SortOrder
    averageArrivalTime?: SortOrder
    prefersTable?: SortOrder
    averageGroupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestSumOrderByAggregateInput = {
    totalEvents?: SortOrder
    averageGroupSize?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCustomerSegmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel> | $Enums.CustomerSegment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerSegmentFilter<$PrismaModel>
    _max?: NestedEnumCustomerSegmentFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumCreatedViaFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaFilter<$PrismaModel> | $Enums.CreatedVia
  }

  export type EnumEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEntryStatusFilter<$PrismaModel> | $Enums.EntryStatus
  }

  export type EnumBookingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMethod | EnumBookingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingMethodFilter<$PrismaModel> | $Enums.BookingMethod
  }

  export type GuestNullableScalarRelationFilter = {
    is?: GuestWhereInput | null
    isNot?: GuestWhereInput | null
  }

  export type ListScalarRelationFilter = {
    is?: ListWhereInput
    isNot?: ListWhereInput
  }

  export type ListEntryCountOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    guestId?: SortOrder
    addedByUserId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    note?: SortOrder
    createdVia?: SortOrder
    status?: SortOrder
    plusOne?: SortOrder
    bookingMethod?: SortOrder
    referralSource?: SortOrder
    groupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListEntryAvgOrderByAggregateInput = {
    groupSize?: SortOrder
  }

  export type ListEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    guestId?: SortOrder
    addedByUserId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    note?: SortOrder
    createdVia?: SortOrder
    status?: SortOrder
    plusOne?: SortOrder
    bookingMethod?: SortOrder
    referralSource?: SortOrder
    groupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListEntryMinOrderByAggregateInput = {
    id?: SortOrder
    listId?: SortOrder
    guestId?: SortOrder
    addedByUserId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    note?: SortOrder
    createdVia?: SortOrder
    status?: SortOrder
    plusOne?: SortOrder
    bookingMethod?: SortOrder
    referralSource?: SortOrder
    groupSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListEntrySumOrderByAggregateInput = {
    groupSize?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumCreatedViaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel> | $Enums.CreatedVia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedViaFilter<$PrismaModel>
    _max?: NestedEnumCreatedViaFilter<$PrismaModel>
  }

  export type EnumEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumEntryStatusFilter<$PrismaModel>
  }

  export type EnumBookingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMethod | EnumBookingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingMethodWithAggregatesFilter<$PrismaModel> | $Enums.BookingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingMethodFilter<$PrismaModel>
    _max?: NestedEnumBookingMethodFilter<$PrismaModel>
  }

  export type EnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ListEntryNullableScalarRelationFilter = {
    is?: ListEntryWhereInput | null
    isNot?: ListEntryWhereInput | null
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    listEntryId?: SortOrder
    issuedByUserId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    qrData?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    listEntryId?: SortOrder
    issuedByUserId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    qrData?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    listEntryId?: SortOrder
    issuedByUserId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    code?: SortOrder
    qrData?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumGateFilter<$PrismaModel = never> = {
    equals?: $Enums.Gate | EnumGateFieldRefInput<$PrismaModel>
    in?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    not?: NestedEnumGateFilter<$PrismaModel> | $Enums.Gate
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type CheckInCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    scannedByUserId?: SortOrder
    scannedAt?: SortOrder
    gate?: SortOrder
    ok?: SortOrder
    notes?: SortOrder
    arrivalTime?: SortOrder
    groupSize?: SortOrder
  }

  export type CheckInAvgOrderByAggregateInput = {
    groupSize?: SortOrder
  }

  export type CheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    scannedByUserId?: SortOrder
    scannedAt?: SortOrder
    gate?: SortOrder
    ok?: SortOrder
    notes?: SortOrder
    arrivalTime?: SortOrder
    groupSize?: SortOrder
  }

  export type CheckInMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    scannedByUserId?: SortOrder
    scannedAt?: SortOrder
    gate?: SortOrder
    ok?: SortOrder
    notes?: SortOrder
    arrivalTime?: SortOrder
    groupSize?: SortOrder
  }

  export type CheckInSumOrderByAggregateInput = {
    groupSize?: SortOrder
  }

  export type EnumGateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gate | EnumGateFieldRefInput<$PrismaModel>
    in?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    not?: NestedEnumGateWithAggregatesFilter<$PrismaModel> | $Enums.Gate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGateFilter<$PrismaModel>
    _max?: NestedEnumGateFilter<$PrismaModel>
  }

  export type InviteLinkCountOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    slug?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteLinkAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type InviteLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    slug?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteLinkMinOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    eventId?: SortOrder
    prProfileId?: SortOrder
    slug?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteLinkSumOrderByAggregateInput = {
    maxUses?: SortOrder
    uses?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ConsumptionCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsumptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ConsumptionMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsumptionMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    eventId?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsumptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FunnelTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    eventId?: SortOrder
    step?: SortOrder
    metadata?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    timestamp?: SortOrder
  }

  export type FunnelTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    eventId?: SortOrder
    step?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    timestamp?: SortOrder
  }

  export type FunnelTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    eventId?: SortOrder
    step?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    timestamp?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type TicketNullableScalarRelationFilter = {
    is?: TicketWhereInput | null
    isNot?: TicketWhereInput | null
  }

  export type EventFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    guestId?: SortOrder
    overallRating?: SortOrder
    musicRating?: SortOrder
    serviceRating?: SortOrder
    venueRating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    interests?: SortOrder
    createdAt?: SortOrder
  }

  export type EventFeedbackAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    musicRating?: SortOrder
    serviceRating?: SortOrder
    venueRating?: SortOrder
  }

  export type EventFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    guestId?: SortOrder
    overallRating?: SortOrder
    musicRating?: SortOrder
    serviceRating?: SortOrder
    venueRating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    createdAt?: SortOrder
  }

  export type EventFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    guestId?: SortOrder
    overallRating?: SortOrder
    musicRating?: SortOrder
    serviceRating?: SortOrder
    venueRating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    createdAt?: SortOrder
  }

  export type EventFeedbackSumOrderByAggregateInput = {
    overallRating?: SortOrder
    musicRating?: SortOrder
    serviceRating?: SortOrder
    venueRating?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EventNullableScalarRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type SecurityNoteCountOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    description?: SortOrder
    reportedByUserId?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    description?: SortOrder
    reportedByUserId?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityNoteMinOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    eventId?: SortOrder
    ticketId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    description?: SortOrder
    reportedByUserId?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type GuestScalarRelationFilter = {
    is?: GuestWhereInput
    isNot?: GuestWhereInput
  }

  export type CustomerPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    musicGenres?: SortOrder
    dressStyle?: SortOrder
    drinkPreferences?: SortOrder
    avgSpending?: SortOrder
    responseToPromo?: SortOrder
    socialEngagement?: SortOrder
    conversionScore?: SortOrder
    lifetimeValue?: SortOrder
    consents?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPreferencesAvgOrderByAggregateInput = {
    avgSpending?: SortOrder
    conversionScore?: SortOrder
    lifetimeValue?: SortOrder
  }

  export type CustomerPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    dressStyle?: SortOrder
    avgSpending?: SortOrder
    responseToPromo?: SortOrder
    socialEngagement?: SortOrder
    conversionScore?: SortOrder
    lifetimeValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    guestId?: SortOrder
    dressStyle?: SortOrder
    avgSpending?: SortOrder
    responseToPromo?: SortOrder
    socialEngagement?: SortOrder
    conversionScore?: SortOrder
    lifetimeValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPreferencesSumOrderByAggregateInput = {
    avgSpending?: SortOrder
    conversionScore?: SortOrder
    lifetimeValue?: SortOrder
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    organizationName?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationProfileAvgOrderByAggregateInput = {
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
  }

  export type OrganizationProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    organizationName?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    organizationName?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationProfileSumOrderByAggregateInput = {
    totalEvents?: SortOrder
    totalAttendees?: SortOrder
  }

  export type OrganizationProfileScalarRelationFilter = {
    is?: OrganizationProfileWhereInput
    isNot?: OrganizationProfileWhereInput
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumArtistTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistType | EnumArtistTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistTypeFilter<$PrismaModel> | $Enums.ArtistType
  }

  export type PerformanceListRelationFilter = {
    every?: PerformanceWhereInput
    some?: PerformanceWhereInput
    none?: PerformanceWhereInput
  }

  export type ArtistMediaListRelationFilter = {
    every?: ArtistMediaWhereInput
    some?: ArtistMediaWhereInput
    none?: ArtistMediaWhereInput
  }

  export type PerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    artistName?: SortOrder
    artistType?: SortOrder
    bio?: SortOrder
    genres?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    soundcloud?: SortOrder
    spotify?: SortOrder
    youtube?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalGigs?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistProfileAvgOrderByAggregateInput = {
    totalGigs?: SortOrder
    rating?: SortOrder
  }

  export type ArtistProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    artistName?: SortOrder
    artistType?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    soundcloud?: SortOrder
    spotify?: SortOrder
    youtube?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalGigs?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    artistName?: SortOrder
    artistType?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    soundcloud?: SortOrder
    spotify?: SortOrder
    youtube?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    verified?: SortOrder
    totalGigs?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistProfileSumOrderByAggregateInput = {
    totalGigs?: SortOrder
    rating?: SortOrder
  }

  export type EnumArtistTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistType | EnumArtistTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtistType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistTypeFilter<$PrismaModel>
    _max?: NestedEnumArtistTypeFilter<$PrismaModel>
  }

  export type ArtistProfileScalarRelationFilter = {
    is?: ArtistProfileWhereInput
    isNot?: ArtistProfileWhereInput
  }

  export type PerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    eventId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    venueName?: SortOrder
    city?: SortOrder
    description?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceAvgOrderByAggregateInput = {
    fee?: SortOrder
  }

  export type PerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    eventId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    venueName?: SortOrder
    city?: SortOrder
    description?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    eventId?: SortOrder
    eventName?: SortOrder
    eventDate?: SortOrder
    venueName?: SortOrder
    city?: SortOrder
    description?: SortOrder
    fee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceSumOrderByAggregateInput = {
    fee?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type ArtistMediaCountOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistMediaAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ArtistMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistMediaMinOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistMediaSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    provincia?: SortOrder
    city?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    interests?: SortOrder
    favoriteGenres?: SortOrder
    preferredVenues?: SortOrder
    tiktokHandle?: SortOrder
    spotifyUrl?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    isPublic?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
    verifiedBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    provincia?: SortOrder
    city?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    tiktokHandle?: SortOrder
    spotifyUrl?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    isPublic?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
    verifiedBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    provincia?: SortOrder
    city?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    tiktokHandle?: SortOrder
    spotifyUrl?: SortOrder
    whatsappNumber?: SortOrder
    telegramHandle?: SortOrder
    isPublic?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
    verifiedBadge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    followersCount?: SortOrder
    followingCount?: SortOrder
    postsCount?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type UserFollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type UserFollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeFilter<$PrismaModel> | $Enums.FeedItemType
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type FeedItemCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    eventId?: SortOrder
    visibility?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedItemAvgOrderByAggregateInput = {
    likesCount?: SortOrder
    commentsCount?: SortOrder
  }

  export type FeedItemMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    eventId?: SortOrder
    visibility?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedItemMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    eventId?: SortOrder
    visibility?: SortOrder
    likesCount?: SortOrder
    commentsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedItemSumOrderByAggregateInput = {
    likesCount?: SortOrder
    commentsCount?: SortOrder
  }

  export type EnumFeedItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedItemTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedItemTypeFilter<$PrismaModel>
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type FeedItemScalarRelationFilter = {
    is?: FeedItemWhereInput
    isNot?: FeedItemWhereInput
  }

  export type FeedLikeFeedItemIdUserIdCompoundUniqueInput = {
    feedItemId: string
    userId: string
  }

  export type FeedLikeCountOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedLikeMinOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedCommentCountOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedCommentMinOrderByAggregateInput = {
    id?: SortOrder
    feedItemId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type IdentityVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentFrontUrl?: SortOrder
    documentBackUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentityVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentFrontUrl?: SortOrder
    documentBackUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdentityVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    documentFrontUrl?: SortOrder
    documentBackUrl?: SortOrder
    selfieUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type UserPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    phoneVerifiedAt?: SortOrder
    otpCode?: SortOrder
    otpExpiresAt?: SortOrder
    otpAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneAvgOrderByAggregateInput = {
    otpAttempts?: SortOrder
  }

  export type UserPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    phoneVerifiedAt?: SortOrder
    otpCode?: SortOrder
    otpExpiresAt?: SortOrder
    otpAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    phoneVerified?: SortOrder
    phoneVerifiedAt?: SortOrder
    otpCode?: SortOrder
    otpExpiresAt?: SortOrder
    otpAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhoneSumOrderByAggregateInput = {
    otpAttempts?: SortOrder
  }

  export type UserConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyAcceptedAt?: SortOrder
    marketingOptIn?: SortOrder
    marketingOptInAt?: SortOrder
    newsletterOptIn?: SortOrder
    newsletterOptInAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyAcceptedAt?: SortOrder
    marketingOptIn?: SortOrder
    marketingOptInAt?: SortOrder
    newsletterOptIn?: SortOrder
    newsletterOptInAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    privacyAccepted?: SortOrder
    privacyAcceptedAt?: SortOrder
    marketingOptIn?: SortOrder
    marketingOptInAt?: SortOrder
    newsletterOptIn?: SortOrder
    newsletterOptInAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStep?: SortOrder
    step1Completed?: SortOrder
    step2Completed?: SortOrder
    step3Completed?: SortOrder
    onboardingComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressAvgOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type OnboardingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStep?: SortOrder
    step1Completed?: SortOrder
    step2Completed?: SortOrder
    step3Completed?: SortOrder
    onboardingComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStep?: SortOrder
    step1Completed?: SortOrder
    step2Completed?: SortOrder
    step3Completed?: SortOrder
    onboardingComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressSumOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckInCreateNestedManyWithoutScannedByInput = {
    create?: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput> | CheckInCreateWithoutScannedByInput[] | CheckInUncheckedCreateWithoutScannedByInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutScannedByInput | CheckInCreateOrConnectWithoutScannedByInput[]
    createMany?: CheckInCreateManyScannedByInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput> | InviteLinkCreateWithoutCreatedByInput[] | InviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatedByInput | InviteLinkCreateOrConnectWithoutCreatedByInput[]
    createMany?: InviteLinkCreateManyCreatedByInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type ListEntryCreateNestedManyWithoutAddedByInput = {
    create?: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput> | ListEntryCreateWithoutAddedByInput[] | ListEntryUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutAddedByInput | ListEntryCreateOrConnectWithoutAddedByInput[]
    createMany?: ListEntryCreateManyAddedByInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type PRProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutUserInput
    connect?: PRProfileWhereUniqueInput
  }

  export type SecurityNoteCreateNestedManyWithoutReportedByInput = {
    create?: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput> | SecurityNoteCreateWithoutReportedByInput[] | SecurityNoteUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutReportedByInput | SecurityNoteCreateOrConnectWithoutReportedByInput[]
    createMany?: SecurityNoteCreateManyReportedByInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutIssuedByInput = {
    create?: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput> | TicketCreateWithoutIssuedByInput[] | TicketUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutIssuedByInput | TicketCreateOrConnectWithoutIssuedByInput[]
    createMany?: TicketCreateManyIssuedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ClubCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput> | ClubCreateWithoutOwnerInput[] | ClubUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutOwnerInput | ClubCreateOrConnectWithoutOwnerInput[]
    createMany?: ClubCreateManyOwnerInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type OrganizationProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutUserInput
    connect?: OrganizationProfileWhereUniqueInput
  }

  export type ArtistProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutUserInput
    connect?: ArtistProfileWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FeedItemCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput> | FeedItemCreateWithoutAuthorInput[] | FeedItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutAuthorInput | FeedItemCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedItemCreateManyAuthorInputEnvelope
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
  }

  export type FeedLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput> | FeedLikeCreateWithoutUserInput[] | FeedLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutUserInput | FeedLikeCreateOrConnectWithoutUserInput[]
    createMany?: FeedLikeCreateManyUserInputEnvelope
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
  }

  export type FeedCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput> | FeedCommentCreateWithoutUserInput[] | FeedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutUserInput | FeedCommentCreateOrConnectWithoutUserInput[]
    createMany?: FeedCommentCreateManyUserInputEnvelope
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type IdentityVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput> | IdentityVerificationCreateWithoutUserInput[] | IdentityVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutUserInput | IdentityVerificationCreateOrConnectWithoutUserInput[]
    createMany?: IdentityVerificationCreateManyUserInputEnvelope
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
  }

  export type IdentityVerificationCreateNestedManyWithoutReviewerInput = {
    create?: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput> | IdentityVerificationCreateWithoutReviewerInput[] | IdentityVerificationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutReviewerInput | IdentityVerificationCreateOrConnectWithoutReviewerInput[]
    createMany?: IdentityVerificationCreateManyReviewerInputEnvelope
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
  }

  export type UserPhoneCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    connect?: UserPhoneWhereUniqueInput
  }

  export type UserConsentCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    connect?: UserConsentWhereUniqueInput
  }

  export type OnboardingProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CheckInUncheckedCreateNestedManyWithoutScannedByInput = {
    create?: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput> | CheckInCreateWithoutScannedByInput[] | CheckInUncheckedCreateWithoutScannedByInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutScannedByInput | CheckInCreateOrConnectWithoutScannedByInput[]
    createMany?: CheckInCreateManyScannedByInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput> | InviteLinkCreateWithoutCreatedByInput[] | InviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatedByInput | InviteLinkCreateOrConnectWithoutCreatedByInput[]
    createMany?: InviteLinkCreateManyCreatedByInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type ListEntryUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput> | ListEntryCreateWithoutAddedByInput[] | ListEntryUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutAddedByInput | ListEntryCreateOrConnectWithoutAddedByInput[]
    createMany?: ListEntryCreateManyAddedByInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type PRProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutUserInput
    connect?: PRProfileWhereUniqueInput
  }

  export type SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput> | SecurityNoteCreateWithoutReportedByInput[] | SecurityNoteUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutReportedByInput | SecurityNoteCreateOrConnectWithoutReportedByInput[]
    createMany?: SecurityNoteCreateManyReportedByInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutIssuedByInput = {
    create?: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput> | TicketCreateWithoutIssuedByInput[] | TicketUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutIssuedByInput | TicketCreateOrConnectWithoutIssuedByInput[]
    createMany?: TicketCreateManyIssuedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ClubUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput> | ClubCreateWithoutOwnerInput[] | ClubUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutOwnerInput | ClubCreateOrConnectWithoutOwnerInput[]
    createMany?: ClubCreateManyOwnerInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type OrganizationProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutUserInput
    connect?: OrganizationProfileWhereUniqueInput
  }

  export type ArtistProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutUserInput
    connect?: ArtistProfileWhereUniqueInput
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FeedItemUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput> | FeedItemCreateWithoutAuthorInput[] | FeedItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutAuthorInput | FeedItemCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedItemCreateManyAuthorInputEnvelope
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
  }

  export type FeedLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput> | FeedLikeCreateWithoutUserInput[] | FeedLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutUserInput | FeedLikeCreateOrConnectWithoutUserInput[]
    createMany?: FeedLikeCreateManyUserInputEnvelope
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
  }

  export type FeedCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput> | FeedCommentCreateWithoutUserInput[] | FeedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutUserInput | FeedCommentCreateOrConnectWithoutUserInput[]
    createMany?: FeedCommentCreateManyUserInputEnvelope
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type IdentityVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput> | IdentityVerificationCreateWithoutUserInput[] | IdentityVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutUserInput | IdentityVerificationCreateOrConnectWithoutUserInput[]
    createMany?: IdentityVerificationCreateManyUserInputEnvelope
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
  }

  export type IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput> | IdentityVerificationCreateWithoutReviewerInput[] | IdentityVerificationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutReviewerInput | IdentityVerificationCreateOrConnectWithoutReviewerInput[]
    createMany?: IdentityVerificationCreateManyReviewerInputEnvelope
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
  }

  export type UserPhoneUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    connect?: UserPhoneWhereUniqueInput
  }

  export type UserConsentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    connect?: UserConsentWhereUniqueInput
  }

  export type OnboardingProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckInUpdateManyWithoutScannedByNestedInput = {
    create?: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput> | CheckInCreateWithoutScannedByInput[] | CheckInUncheckedCreateWithoutScannedByInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutScannedByInput | CheckInCreateOrConnectWithoutScannedByInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutScannedByInput | CheckInUpsertWithWhereUniqueWithoutScannedByInput[]
    createMany?: CheckInCreateManyScannedByInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutScannedByInput | CheckInUpdateWithWhereUniqueWithoutScannedByInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutScannedByInput | CheckInUpdateManyWithWhereWithoutScannedByInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput> | InviteLinkCreateWithoutCreatedByInput[] | InviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatedByInput | InviteLinkCreateOrConnectWithoutCreatedByInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCreatedByInput | InviteLinkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InviteLinkCreateManyCreatedByInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCreatedByInput | InviteLinkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCreatedByInput | InviteLinkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type ListEntryUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput> | ListEntryCreateWithoutAddedByInput[] | ListEntryUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutAddedByInput | ListEntryCreateOrConnectWithoutAddedByInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutAddedByInput | ListEntryUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: ListEntryCreateManyAddedByInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutAddedByInput | ListEntryUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutAddedByInput | ListEntryUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type PRProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutUserInput
    upsert?: PRProfileUpsertWithoutUserInput
    disconnect?: PRProfileWhereInput | boolean
    delete?: PRProfileWhereInput | boolean
    connect?: PRProfileWhereUniqueInput
    update?: XOR<XOR<PRProfileUpdateToOneWithWhereWithoutUserInput, PRProfileUpdateWithoutUserInput>, PRProfileUncheckedUpdateWithoutUserInput>
  }

  export type SecurityNoteUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput> | SecurityNoteCreateWithoutReportedByInput[] | SecurityNoteUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutReportedByInput | SecurityNoteCreateOrConnectWithoutReportedByInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutReportedByInput | SecurityNoteUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: SecurityNoteCreateManyReportedByInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutReportedByInput | SecurityNoteUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutReportedByInput | SecurityNoteUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutIssuedByNestedInput = {
    create?: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput> | TicketCreateWithoutIssuedByInput[] | TicketUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutIssuedByInput | TicketCreateOrConnectWithoutIssuedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutIssuedByInput | TicketUpsertWithWhereUniqueWithoutIssuedByInput[]
    createMany?: TicketCreateManyIssuedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutIssuedByInput | TicketUpdateWithWhereUniqueWithoutIssuedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutIssuedByInput | TicketUpdateManyWithWhereWithoutIssuedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ClubUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput> | ClubCreateWithoutOwnerInput[] | ClubUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutOwnerInput | ClubCreateOrConnectWithoutOwnerInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutOwnerInput | ClubUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClubCreateManyOwnerInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutOwnerInput | ClubUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutOwnerInput | ClubUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type OrganizationProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutUserInput
    upsert?: OrganizationProfileUpsertWithoutUserInput
    disconnect?: OrganizationProfileWhereInput | boolean
    delete?: OrganizationProfileWhereInput | boolean
    connect?: OrganizationProfileWhereUniqueInput
    update?: XOR<XOR<OrganizationProfileUpdateToOneWithWhereWithoutUserInput, OrganizationProfileUpdateWithoutUserInput>, OrganizationProfileUncheckedUpdateWithoutUserInput>
  }

  export type ArtistProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutUserInput
    upsert?: ArtistProfileUpsertWithoutUserInput
    disconnect?: ArtistProfileWhereInput | boolean
    delete?: ArtistProfileWhereInput | boolean
    connect?: ArtistProfileWhereUniqueInput
    update?: XOR<XOR<ArtistProfileUpdateToOneWithWhereWithoutUserInput, ArtistProfileUpdateWithoutUserInput>, ArtistProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type FeedItemUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput> | FeedItemCreateWithoutAuthorInput[] | FeedItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutAuthorInput | FeedItemCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedItemUpsertWithWhereUniqueWithoutAuthorInput | FeedItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedItemCreateManyAuthorInputEnvelope
    set?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    disconnect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    delete?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    update?: FeedItemUpdateWithWhereUniqueWithoutAuthorInput | FeedItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedItemUpdateManyWithWhereWithoutAuthorInput | FeedItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
  }

  export type FeedLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput> | FeedLikeCreateWithoutUserInput[] | FeedLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutUserInput | FeedLikeCreateOrConnectWithoutUserInput[]
    upsert?: FeedLikeUpsertWithWhereUniqueWithoutUserInput | FeedLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedLikeCreateManyUserInputEnvelope
    set?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    disconnect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    delete?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    update?: FeedLikeUpdateWithWhereUniqueWithoutUserInput | FeedLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedLikeUpdateManyWithWhereWithoutUserInput | FeedLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
  }

  export type FeedCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput> | FeedCommentCreateWithoutUserInput[] | FeedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutUserInput | FeedCommentCreateOrConnectWithoutUserInput[]
    upsert?: FeedCommentUpsertWithWhereUniqueWithoutUserInput | FeedCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedCommentCreateManyUserInputEnvelope
    set?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    disconnect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    delete?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    update?: FeedCommentUpdateWithWhereUniqueWithoutUserInput | FeedCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedCommentUpdateManyWithWhereWithoutUserInput | FeedCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type IdentityVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput> | IdentityVerificationCreateWithoutUserInput[] | IdentityVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutUserInput | IdentityVerificationCreateOrConnectWithoutUserInput[]
    upsert?: IdentityVerificationUpsertWithWhereUniqueWithoutUserInput | IdentityVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdentityVerificationCreateManyUserInputEnvelope
    set?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    disconnect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    delete?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    update?: IdentityVerificationUpdateWithWhereUniqueWithoutUserInput | IdentityVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdentityVerificationUpdateManyWithWhereWithoutUserInput | IdentityVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
  }

  export type IdentityVerificationUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput> | IdentityVerificationCreateWithoutReviewerInput[] | IdentityVerificationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutReviewerInput | IdentityVerificationCreateOrConnectWithoutReviewerInput[]
    upsert?: IdentityVerificationUpsertWithWhereUniqueWithoutReviewerInput | IdentityVerificationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: IdentityVerificationCreateManyReviewerInputEnvelope
    set?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    disconnect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    delete?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    update?: IdentityVerificationUpdateWithWhereUniqueWithoutReviewerInput | IdentityVerificationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: IdentityVerificationUpdateManyWithWhereWithoutReviewerInput | IdentityVerificationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
  }

  export type UserPhoneUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    upsert?: UserPhoneUpsertWithoutUserInput
    disconnect?: UserPhoneWhereInput | boolean
    delete?: UserPhoneWhereInput | boolean
    connect?: UserPhoneWhereUniqueInput
    update?: XOR<XOR<UserPhoneUpdateToOneWithWhereWithoutUserInput, UserPhoneUpdateWithoutUserInput>, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    upsert?: UserConsentUpsertWithoutUserInput
    disconnect?: UserConsentWhereInput | boolean
    delete?: UserConsentWhereInput | boolean
    connect?: UserConsentWhereUniqueInput
    update?: XOR<XOR<UserConsentUpdateToOneWithWhereWithoutUserInput, UserConsentUpdateWithoutUserInput>, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CheckInUncheckedUpdateManyWithoutScannedByNestedInput = {
    create?: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput> | CheckInCreateWithoutScannedByInput[] | CheckInUncheckedCreateWithoutScannedByInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutScannedByInput | CheckInCreateOrConnectWithoutScannedByInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutScannedByInput | CheckInUpsertWithWhereUniqueWithoutScannedByInput[]
    createMany?: CheckInCreateManyScannedByInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutScannedByInput | CheckInUpdateWithWhereUniqueWithoutScannedByInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutScannedByInput | CheckInUpdateManyWithWhereWithoutScannedByInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput> | InviteLinkCreateWithoutCreatedByInput[] | InviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutCreatedByInput | InviteLinkCreateOrConnectWithoutCreatedByInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutCreatedByInput | InviteLinkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InviteLinkCreateManyCreatedByInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutCreatedByInput | InviteLinkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutCreatedByInput | InviteLinkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type ListEntryUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput> | ListEntryCreateWithoutAddedByInput[] | ListEntryUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutAddedByInput | ListEntryCreateOrConnectWithoutAddedByInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutAddedByInput | ListEntryUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: ListEntryCreateManyAddedByInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutAddedByInput | ListEntryUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutAddedByInput | ListEntryUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type PRProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutUserInput
    upsert?: PRProfileUpsertWithoutUserInput
    disconnect?: PRProfileWhereInput | boolean
    delete?: PRProfileWhereInput | boolean
    connect?: PRProfileWhereUniqueInput
    update?: XOR<XOR<PRProfileUpdateToOneWithWhereWithoutUserInput, PRProfileUpdateWithoutUserInput>, PRProfileUncheckedUpdateWithoutUserInput>
  }

  export type SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput> | SecurityNoteCreateWithoutReportedByInput[] | SecurityNoteUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutReportedByInput | SecurityNoteCreateOrConnectWithoutReportedByInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutReportedByInput | SecurityNoteUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: SecurityNoteCreateManyReportedByInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutReportedByInput | SecurityNoteUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutReportedByInput | SecurityNoteUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutIssuedByNestedInput = {
    create?: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput> | TicketCreateWithoutIssuedByInput[] | TicketUncheckedCreateWithoutIssuedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutIssuedByInput | TicketCreateOrConnectWithoutIssuedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutIssuedByInput | TicketUpsertWithWhereUniqueWithoutIssuedByInput[]
    createMany?: TicketCreateManyIssuedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutIssuedByInput | TicketUpdateWithWhereUniqueWithoutIssuedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutIssuedByInput | TicketUpdateManyWithWhereWithoutIssuedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ClubUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput> | ClubCreateWithoutOwnerInput[] | ClubUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutOwnerInput | ClubCreateOrConnectWithoutOwnerInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutOwnerInput | ClubUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClubCreateManyOwnerInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutOwnerInput | ClubUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutOwnerInput | ClubUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutUserInput
    upsert?: OrganizationProfileUpsertWithoutUserInput
    disconnect?: OrganizationProfileWhereInput | boolean
    delete?: OrganizationProfileWhereInput | boolean
    connect?: OrganizationProfileWhereUniqueInput
    update?: XOR<XOR<OrganizationProfileUpdateToOneWithWhereWithoutUserInput, OrganizationProfileUpdateWithoutUserInput>, OrganizationProfileUncheckedUpdateWithoutUserInput>
  }

  export type ArtistProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutUserInput
    upsert?: ArtistProfileUpsertWithoutUserInput
    disconnect?: ArtistProfileWhereInput | boolean
    delete?: ArtistProfileWhereInput | boolean
    connect?: ArtistProfileWhereUniqueInput
    update?: XOR<XOR<ArtistProfileUpdateToOneWithWhereWithoutUserInput, ArtistProfileUpdateWithoutUserInput>, ArtistProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type FeedItemUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput> | FeedItemCreateWithoutAuthorInput[] | FeedItemUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedItemCreateOrConnectWithoutAuthorInput | FeedItemCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedItemUpsertWithWhereUniqueWithoutAuthorInput | FeedItemUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedItemCreateManyAuthorInputEnvelope
    set?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    disconnect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    delete?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    connect?: FeedItemWhereUniqueInput | FeedItemWhereUniqueInput[]
    update?: FeedItemUpdateWithWhereUniqueWithoutAuthorInput | FeedItemUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedItemUpdateManyWithWhereWithoutAuthorInput | FeedItemUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
  }

  export type FeedLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput> | FeedLikeCreateWithoutUserInput[] | FeedLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutUserInput | FeedLikeCreateOrConnectWithoutUserInput[]
    upsert?: FeedLikeUpsertWithWhereUniqueWithoutUserInput | FeedLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedLikeCreateManyUserInputEnvelope
    set?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    disconnect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    delete?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    update?: FeedLikeUpdateWithWhereUniqueWithoutUserInput | FeedLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedLikeUpdateManyWithWhereWithoutUserInput | FeedLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
  }

  export type FeedCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput> | FeedCommentCreateWithoutUserInput[] | FeedCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutUserInput | FeedCommentCreateOrConnectWithoutUserInput[]
    upsert?: FeedCommentUpsertWithWhereUniqueWithoutUserInput | FeedCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedCommentCreateManyUserInputEnvelope
    set?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    disconnect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    delete?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    update?: FeedCommentUpdateWithWhereUniqueWithoutUserInput | FeedCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedCommentUpdateManyWithWhereWithoutUserInput | FeedCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput> | IdentityVerificationCreateWithoutUserInput[] | IdentityVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutUserInput | IdentityVerificationCreateOrConnectWithoutUserInput[]
    upsert?: IdentityVerificationUpsertWithWhereUniqueWithoutUserInput | IdentityVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdentityVerificationCreateManyUserInputEnvelope
    set?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    disconnect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    delete?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    update?: IdentityVerificationUpdateWithWhereUniqueWithoutUserInput | IdentityVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdentityVerificationUpdateManyWithWhereWithoutUserInput | IdentityVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
  }

  export type IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput> | IdentityVerificationCreateWithoutReviewerInput[] | IdentityVerificationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: IdentityVerificationCreateOrConnectWithoutReviewerInput | IdentityVerificationCreateOrConnectWithoutReviewerInput[]
    upsert?: IdentityVerificationUpsertWithWhereUniqueWithoutReviewerInput | IdentityVerificationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: IdentityVerificationCreateManyReviewerInputEnvelope
    set?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    disconnect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    delete?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    connect?: IdentityVerificationWhereUniqueInput | IdentityVerificationWhereUniqueInput[]
    update?: IdentityVerificationUpdateWithWhereUniqueWithoutReviewerInput | IdentityVerificationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: IdentityVerificationUpdateManyWithWhereWithoutReviewerInput | IdentityVerificationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
  }

  export type UserPhoneUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    upsert?: UserPhoneUpsertWithoutUserInput
    disconnect?: UserPhoneWhereInput | boolean
    delete?: UserPhoneWhereInput | boolean
    connect?: UserPhoneWhereUniqueInput
    update?: XOR<XOR<UserPhoneUpdateToOneWithWhereWithoutUserInput, UserPhoneUpdateWithoutUserInput>, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput
    upsert?: UserConsentUpsertWithoutUserInput
    disconnect?: UserConsentWhereInput | boolean
    delete?: UserConsentWhereInput | boolean
    connect?: UserConsentWhereUniqueInput
    update?: XOR<XOR<UserConsentUpdateToOneWithWhereWithoutUserInput, UserConsentUpdateWithoutUserInput>, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type ClubCreategalleryInput = {
    set: string[]
  }

  export type ClubCreateamenitiesInput = {
    set: string[]
  }

  export type ClubCreatemusicGenresInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutClubsOwnedInput = {
    create?: XOR<UserCreateWithoutClubsOwnedInput, UserUncheckedCreateWithoutClubsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubsOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedManyWithoutClubInput = {
    create?: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput> | VenueCreateWithoutClubInput[] | VenueUncheckedCreateWithoutClubInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutClubInput | VenueCreateOrConnectWithoutClubInput[]
    createMany?: VenueCreateManyClubInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput> | VenueCreateWithoutClubInput[] | VenueUncheckedCreateWithoutClubInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutClubInput | VenueCreateOrConnectWithoutClubInput[]
    createMany?: VenueCreateManyClubInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type EnumClubTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClubType
  }

  export type ClubUpdategalleryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClubUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClubUpdatemusicGenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutClubsOwnedNestedInput = {
    create?: XOR<UserCreateWithoutClubsOwnedInput, UserUncheckedCreateWithoutClubsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubsOwnedInput
    upsert?: UserUpsertWithoutClubsOwnedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClubsOwnedInput, UserUpdateWithoutClubsOwnedInput>, UserUncheckedUpdateWithoutClubsOwnedInput>
  }

  export type VenueUpdateManyWithoutClubNestedInput = {
    create?: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput> | VenueCreateWithoutClubInput[] | VenueUncheckedCreateWithoutClubInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutClubInput | VenueCreateOrConnectWithoutClubInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutClubInput | VenueUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: VenueCreateManyClubInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutClubInput | VenueUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutClubInput | VenueUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput> | VenueCreateWithoutClubInput[] | VenueUncheckedCreateWithoutClubInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutClubInput | VenueCreateOrConnectWithoutClubInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutClubInput | VenueUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: VenueCreateManyClubInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutClubInput | VenueUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutClubInput | VenueUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type ClubCreateNestedOneWithoutVenuesInput = {
    create?: XOR<ClubCreateWithoutVenuesInput, ClubUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: ClubCreateOrConnectWithoutVenuesInput
    connect?: ClubWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ClubUpdateOneWithoutVenuesNestedInput = {
    create?: XOR<ClubCreateWithoutVenuesInput, ClubUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: ClubCreateOrConnectWithoutVenuesInput
    upsert?: ClubUpsertWithoutVenuesInput
    disconnect?: ClubWhereInput | boolean
    delete?: ClubWhereInput | boolean
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutVenuesInput, ClubUpdateWithoutVenuesInput>, ClubUncheckedUpdateWithoutVenuesInput>
  }

  export type EventUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type AssignmentCreateNestedManyWithoutEventInput = {
    create?: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput> | AssignmentCreateWithoutEventInput[] | AssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEventInput | AssignmentCreateOrConnectWithoutEventInput[]
    createMany?: AssignmentCreateManyEventInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ConsumptionCreateNestedManyWithoutEventInput = {
    create?: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput> | ConsumptionCreateWithoutEventInput[] | ConsumptionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutEventInput | ConsumptionCreateOrConnectWithoutEventInput[]
    createMany?: ConsumptionCreateManyEventInputEnvelope
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
  }

  export type EventFeedbackCreateNestedManyWithoutEventInput = {
    create?: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput> | EventFeedbackCreateWithoutEventInput[] | EventFeedbackUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutEventInput | EventFeedbackCreateOrConnectWithoutEventInput[]
    createMany?: EventFeedbackCreateManyEventInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEventsCreatedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutEventsInput = {
    create?: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEventsInput
    connect?: VenueWhereUniqueInput
  }

  export type FunnelTrackingCreateNestedManyWithoutEventInput = {
    create?: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput> | FunnelTrackingCreateWithoutEventInput[] | FunnelTrackingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FunnelTrackingCreateOrConnectWithoutEventInput | FunnelTrackingCreateOrConnectWithoutEventInput[]
    createMany?: FunnelTrackingCreateManyEventInputEnvelope
    connect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutEventInput = {
    create?: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput> | InviteLinkCreateWithoutEventInput[] | InviteLinkUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutEventInput | InviteLinkCreateOrConnectWithoutEventInput[]
    createMany?: InviteLinkCreateManyEventInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type ListCreateNestedManyWithoutEventInput = {
    create?: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput> | ListCreateWithoutEventInput[] | ListUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEventInput | ListCreateOrConnectWithoutEventInput[]
    createMany?: ListCreateManyEventInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SecurityNoteCreateNestedManyWithoutEventInput = {
    create?: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput> | SecurityNoteCreateWithoutEventInput[] | SecurityNoteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutEventInput | SecurityNoteCreateOrConnectWithoutEventInput[]
    createMany?: SecurityNoteCreateManyEventInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput> | AssignmentCreateWithoutEventInput[] | AssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEventInput | AssignmentCreateOrConnectWithoutEventInput[]
    createMany?: AssignmentCreateManyEventInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ConsumptionUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput> | ConsumptionCreateWithoutEventInput[] | ConsumptionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutEventInput | ConsumptionCreateOrConnectWithoutEventInput[]
    createMany?: ConsumptionCreateManyEventInputEnvelope
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
  }

  export type EventFeedbackUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput> | EventFeedbackCreateWithoutEventInput[] | EventFeedbackUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutEventInput | EventFeedbackCreateOrConnectWithoutEventInput[]
    createMany?: EventFeedbackCreateManyEventInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type FunnelTrackingUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput> | FunnelTrackingCreateWithoutEventInput[] | FunnelTrackingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FunnelTrackingCreateOrConnectWithoutEventInput | FunnelTrackingCreateOrConnectWithoutEventInput[]
    createMany?: FunnelTrackingCreateManyEventInputEnvelope
    connect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput> | InviteLinkCreateWithoutEventInput[] | InviteLinkUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutEventInput | InviteLinkCreateOrConnectWithoutEventInput[]
    createMany?: InviteLinkCreateManyEventInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type ListUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput> | ListCreateWithoutEventInput[] | ListUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEventInput | ListCreateOrConnectWithoutEventInput[]
    createMany?: ListCreateManyEventInputEnvelope
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
  }

  export type SecurityNoteUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput> | SecurityNoteCreateWithoutEventInput[] | SecurityNoteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutEventInput | SecurityNoteCreateOrConnectWithoutEventInput[]
    createMany?: SecurityNoteCreateManyEventInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus
  }

  export type AssignmentUpdateManyWithoutEventNestedInput = {
    create?: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput> | AssignmentCreateWithoutEventInput[] | AssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEventInput | AssignmentCreateOrConnectWithoutEventInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutEventInput | AssignmentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AssignmentCreateManyEventInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutEventInput | AssignmentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutEventInput | AssignmentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ConsumptionUpdateManyWithoutEventNestedInput = {
    create?: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput> | ConsumptionCreateWithoutEventInput[] | ConsumptionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutEventInput | ConsumptionCreateOrConnectWithoutEventInput[]
    upsert?: ConsumptionUpsertWithWhereUniqueWithoutEventInput | ConsumptionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ConsumptionCreateManyEventInputEnvelope
    set?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    disconnect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    delete?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    update?: ConsumptionUpdateWithWhereUniqueWithoutEventInput | ConsumptionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ConsumptionUpdateManyWithWhereWithoutEventInput | ConsumptionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
  }

  export type EventFeedbackUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput> | EventFeedbackCreateWithoutEventInput[] | EventFeedbackUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutEventInput | EventFeedbackCreateOrConnectWithoutEventInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutEventInput | EventFeedbackUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventFeedbackCreateManyEventInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutEventInput | EventFeedbackUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutEventInput | EventFeedbackUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEventsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    upsert?: UserUpsertWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsCreatedInput, UserUpdateWithoutEventsCreatedInput>, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type VenueUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEventsInput
    upsert?: VenueUpsertWithoutEventsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutEventsInput, VenueUpdateWithoutEventsInput>, VenueUncheckedUpdateWithoutEventsInput>
  }

  export type FunnelTrackingUpdateManyWithoutEventNestedInput = {
    create?: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput> | FunnelTrackingCreateWithoutEventInput[] | FunnelTrackingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FunnelTrackingCreateOrConnectWithoutEventInput | FunnelTrackingCreateOrConnectWithoutEventInput[]
    upsert?: FunnelTrackingUpsertWithWhereUniqueWithoutEventInput | FunnelTrackingUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: FunnelTrackingCreateManyEventInputEnvelope
    set?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    disconnect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    delete?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    connect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    update?: FunnelTrackingUpdateWithWhereUniqueWithoutEventInput | FunnelTrackingUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: FunnelTrackingUpdateManyWithWhereWithoutEventInput | FunnelTrackingUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: FunnelTrackingScalarWhereInput | FunnelTrackingScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutEventNestedInput = {
    create?: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput> | InviteLinkCreateWithoutEventInput[] | InviteLinkUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutEventInput | InviteLinkCreateOrConnectWithoutEventInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutEventInput | InviteLinkUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InviteLinkCreateManyEventInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutEventInput | InviteLinkUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutEventInput | InviteLinkUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type ListUpdateManyWithoutEventNestedInput = {
    create?: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput> | ListCreateWithoutEventInput[] | ListUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEventInput | ListCreateOrConnectWithoutEventInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutEventInput | ListUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ListCreateManyEventInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutEventInput | ListUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ListUpdateManyWithWhereWithoutEventInput | ListUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SecurityNoteUpdateManyWithoutEventNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput> | SecurityNoteCreateWithoutEventInput[] | SecurityNoteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutEventInput | SecurityNoteCreateOrConnectWithoutEventInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutEventInput | SecurityNoteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SecurityNoteCreateManyEventInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutEventInput | SecurityNoteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutEventInput | SecurityNoteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput> | AssignmentCreateWithoutEventInput[] | AssignmentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEventInput | AssignmentCreateOrConnectWithoutEventInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutEventInput | AssignmentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AssignmentCreateManyEventInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutEventInput | AssignmentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutEventInput | AssignmentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ConsumptionUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput> | ConsumptionCreateWithoutEventInput[] | ConsumptionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutEventInput | ConsumptionCreateOrConnectWithoutEventInput[]
    upsert?: ConsumptionUpsertWithWhereUniqueWithoutEventInput | ConsumptionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ConsumptionCreateManyEventInputEnvelope
    set?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    disconnect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    delete?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    update?: ConsumptionUpdateWithWhereUniqueWithoutEventInput | ConsumptionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ConsumptionUpdateManyWithWhereWithoutEventInput | ConsumptionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
  }

  export type EventFeedbackUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput> | EventFeedbackCreateWithoutEventInput[] | EventFeedbackUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutEventInput | EventFeedbackCreateOrConnectWithoutEventInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutEventInput | EventFeedbackUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventFeedbackCreateManyEventInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutEventInput | EventFeedbackUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutEventInput | EventFeedbackUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput> | FunnelTrackingCreateWithoutEventInput[] | FunnelTrackingUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FunnelTrackingCreateOrConnectWithoutEventInput | FunnelTrackingCreateOrConnectWithoutEventInput[]
    upsert?: FunnelTrackingUpsertWithWhereUniqueWithoutEventInput | FunnelTrackingUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: FunnelTrackingCreateManyEventInputEnvelope
    set?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    disconnect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    delete?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    connect?: FunnelTrackingWhereUniqueInput | FunnelTrackingWhereUniqueInput[]
    update?: FunnelTrackingUpdateWithWhereUniqueWithoutEventInput | FunnelTrackingUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: FunnelTrackingUpdateManyWithWhereWithoutEventInput | FunnelTrackingUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: FunnelTrackingScalarWhereInput | FunnelTrackingScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput> | InviteLinkCreateWithoutEventInput[] | InviteLinkUncheckedCreateWithoutEventInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutEventInput | InviteLinkCreateOrConnectWithoutEventInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutEventInput | InviteLinkUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: InviteLinkCreateManyEventInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutEventInput | InviteLinkUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutEventInput | InviteLinkUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type ListUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput> | ListCreateWithoutEventInput[] | ListUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ListCreateOrConnectWithoutEventInput | ListCreateOrConnectWithoutEventInput[]
    upsert?: ListUpsertWithWhereUniqueWithoutEventInput | ListUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ListCreateManyEventInputEnvelope
    set?: ListWhereUniqueInput | ListWhereUniqueInput[]
    disconnect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    delete?: ListWhereUniqueInput | ListWhereUniqueInput[]
    connect?: ListWhereUniqueInput | ListWhereUniqueInput[]
    update?: ListUpdateWithWhereUniqueWithoutEventInput | ListUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ListUpdateManyWithWhereWithoutEventInput | ListUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ListScalarWhereInput | ListScalarWhereInput[]
  }

  export type SecurityNoteUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput> | SecurityNoteCreateWithoutEventInput[] | SecurityNoteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutEventInput | SecurityNoteCreateOrConnectWithoutEventInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutEventInput | SecurityNoteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SecurityNoteCreateManyEventInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutEventInput | SecurityNoteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutEventInput | SecurityNoteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type AssignmentCreateNestedManyWithoutPrProfileInput = {
    create?: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput> | AssignmentCreateWithoutPrProfileInput[] | AssignmentUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutPrProfileInput | AssignmentCreateOrConnectWithoutPrProfileInput[]
    createMany?: AssignmentCreateManyPrProfileInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type InviteLinkCreateNestedManyWithoutPrProfileInput = {
    create?: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput> | InviteLinkCreateWithoutPrProfileInput[] | InviteLinkUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutPrProfileInput | InviteLinkCreateOrConnectWithoutPrProfileInput[]
    createMany?: InviteLinkCreateManyPrProfileInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPrProfileInput = {
    create?: XOR<UserCreateWithoutPrProfileInput, UserUncheckedCreateWithoutPrProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AssignmentUncheckedCreateNestedManyWithoutPrProfileInput = {
    create?: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput> | AssignmentCreateWithoutPrProfileInput[] | AssignmentUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutPrProfileInput | AssignmentCreateOrConnectWithoutPrProfileInput[]
    createMany?: AssignmentCreateManyPrProfileInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type InviteLinkUncheckedCreateNestedManyWithoutPrProfileInput = {
    create?: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput> | InviteLinkCreateWithoutPrProfileInput[] | InviteLinkUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutPrProfileInput | InviteLinkCreateOrConnectWithoutPrProfileInput[]
    createMany?: InviteLinkCreateManyPrProfileInputEnvelope
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
  }

  export type AssignmentUpdateManyWithoutPrProfileNestedInput = {
    create?: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput> | AssignmentCreateWithoutPrProfileInput[] | AssignmentUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutPrProfileInput | AssignmentCreateOrConnectWithoutPrProfileInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutPrProfileInput | AssignmentUpsertWithWhereUniqueWithoutPrProfileInput[]
    createMany?: AssignmentCreateManyPrProfileInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutPrProfileInput | AssignmentUpdateWithWhereUniqueWithoutPrProfileInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutPrProfileInput | AssignmentUpdateManyWithWhereWithoutPrProfileInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type InviteLinkUpdateManyWithoutPrProfileNestedInput = {
    create?: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput> | InviteLinkCreateWithoutPrProfileInput[] | InviteLinkUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutPrProfileInput | InviteLinkCreateOrConnectWithoutPrProfileInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutPrProfileInput | InviteLinkUpsertWithWhereUniqueWithoutPrProfileInput[]
    createMany?: InviteLinkCreateManyPrProfileInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutPrProfileInput | InviteLinkUpdateWithWhereUniqueWithoutPrProfileInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutPrProfileInput | InviteLinkUpdateManyWithWhereWithoutPrProfileInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPrProfileNestedInput = {
    create?: XOR<UserCreateWithoutPrProfileInput, UserUncheckedCreateWithoutPrProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrProfileInput
    upsert?: UserUpsertWithoutPrProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrProfileInput, UserUpdateWithoutPrProfileInput>, UserUncheckedUpdateWithoutPrProfileInput>
  }

  export type AssignmentUncheckedUpdateManyWithoutPrProfileNestedInput = {
    create?: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput> | AssignmentCreateWithoutPrProfileInput[] | AssignmentUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutPrProfileInput | AssignmentCreateOrConnectWithoutPrProfileInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutPrProfileInput | AssignmentUpsertWithWhereUniqueWithoutPrProfileInput[]
    createMany?: AssignmentCreateManyPrProfileInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutPrProfileInput | AssignmentUpdateWithWhereUniqueWithoutPrProfileInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutPrProfileInput | AssignmentUpdateManyWithWhereWithoutPrProfileInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type InviteLinkUncheckedUpdateManyWithoutPrProfileNestedInput = {
    create?: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput> | InviteLinkCreateWithoutPrProfileInput[] | InviteLinkUncheckedCreateWithoutPrProfileInput[]
    connectOrCreate?: InviteLinkCreateOrConnectWithoutPrProfileInput | InviteLinkCreateOrConnectWithoutPrProfileInput[]
    upsert?: InviteLinkUpsertWithWhereUniqueWithoutPrProfileInput | InviteLinkUpsertWithWhereUniqueWithoutPrProfileInput[]
    createMany?: InviteLinkCreateManyPrProfileInputEnvelope
    set?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    disconnect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    delete?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    connect?: InviteLinkWhereUniqueInput | InviteLinkWhereUniqueInput[]
    update?: InviteLinkUpdateWithWhereUniqueWithoutPrProfileInput | InviteLinkUpdateWithWhereUniqueWithoutPrProfileInput[]
    updateMany?: InviteLinkUpdateManyWithWhereWithoutPrProfileInput | InviteLinkUpdateManyWithWhereWithoutPrProfileInput[]
    deleteMany?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<EventCreateWithoutAssignmentsInput, EventUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EventCreateOrConnectWithoutAssignmentsInput
    connect?: EventWhereUniqueInput
  }

  export type PRProfileCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<PRProfileCreateWithoutAssignmentsInput, PRProfileUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutAssignmentsInput
    connect?: PRProfileWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<EventCreateWithoutAssignmentsInput, EventUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EventCreateOrConnectWithoutAssignmentsInput
    upsert?: EventUpsertWithoutAssignmentsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutAssignmentsInput, EventUpdateWithoutAssignmentsInput>, EventUncheckedUpdateWithoutAssignmentsInput>
  }

  export type PRProfileUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<PRProfileCreateWithoutAssignmentsInput, PRProfileUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutAssignmentsInput
    upsert?: PRProfileUpsertWithoutAssignmentsInput
    connect?: PRProfileWhereUniqueInput
    update?: XOR<XOR<PRProfileUpdateToOneWithWhereWithoutAssignmentsInput, PRProfileUpdateWithoutAssignmentsInput>, PRProfileUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ListEntryCreateNestedManyWithoutListInput = {
    create?: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput> | ListEntryCreateWithoutListInput[] | ListEntryUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListInput | ListEntryCreateOrConnectWithoutListInput[]
    createMany?: ListEntryCreateManyListInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type EventCreateNestedOneWithoutListsInput = {
    create?: XOR<EventCreateWithoutListsInput, EventUncheckedCreateWithoutListsInput>
    connectOrCreate?: EventCreateOrConnectWithoutListsInput
    connect?: EventWhereUniqueInput
  }

  export type ListEntryUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput> | ListEntryCreateWithoutListInput[] | ListEntryUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListInput | ListEntryCreateOrConnectWithoutListInput[]
    createMany?: ListEntryCreateManyListInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type EnumListTypeFieldUpdateOperationsInput = {
    set?: $Enums.ListType
  }

  export type ListEntryUpdateManyWithoutListNestedInput = {
    create?: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput> | ListEntryCreateWithoutListInput[] | ListEntryUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListInput | ListEntryCreateOrConnectWithoutListInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutListInput | ListEntryUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListEntryCreateManyListInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutListInput | ListEntryUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutListInput | ListEntryUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type EventUpdateOneRequiredWithoutListsNestedInput = {
    create?: XOR<EventCreateWithoutListsInput, EventUncheckedCreateWithoutListsInput>
    connectOrCreate?: EventCreateOrConnectWithoutListsInput
    upsert?: EventUpsertWithoutListsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutListsInput, EventUpdateWithoutListsInput>, EventUncheckedUpdateWithoutListsInput>
  }

  export type ListEntryUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput> | ListEntryCreateWithoutListInput[] | ListEntryUncheckedCreateWithoutListInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutListInput | ListEntryCreateOrConnectWithoutListInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutListInput | ListEntryUpsertWithWhereUniqueWithoutListInput[]
    createMany?: ListEntryCreateManyListInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutListInput | ListEntryUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutListInput | ListEntryUpdateManyWithWhereWithoutListInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type CustomerPreferencesCreateNestedOneWithoutGuestInput = {
    create?: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
    connectOrCreate?: CustomerPreferencesCreateOrConnectWithoutGuestInput
    connect?: CustomerPreferencesWhereUniqueInput
  }

  export type EventFeedbackCreateNestedManyWithoutGuestInput = {
    create?: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput> | EventFeedbackCreateWithoutGuestInput[] | EventFeedbackUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutGuestInput | EventFeedbackCreateOrConnectWithoutGuestInput[]
    createMany?: EventFeedbackCreateManyGuestInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type ListEntryCreateNestedManyWithoutGuestInput = {
    create?: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput> | ListEntryCreateWithoutGuestInput[] | ListEntryUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutGuestInput | ListEntryCreateOrConnectWithoutGuestInput[]
    createMany?: ListEntryCreateManyGuestInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type SecurityNoteCreateNestedManyWithoutGuestInput = {
    create?: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput> | SecurityNoteCreateWithoutGuestInput[] | SecurityNoteUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutGuestInput | SecurityNoteCreateOrConnectWithoutGuestInput[]
    createMany?: SecurityNoteCreateManyGuestInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutGuestInput = {
    create?: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput> | TicketCreateWithoutGuestInput[] | TicketUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutGuestInput | TicketCreateOrConnectWithoutGuestInput[]
    createMany?: TicketCreateManyGuestInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput = {
    create?: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
    connectOrCreate?: CustomerPreferencesCreateOrConnectWithoutGuestInput
    connect?: CustomerPreferencesWhereUniqueInput
  }

  export type EventFeedbackUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput> | EventFeedbackCreateWithoutGuestInput[] | EventFeedbackUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutGuestInput | EventFeedbackCreateOrConnectWithoutGuestInput[]
    createMany?: EventFeedbackCreateManyGuestInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type ListEntryUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput> | ListEntryCreateWithoutGuestInput[] | ListEntryUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutGuestInput | ListEntryCreateOrConnectWithoutGuestInput[]
    createMany?: ListEntryCreateManyGuestInputEnvelope
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
  }

  export type SecurityNoteUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput> | SecurityNoteCreateWithoutGuestInput[] | SecurityNoteUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutGuestInput | SecurityNoteCreateOrConnectWithoutGuestInput[]
    createMany?: SecurityNoteCreateManyGuestInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput> | TicketCreateWithoutGuestInput[] | TicketUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutGuestInput | TicketCreateOrConnectWithoutGuestInput[]
    createMany?: TicketCreateManyGuestInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCustomerSegmentFieldUpdateOperationsInput = {
    set?: $Enums.CustomerSegment
  }

  export type CustomerPreferencesUpdateOneWithoutGuestNestedInput = {
    create?: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
    connectOrCreate?: CustomerPreferencesCreateOrConnectWithoutGuestInput
    upsert?: CustomerPreferencesUpsertWithoutGuestInput
    disconnect?: CustomerPreferencesWhereInput | boolean
    delete?: CustomerPreferencesWhereInput | boolean
    connect?: CustomerPreferencesWhereUniqueInput
    update?: XOR<XOR<CustomerPreferencesUpdateToOneWithWhereWithoutGuestInput, CustomerPreferencesUpdateWithoutGuestInput>, CustomerPreferencesUncheckedUpdateWithoutGuestInput>
  }

  export type EventFeedbackUpdateManyWithoutGuestNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput> | EventFeedbackCreateWithoutGuestInput[] | EventFeedbackUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutGuestInput | EventFeedbackCreateOrConnectWithoutGuestInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutGuestInput | EventFeedbackUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: EventFeedbackCreateManyGuestInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutGuestInput | EventFeedbackUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutGuestInput | EventFeedbackUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type ListEntryUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput> | ListEntryCreateWithoutGuestInput[] | ListEntryUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutGuestInput | ListEntryCreateOrConnectWithoutGuestInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutGuestInput | ListEntryUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ListEntryCreateManyGuestInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutGuestInput | ListEntryUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutGuestInput | ListEntryUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type SecurityNoteUpdateManyWithoutGuestNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput> | SecurityNoteCreateWithoutGuestInput[] | SecurityNoteUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutGuestInput | SecurityNoteCreateOrConnectWithoutGuestInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutGuestInput | SecurityNoteUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: SecurityNoteCreateManyGuestInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutGuestInput | SecurityNoteUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutGuestInput | SecurityNoteUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutGuestNestedInput = {
    create?: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput> | TicketCreateWithoutGuestInput[] | TicketUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutGuestInput | TicketCreateOrConnectWithoutGuestInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutGuestInput | TicketUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: TicketCreateManyGuestInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutGuestInput | TicketUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutGuestInput | TicketUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput = {
    create?: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
    connectOrCreate?: CustomerPreferencesCreateOrConnectWithoutGuestInput
    upsert?: CustomerPreferencesUpsertWithoutGuestInput
    disconnect?: CustomerPreferencesWhereInput | boolean
    delete?: CustomerPreferencesWhereInput | boolean
    connect?: CustomerPreferencesWhereUniqueInput
    update?: XOR<XOR<CustomerPreferencesUpdateToOneWithWhereWithoutGuestInput, CustomerPreferencesUpdateWithoutGuestInput>, CustomerPreferencesUncheckedUpdateWithoutGuestInput>
  }

  export type EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput> | EventFeedbackCreateWithoutGuestInput[] | EventFeedbackUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutGuestInput | EventFeedbackCreateOrConnectWithoutGuestInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutGuestInput | EventFeedbackUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: EventFeedbackCreateManyGuestInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutGuestInput | EventFeedbackUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutGuestInput | EventFeedbackUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type ListEntryUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput> | ListEntryCreateWithoutGuestInput[] | ListEntryUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ListEntryCreateOrConnectWithoutGuestInput | ListEntryCreateOrConnectWithoutGuestInput[]
    upsert?: ListEntryUpsertWithWhereUniqueWithoutGuestInput | ListEntryUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ListEntryCreateManyGuestInputEnvelope
    set?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    disconnect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    delete?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    connect?: ListEntryWhereUniqueInput | ListEntryWhereUniqueInput[]
    update?: ListEntryUpdateWithWhereUniqueWithoutGuestInput | ListEntryUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ListEntryUpdateManyWithWhereWithoutGuestInput | ListEntryUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
  }

  export type SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput> | SecurityNoteCreateWithoutGuestInput[] | SecurityNoteUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutGuestInput | SecurityNoteCreateOrConnectWithoutGuestInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutGuestInput | SecurityNoteUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: SecurityNoteCreateManyGuestInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutGuestInput | SecurityNoteUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutGuestInput | SecurityNoteUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput> | TicketCreateWithoutGuestInput[] | TicketUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutGuestInput | TicketCreateOrConnectWithoutGuestInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutGuestInput | TicketUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: TicketCreateManyGuestInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutGuestInput | TicketUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutGuestInput | TicketUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutListEntriesInput = {
    create?: XOR<UserCreateWithoutListEntriesInput, UserUncheckedCreateWithoutListEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutListEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutListEntriesInput = {
    create?: XOR<GuestCreateWithoutListEntriesInput, GuestUncheckedCreateWithoutListEntriesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutListEntriesInput
    connect?: GuestWhereUniqueInput
  }

  export type ListCreateNestedOneWithoutEntriesInput = {
    create?: XOR<ListCreateWithoutEntriesInput, ListUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ListCreateOrConnectWithoutEntriesInput
    connect?: ListWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutListEntryInput = {
    create?: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput> | TicketCreateWithoutListEntryInput[] | TicketUncheckedCreateWithoutListEntryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutListEntryInput | TicketCreateOrConnectWithoutListEntryInput[]
    createMany?: TicketCreateManyListEntryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutListEntryInput = {
    create?: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput> | TicketCreateWithoutListEntryInput[] | TicketUncheckedCreateWithoutListEntryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutListEntryInput | TicketCreateOrConnectWithoutListEntryInput[]
    createMany?: TicketCreateManyListEntryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumCreatedViaFieldUpdateOperationsInput = {
    set?: $Enums.CreatedVia
  }

  export type EnumEntryStatusFieldUpdateOperationsInput = {
    set?: $Enums.EntryStatus
  }

  export type EnumBookingMethodFieldUpdateOperationsInput = {
    set?: $Enums.BookingMethod
  }

  export type UserUpdateOneRequiredWithoutListEntriesNestedInput = {
    create?: XOR<UserCreateWithoutListEntriesInput, UserUncheckedCreateWithoutListEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutListEntriesInput
    upsert?: UserUpsertWithoutListEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListEntriesInput, UserUpdateWithoutListEntriesInput>, UserUncheckedUpdateWithoutListEntriesInput>
  }

  export type GuestUpdateOneWithoutListEntriesNestedInput = {
    create?: XOR<GuestCreateWithoutListEntriesInput, GuestUncheckedCreateWithoutListEntriesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutListEntriesInput
    upsert?: GuestUpsertWithoutListEntriesInput
    disconnect?: GuestWhereInput | boolean
    delete?: GuestWhereInput | boolean
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutListEntriesInput, GuestUpdateWithoutListEntriesInput>, GuestUncheckedUpdateWithoutListEntriesInput>
  }

  export type ListUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<ListCreateWithoutEntriesInput, ListUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: ListCreateOrConnectWithoutEntriesInput
    upsert?: ListUpsertWithoutEntriesInput
    connect?: ListWhereUniqueInput
    update?: XOR<XOR<ListUpdateToOneWithWhereWithoutEntriesInput, ListUpdateWithoutEntriesInput>, ListUncheckedUpdateWithoutEntriesInput>
  }

  export type TicketUpdateManyWithoutListEntryNestedInput = {
    create?: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput> | TicketCreateWithoutListEntryInput[] | TicketUncheckedCreateWithoutListEntryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutListEntryInput | TicketCreateOrConnectWithoutListEntryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutListEntryInput | TicketUpsertWithWhereUniqueWithoutListEntryInput[]
    createMany?: TicketCreateManyListEntryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutListEntryInput | TicketUpdateWithWhereUniqueWithoutListEntryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutListEntryInput | TicketUpdateManyWithWhereWithoutListEntryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutListEntryNestedInput = {
    create?: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput> | TicketCreateWithoutListEntryInput[] | TicketUncheckedCreateWithoutListEntryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutListEntryInput | TicketCreateOrConnectWithoutListEntryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutListEntryInput | TicketUpsertWithWhereUniqueWithoutListEntryInput[]
    createMany?: TicketCreateManyListEntryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutListEntryInput | TicketUpdateWithWhereUniqueWithoutListEntryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutListEntryInput | TicketUpdateManyWithWhereWithoutListEntryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CheckInCreateNestedManyWithoutTicketInput = {
    create?: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput> | CheckInCreateWithoutTicketInput[] | CheckInUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutTicketInput | CheckInCreateOrConnectWithoutTicketInput[]
    createMany?: CheckInCreateManyTicketInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ConsumptionCreateNestedManyWithoutTicketInput = {
    create?: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput> | ConsumptionCreateWithoutTicketInput[] | ConsumptionUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutTicketInput | ConsumptionCreateOrConnectWithoutTicketInput[]
    createMany?: ConsumptionCreateManyTicketInputEnvelope
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
  }

  export type EventFeedbackCreateNestedManyWithoutTicketInput = {
    create?: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput> | EventFeedbackCreateWithoutTicketInput[] | EventFeedbackUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutTicketInput | EventFeedbackCreateOrConnectWithoutTicketInput[]
    createMany?: EventFeedbackCreateManyTicketInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type SecurityNoteCreateNestedManyWithoutTicketInput = {
    create?: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput> | SecurityNoteCreateWithoutTicketInput[] | SecurityNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutTicketInput | SecurityNoteCreateOrConnectWithoutTicketInput[]
    createMany?: SecurityNoteCreateManyTicketInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type EventCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    connect?: EventWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutTicketsInput = {
    create?: XOR<GuestCreateWithoutTicketsInput, GuestUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutTicketsInput
    connect?: GuestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsIssuedInput = {
    create?: XOR<UserCreateWithoutTicketsIssuedInput, UserUncheckedCreateWithoutTicketsIssuedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsIssuedInput
    connect?: UserWhereUniqueInput
  }

  export type ListEntryCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ListEntryCreateWithoutTicketsInput, ListEntryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ListEntryCreateOrConnectWithoutTicketsInput
    connect?: ListEntryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsOwnedInput = {
    create?: XOR<UserCreateWithoutTicketsOwnedInput, UserUncheckedCreateWithoutTicketsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsOwnedInput
    connect?: UserWhereUniqueInput
  }

  export type CheckInUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput> | CheckInCreateWithoutTicketInput[] | CheckInUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutTicketInput | CheckInCreateOrConnectWithoutTicketInput[]
    createMany?: CheckInCreateManyTicketInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ConsumptionUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput> | ConsumptionCreateWithoutTicketInput[] | ConsumptionUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutTicketInput | ConsumptionCreateOrConnectWithoutTicketInput[]
    createMany?: ConsumptionCreateManyTicketInputEnvelope
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
  }

  export type EventFeedbackUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput> | EventFeedbackCreateWithoutTicketInput[] | EventFeedbackUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutTicketInput | EventFeedbackCreateOrConnectWithoutTicketInput[]
    createMany?: EventFeedbackCreateManyTicketInputEnvelope
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
  }

  export type SecurityNoteUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput> | SecurityNoteCreateWithoutTicketInput[] | SecurityNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutTicketInput | SecurityNoteCreateOrConnectWithoutTicketInput[]
    createMany?: SecurityNoteCreateManyTicketInputEnvelope
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
  }

  export type EnumTicketTypeFieldUpdateOperationsInput = {
    set?: $Enums.TicketType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type CheckInUpdateManyWithoutTicketNestedInput = {
    create?: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput> | CheckInCreateWithoutTicketInput[] | CheckInUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutTicketInput | CheckInCreateOrConnectWithoutTicketInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutTicketInput | CheckInUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: CheckInCreateManyTicketInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutTicketInput | CheckInUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutTicketInput | CheckInUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ConsumptionUpdateManyWithoutTicketNestedInput = {
    create?: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput> | ConsumptionCreateWithoutTicketInput[] | ConsumptionUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutTicketInput | ConsumptionCreateOrConnectWithoutTicketInput[]
    upsert?: ConsumptionUpsertWithWhereUniqueWithoutTicketInput | ConsumptionUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: ConsumptionCreateManyTicketInputEnvelope
    set?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    disconnect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    delete?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    update?: ConsumptionUpdateWithWhereUniqueWithoutTicketInput | ConsumptionUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: ConsumptionUpdateManyWithWhereWithoutTicketInput | ConsumptionUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
  }

  export type EventFeedbackUpdateManyWithoutTicketNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput> | EventFeedbackCreateWithoutTicketInput[] | EventFeedbackUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutTicketInput | EventFeedbackCreateOrConnectWithoutTicketInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutTicketInput | EventFeedbackUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: EventFeedbackCreateManyTicketInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutTicketInput | EventFeedbackUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutTicketInput | EventFeedbackUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type SecurityNoteUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput> | SecurityNoteCreateWithoutTicketInput[] | SecurityNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutTicketInput | SecurityNoteCreateOrConnectWithoutTicketInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutTicketInput | SecurityNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SecurityNoteCreateManyTicketInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutTicketInput | SecurityNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutTicketInput | SecurityNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type EventUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    upsert?: EventUpsertWithoutTicketsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTicketsInput, EventUpdateWithoutTicketsInput>, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type GuestUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<GuestCreateWithoutTicketsInput, GuestUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutTicketsInput
    upsert?: GuestUpsertWithoutTicketsInput
    disconnect?: GuestWhereInput | boolean
    delete?: GuestWhereInput | boolean
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutTicketsInput, GuestUpdateWithoutTicketsInput>, GuestUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutTicketsIssuedNestedInput = {
    create?: XOR<UserCreateWithoutTicketsIssuedInput, UserUncheckedCreateWithoutTicketsIssuedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsIssuedInput
    upsert?: UserUpsertWithoutTicketsIssuedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsIssuedInput, UserUpdateWithoutTicketsIssuedInput>, UserUncheckedUpdateWithoutTicketsIssuedInput>
  }

  export type ListEntryUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<ListEntryCreateWithoutTicketsInput, ListEntryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ListEntryCreateOrConnectWithoutTicketsInput
    upsert?: ListEntryUpsertWithoutTicketsInput
    disconnect?: ListEntryWhereInput | boolean
    delete?: ListEntryWhereInput | boolean
    connect?: ListEntryWhereUniqueInput
    update?: XOR<XOR<ListEntryUpdateToOneWithWhereWithoutTicketsInput, ListEntryUpdateWithoutTicketsInput>, ListEntryUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutTicketsOwnedNestedInput = {
    create?: XOR<UserCreateWithoutTicketsOwnedInput, UserUncheckedCreateWithoutTicketsOwnedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsOwnedInput
    upsert?: UserUpsertWithoutTicketsOwnedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsOwnedInput, UserUpdateWithoutTicketsOwnedInput>, UserUncheckedUpdateWithoutTicketsOwnedInput>
  }

  export type CheckInUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput> | CheckInCreateWithoutTicketInput[] | CheckInUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutTicketInput | CheckInCreateOrConnectWithoutTicketInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutTicketInput | CheckInUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: CheckInCreateManyTicketInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutTicketInput | CheckInUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutTicketInput | CheckInUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ConsumptionUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput> | ConsumptionCreateWithoutTicketInput[] | ConsumptionUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ConsumptionCreateOrConnectWithoutTicketInput | ConsumptionCreateOrConnectWithoutTicketInput[]
    upsert?: ConsumptionUpsertWithWhereUniqueWithoutTicketInput | ConsumptionUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: ConsumptionCreateManyTicketInputEnvelope
    set?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    disconnect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    delete?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    connect?: ConsumptionWhereUniqueInput | ConsumptionWhereUniqueInput[]
    update?: ConsumptionUpdateWithWhereUniqueWithoutTicketInput | ConsumptionUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: ConsumptionUpdateManyWithWhereWithoutTicketInput | ConsumptionUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
  }

  export type EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput> | EventFeedbackCreateWithoutTicketInput[] | EventFeedbackUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: EventFeedbackCreateOrConnectWithoutTicketInput | EventFeedbackCreateOrConnectWithoutTicketInput[]
    upsert?: EventFeedbackUpsertWithWhereUniqueWithoutTicketInput | EventFeedbackUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: EventFeedbackCreateManyTicketInputEnvelope
    set?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    disconnect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    delete?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    connect?: EventFeedbackWhereUniqueInput | EventFeedbackWhereUniqueInput[]
    update?: EventFeedbackUpdateWithWhereUniqueWithoutTicketInput | EventFeedbackUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: EventFeedbackUpdateManyWithWhereWithoutTicketInput | EventFeedbackUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
  }

  export type SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput> | SecurityNoteCreateWithoutTicketInput[] | SecurityNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SecurityNoteCreateOrConnectWithoutTicketInput | SecurityNoteCreateOrConnectWithoutTicketInput[]
    upsert?: SecurityNoteUpsertWithWhereUniqueWithoutTicketInput | SecurityNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SecurityNoteCreateManyTicketInputEnvelope
    set?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    disconnect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    delete?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    connect?: SecurityNoteWhereUniqueInput | SecurityNoteWhereUniqueInput[]
    update?: SecurityNoteUpdateWithWhereUniqueWithoutTicketInput | SecurityNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SecurityNoteUpdateManyWithWhereWithoutTicketInput | SecurityNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<UserCreateWithoutCheckinsInput, UserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckinsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<TicketCreateWithoutCheckinsInput, TicketUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCheckinsInput
    connect?: TicketWhereUniqueInput
  }

  export type EnumGateFieldUpdateOperationsInput = {
    set?: $Enums.Gate
  }

  export type UserUpdateOneRequiredWithoutCheckinsNestedInput = {
    create?: XOR<UserCreateWithoutCheckinsInput, UserUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckinsInput
    upsert?: UserUpsertWithoutCheckinsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckinsInput, UserUpdateWithoutCheckinsInput>, UserUncheckedUpdateWithoutCheckinsInput>
  }

  export type TicketUpdateOneRequiredWithoutCheckinsNestedInput = {
    create?: XOR<TicketCreateWithoutCheckinsInput, TicketUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCheckinsInput
    upsert?: TicketUpsertWithoutCheckinsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCheckinsInput, TicketUpdateWithoutCheckinsInput>, TicketUncheckedUpdateWithoutCheckinsInput>
  }

  export type UserCreateNestedOneWithoutInviteLinksInput = {
    create?: XOR<UserCreateWithoutInviteLinksInput, UserUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteLinksInput
    connect?: UserWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutInviteLinksInput = {
    create?: XOR<EventCreateWithoutInviteLinksInput, EventUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: EventCreateOrConnectWithoutInviteLinksInput
    connect?: EventWhereUniqueInput
  }

  export type PRProfileCreateNestedOneWithoutInviteLinksInput = {
    create?: XOR<PRProfileCreateWithoutInviteLinksInput, PRProfileUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutInviteLinksInput
    connect?: PRProfileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInviteLinksNestedInput = {
    create?: XOR<UserCreateWithoutInviteLinksInput, UserUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutInviteLinksInput
    upsert?: UserUpsertWithoutInviteLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInviteLinksInput, UserUpdateWithoutInviteLinksInput>, UserUncheckedUpdateWithoutInviteLinksInput>
  }

  export type EventUpdateOneRequiredWithoutInviteLinksNestedInput = {
    create?: XOR<EventCreateWithoutInviteLinksInput, EventUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: EventCreateOrConnectWithoutInviteLinksInput
    upsert?: EventUpsertWithoutInviteLinksInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutInviteLinksInput, EventUpdateWithoutInviteLinksInput>, EventUncheckedUpdateWithoutInviteLinksInput>
  }

  export type PRProfileUpdateOneWithoutInviteLinksNestedInput = {
    create?: XOR<PRProfileCreateWithoutInviteLinksInput, PRProfileUncheckedCreateWithoutInviteLinksInput>
    connectOrCreate?: PRProfileCreateOrConnectWithoutInviteLinksInput
    upsert?: PRProfileUpsertWithoutInviteLinksInput
    disconnect?: PRProfileWhereInput | boolean
    delete?: PRProfileWhereInput | boolean
    connect?: PRProfileWhereUniqueInput
    update?: XOR<XOR<PRProfileUpdateToOneWithWhereWithoutInviteLinksInput, PRProfileUpdateWithoutInviteLinksInput>, PRProfileUncheckedUpdateWithoutInviteLinksInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EventCreateNestedOneWithoutConsumptionsInput = {
    create?: XOR<EventCreateWithoutConsumptionsInput, EventUncheckedCreateWithoutConsumptionsInput>
    connectOrCreate?: EventCreateOrConnectWithoutConsumptionsInput
    connect?: EventWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutConsumptionsInput = {
    create?: XOR<TicketCreateWithoutConsumptionsInput, TicketUncheckedCreateWithoutConsumptionsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutConsumptionsInput
    connect?: TicketWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUpdateOneRequiredWithoutConsumptionsNestedInput = {
    create?: XOR<EventCreateWithoutConsumptionsInput, EventUncheckedCreateWithoutConsumptionsInput>
    connectOrCreate?: EventCreateOrConnectWithoutConsumptionsInput
    upsert?: EventUpsertWithoutConsumptionsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutConsumptionsInput, EventUpdateWithoutConsumptionsInput>, EventUncheckedUpdateWithoutConsumptionsInput>
  }

  export type TicketUpdateOneRequiredWithoutConsumptionsNestedInput = {
    create?: XOR<TicketCreateWithoutConsumptionsInput, TicketUncheckedCreateWithoutConsumptionsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutConsumptionsInput
    upsert?: TicketUpsertWithoutConsumptionsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutConsumptionsInput, TicketUpdateWithoutConsumptionsInput>, TicketUncheckedUpdateWithoutConsumptionsInput>
  }

  export type EventCreateNestedOneWithoutFunnelTrackingInput = {
    create?: XOR<EventCreateWithoutFunnelTrackingInput, EventUncheckedCreateWithoutFunnelTrackingInput>
    connectOrCreate?: EventCreateOrConnectWithoutFunnelTrackingInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutFunnelTrackingNestedInput = {
    create?: XOR<EventCreateWithoutFunnelTrackingInput, EventUncheckedCreateWithoutFunnelTrackingInput>
    connectOrCreate?: EventCreateOrConnectWithoutFunnelTrackingInput
    upsert?: EventUpsertWithoutFunnelTrackingInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutFunnelTrackingInput, EventUpdateWithoutFunnelTrackingInput>, EventUncheckedUpdateWithoutFunnelTrackingInput>
  }

  export type EventCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<EventCreateWithoutFeedbacksInput, EventUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: EventCreateOrConnectWithoutFeedbacksInput
    connect?: EventWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<GuestCreateWithoutFeedbacksInput, GuestUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: GuestCreateOrConnectWithoutFeedbacksInput
    connect?: GuestWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<TicketCreateWithoutFeedbacksInput, TicketUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: TicketCreateOrConnectWithoutFeedbacksInput
    connect?: TicketWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EventUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<EventCreateWithoutFeedbacksInput, EventUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: EventCreateOrConnectWithoutFeedbacksInput
    upsert?: EventUpsertWithoutFeedbacksInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutFeedbacksInput, EventUpdateWithoutFeedbacksInput>, EventUncheckedUpdateWithoutFeedbacksInput>
  }

  export type GuestUpdateOneWithoutFeedbacksNestedInput = {
    create?: XOR<GuestCreateWithoutFeedbacksInput, GuestUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: GuestCreateOrConnectWithoutFeedbacksInput
    upsert?: GuestUpsertWithoutFeedbacksInput
    disconnect?: GuestWhereInput | boolean
    delete?: GuestWhereInput | boolean
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutFeedbacksInput, GuestUpdateWithoutFeedbacksInput>, GuestUncheckedUpdateWithoutFeedbacksInput>
  }

  export type TicketUpdateOneWithoutFeedbacksNestedInput = {
    create?: XOR<TicketCreateWithoutFeedbacksInput, TicketUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: TicketCreateOrConnectWithoutFeedbacksInput
    upsert?: TicketUpsertWithoutFeedbacksInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutFeedbacksInput, TicketUpdateWithoutFeedbacksInput>, TicketUncheckedUpdateWithoutFeedbacksInput>
  }

  export type EventCreateNestedOneWithoutSecurityNotesInput = {
    create?: XOR<EventCreateWithoutSecurityNotesInput, EventUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: EventCreateOrConnectWithoutSecurityNotesInput
    connect?: EventWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutSecurityNotesInput = {
    create?: XOR<GuestCreateWithoutSecurityNotesInput, GuestUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutSecurityNotesInput
    connect?: GuestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSecurityReportsInput = {
    create?: XOR<UserCreateWithoutSecurityReportsInput, UserUncheckedCreateWithoutSecurityReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityReportsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutSecurityNotesInput = {
    create?: XOR<TicketCreateWithoutSecurityNotesInput, TicketUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutSecurityNotesInput
    connect?: TicketWhereUniqueInput
  }

  export type EventUpdateOneWithoutSecurityNotesNestedInput = {
    create?: XOR<EventCreateWithoutSecurityNotesInput, EventUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: EventCreateOrConnectWithoutSecurityNotesInput
    upsert?: EventUpsertWithoutSecurityNotesInput
    disconnect?: EventWhereInput | boolean
    delete?: EventWhereInput | boolean
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutSecurityNotesInput, EventUpdateWithoutSecurityNotesInput>, EventUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type GuestUpdateOneWithoutSecurityNotesNestedInput = {
    create?: XOR<GuestCreateWithoutSecurityNotesInput, GuestUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutSecurityNotesInput
    upsert?: GuestUpsertWithoutSecurityNotesInput
    disconnect?: GuestWhereInput | boolean
    delete?: GuestWhereInput | boolean
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutSecurityNotesInput, GuestUpdateWithoutSecurityNotesInput>, GuestUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type UserUpdateOneRequiredWithoutSecurityReportsNestedInput = {
    create?: XOR<UserCreateWithoutSecurityReportsInput, UserUncheckedCreateWithoutSecurityReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSecurityReportsInput
    upsert?: UserUpsertWithoutSecurityReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSecurityReportsInput, UserUpdateWithoutSecurityReportsInput>, UserUncheckedUpdateWithoutSecurityReportsInput>
  }

  export type TicketUpdateOneWithoutSecurityNotesNestedInput = {
    create?: XOR<TicketCreateWithoutSecurityNotesInput, TicketUncheckedCreateWithoutSecurityNotesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutSecurityNotesInput
    upsert?: TicketUpsertWithoutSecurityNotesInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutSecurityNotesInput, TicketUpdateWithoutSecurityNotesInput>, TicketUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type GuestCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<GuestCreateWithoutPreferencesInput, GuestUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutPreferencesInput
    connect?: GuestWhereUniqueInput
  }

  export type GuestUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<GuestCreateWithoutPreferencesInput, GuestUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: GuestCreateOrConnectWithoutPreferencesInput
    upsert?: GuestUpsertWithoutPreferencesInput
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutPreferencesInput, GuestUpdateWithoutPreferencesInput>, GuestUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutOrganizationProfileInput = {
    create?: XOR<UserCreateWithoutOrganizationProfileInput, UserUncheckedCreateWithoutOrganizationProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationProfileInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrganizationProfileNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationProfileInput, UserUncheckedCreateWithoutOrganizationProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationProfileInput
    upsert?: UserUpsertWithoutOrganizationProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationProfileInput, UserUpdateWithoutOrganizationProfileInput>, UserUncheckedUpdateWithoutOrganizationProfileInput>
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type OrganizationProfileCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<OrganizationProfileCreateWithoutTeamMembersInput, OrganizationProfileUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutTeamMembersInput
    connect?: OrganizationProfileWhereUniqueInput
  }

  export type OrganizationProfileUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<OrganizationProfileCreateWithoutTeamMembersInput, OrganizationProfileUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: OrganizationProfileCreateOrConnectWithoutTeamMembersInput
    upsert?: OrganizationProfileUpsertWithoutTeamMembersInput
    connect?: OrganizationProfileWhereUniqueInput
    update?: XOR<XOR<OrganizationProfileUpdateToOneWithWhereWithoutTeamMembersInput, OrganizationProfileUpdateWithoutTeamMembersInput>, OrganizationProfileUncheckedUpdateWithoutTeamMembersInput>
  }

  export type ArtistProfileCreategenresInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutArtistProfileInput = {
    create?: XOR<UserCreateWithoutArtistProfileInput, UserUncheckedCreateWithoutArtistProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtistProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PerformanceCreateNestedManyWithoutArtistInput = {
    create?: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput> | PerformanceCreateWithoutArtistInput[] | PerformanceUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: PerformanceCreateOrConnectWithoutArtistInput | PerformanceCreateOrConnectWithoutArtistInput[]
    createMany?: PerformanceCreateManyArtistInputEnvelope
    connect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
  }

  export type ArtistMediaCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput> | ArtistMediaCreateWithoutArtistInput[] | ArtistMediaUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistMediaCreateOrConnectWithoutArtistInput | ArtistMediaCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistMediaCreateManyArtistInputEnvelope
    connect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
  }

  export type PerformanceUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput> | PerformanceCreateWithoutArtistInput[] | PerformanceUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: PerformanceCreateOrConnectWithoutArtistInput | PerformanceCreateOrConnectWithoutArtistInput[]
    createMany?: PerformanceCreateManyArtistInputEnvelope
    connect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
  }

  export type ArtistMediaUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput> | ArtistMediaCreateWithoutArtistInput[] | ArtistMediaUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistMediaCreateOrConnectWithoutArtistInput | ArtistMediaCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistMediaCreateManyArtistInputEnvelope
    connect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
  }

  export type EnumArtistTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArtistType
  }

  export type ArtistProfileUpdategenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutArtistProfileNestedInput = {
    create?: XOR<UserCreateWithoutArtistProfileInput, UserUncheckedCreateWithoutArtistProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtistProfileInput
    upsert?: UserUpsertWithoutArtistProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArtistProfileInput, UserUpdateWithoutArtistProfileInput>, UserUncheckedUpdateWithoutArtistProfileInput>
  }

  export type PerformanceUpdateManyWithoutArtistNestedInput = {
    create?: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput> | PerformanceCreateWithoutArtistInput[] | PerformanceUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: PerformanceCreateOrConnectWithoutArtistInput | PerformanceCreateOrConnectWithoutArtistInput[]
    upsert?: PerformanceUpsertWithWhereUniqueWithoutArtistInput | PerformanceUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: PerformanceCreateManyArtistInputEnvelope
    set?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    disconnect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    delete?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    connect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    update?: PerformanceUpdateWithWhereUniqueWithoutArtistInput | PerformanceUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: PerformanceUpdateManyWithWhereWithoutArtistInput | PerformanceUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: PerformanceScalarWhereInput | PerformanceScalarWhereInput[]
  }

  export type ArtistMediaUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput> | ArtistMediaCreateWithoutArtistInput[] | ArtistMediaUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistMediaCreateOrConnectWithoutArtistInput | ArtistMediaCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistMediaUpsertWithWhereUniqueWithoutArtistInput | ArtistMediaUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistMediaCreateManyArtistInputEnvelope
    set?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    disconnect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    delete?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    connect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    update?: ArtistMediaUpdateWithWhereUniqueWithoutArtistInput | ArtistMediaUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistMediaUpdateManyWithWhereWithoutArtistInput | ArtistMediaUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistMediaScalarWhereInput | ArtistMediaScalarWhereInput[]
  }

  export type PerformanceUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput> | PerformanceCreateWithoutArtistInput[] | PerformanceUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: PerformanceCreateOrConnectWithoutArtistInput | PerformanceCreateOrConnectWithoutArtistInput[]
    upsert?: PerformanceUpsertWithWhereUniqueWithoutArtistInput | PerformanceUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: PerformanceCreateManyArtistInputEnvelope
    set?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    disconnect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    delete?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    connect?: PerformanceWhereUniqueInput | PerformanceWhereUniqueInput[]
    update?: PerformanceUpdateWithWhereUniqueWithoutArtistInput | PerformanceUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: PerformanceUpdateManyWithWhereWithoutArtistInput | PerformanceUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: PerformanceScalarWhereInput | PerformanceScalarWhereInput[]
  }

  export type ArtistMediaUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput> | ArtistMediaCreateWithoutArtistInput[] | ArtistMediaUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistMediaCreateOrConnectWithoutArtistInput | ArtistMediaCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistMediaUpsertWithWhereUniqueWithoutArtistInput | ArtistMediaUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistMediaCreateManyArtistInputEnvelope
    set?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    disconnect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    delete?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    connect?: ArtistMediaWhereUniqueInput | ArtistMediaWhereUniqueInput[]
    update?: ArtistMediaUpdateWithWhereUniqueWithoutArtistInput | ArtistMediaUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistMediaUpdateManyWithWhereWithoutArtistInput | ArtistMediaUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistMediaScalarWhereInput | ArtistMediaScalarWhereInput[]
  }

  export type ArtistProfileCreateNestedOneWithoutPerformancesInput = {
    create?: XOR<ArtistProfileCreateWithoutPerformancesInput, ArtistProfileUncheckedCreateWithoutPerformancesInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutPerformancesInput
    connect?: ArtistProfileWhereUniqueInput
  }

  export type ArtistProfileUpdateOneRequiredWithoutPerformancesNestedInput = {
    create?: XOR<ArtistProfileCreateWithoutPerformancesInput, ArtistProfileUncheckedCreateWithoutPerformancesInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutPerformancesInput
    upsert?: ArtistProfileUpsertWithoutPerformancesInput
    connect?: ArtistProfileWhereUniqueInput
    update?: XOR<XOR<ArtistProfileUpdateToOneWithWhereWithoutPerformancesInput, ArtistProfileUpdateWithoutPerformancesInput>, ArtistProfileUncheckedUpdateWithoutPerformancesInput>
  }

  export type ArtistProfileCreateNestedOneWithoutMediaGalleryInput = {
    create?: XOR<ArtistProfileCreateWithoutMediaGalleryInput, ArtistProfileUncheckedCreateWithoutMediaGalleryInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutMediaGalleryInput
    connect?: ArtistProfileWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type ArtistProfileUpdateOneRequiredWithoutMediaGalleryNestedInput = {
    create?: XOR<ArtistProfileCreateWithoutMediaGalleryInput, ArtistProfileUncheckedCreateWithoutMediaGalleryInput>
    connectOrCreate?: ArtistProfileCreateOrConnectWithoutMediaGalleryInput
    upsert?: ArtistProfileUpsertWithoutMediaGalleryInput
    connect?: ArtistProfileWhereUniqueInput
    update?: XOR<XOR<ArtistProfileUpdateToOneWithWhereWithoutMediaGalleryInput, ArtistProfileUpdateWithoutMediaGalleryInput>, ArtistProfileUncheckedUpdateWithoutMediaGalleryInput>
  }

  export type UserProfileCreateinterestsInput = {
    set: string[]
  }

  export type UserProfileCreatefavoriteGenresInput = {
    set: string[]
  }

  export type UserProfileCreatepreferredVenuesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type UserProfileUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatefavoriteGenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatepreferredVenuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProfileInput, UserUpdateWithoutUserProfileInput>, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowedByInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowedByNestedInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    upsert?: UserUpsertWithoutFollowedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowedByInput, UserUpdateWithoutFollowedByInput>, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserCreateNestedOneWithoutFeedItemsInput = {
    create?: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedItemsInput
    connect?: UserWhereUniqueInput
  }

  export type FeedLikeCreateNestedManyWithoutFeedItemInput = {
    create?: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput> | FeedLikeCreateWithoutFeedItemInput[] | FeedLikeUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutFeedItemInput | FeedLikeCreateOrConnectWithoutFeedItemInput[]
    createMany?: FeedLikeCreateManyFeedItemInputEnvelope
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
  }

  export type FeedCommentCreateNestedManyWithoutFeedItemInput = {
    create?: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput> | FeedCommentCreateWithoutFeedItemInput[] | FeedCommentUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutFeedItemInput | FeedCommentCreateOrConnectWithoutFeedItemInput[]
    createMany?: FeedCommentCreateManyFeedItemInputEnvelope
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
  }

  export type FeedLikeUncheckedCreateNestedManyWithoutFeedItemInput = {
    create?: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput> | FeedLikeCreateWithoutFeedItemInput[] | FeedLikeUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutFeedItemInput | FeedLikeCreateOrConnectWithoutFeedItemInput[]
    createMany?: FeedLikeCreateManyFeedItemInputEnvelope
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
  }

  export type FeedCommentUncheckedCreateNestedManyWithoutFeedItemInput = {
    create?: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput> | FeedCommentCreateWithoutFeedItemInput[] | FeedCommentUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutFeedItemInput | FeedCommentCreateOrConnectWithoutFeedItemInput[]
    createMany?: FeedCommentCreateManyFeedItemInputEnvelope
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
  }

  export type EnumFeedItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedItemType
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type UserUpdateOneRequiredWithoutFeedItemsNestedInput = {
    create?: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedItemsInput
    upsert?: UserUpsertWithoutFeedItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedItemsInput, UserUpdateWithoutFeedItemsInput>, UserUncheckedUpdateWithoutFeedItemsInput>
  }

  export type FeedLikeUpdateManyWithoutFeedItemNestedInput = {
    create?: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput> | FeedLikeCreateWithoutFeedItemInput[] | FeedLikeUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutFeedItemInput | FeedLikeCreateOrConnectWithoutFeedItemInput[]
    upsert?: FeedLikeUpsertWithWhereUniqueWithoutFeedItemInput | FeedLikeUpsertWithWhereUniqueWithoutFeedItemInput[]
    createMany?: FeedLikeCreateManyFeedItemInputEnvelope
    set?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    disconnect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    delete?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    update?: FeedLikeUpdateWithWhereUniqueWithoutFeedItemInput | FeedLikeUpdateWithWhereUniqueWithoutFeedItemInput[]
    updateMany?: FeedLikeUpdateManyWithWhereWithoutFeedItemInput | FeedLikeUpdateManyWithWhereWithoutFeedItemInput[]
    deleteMany?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
  }

  export type FeedCommentUpdateManyWithoutFeedItemNestedInput = {
    create?: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput> | FeedCommentCreateWithoutFeedItemInput[] | FeedCommentUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutFeedItemInput | FeedCommentCreateOrConnectWithoutFeedItemInput[]
    upsert?: FeedCommentUpsertWithWhereUniqueWithoutFeedItemInput | FeedCommentUpsertWithWhereUniqueWithoutFeedItemInput[]
    createMany?: FeedCommentCreateManyFeedItemInputEnvelope
    set?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    disconnect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    delete?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    update?: FeedCommentUpdateWithWhereUniqueWithoutFeedItemInput | FeedCommentUpdateWithWhereUniqueWithoutFeedItemInput[]
    updateMany?: FeedCommentUpdateManyWithWhereWithoutFeedItemInput | FeedCommentUpdateManyWithWhereWithoutFeedItemInput[]
    deleteMany?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
  }

  export type FeedLikeUncheckedUpdateManyWithoutFeedItemNestedInput = {
    create?: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput> | FeedLikeCreateWithoutFeedItemInput[] | FeedLikeUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedLikeCreateOrConnectWithoutFeedItemInput | FeedLikeCreateOrConnectWithoutFeedItemInput[]
    upsert?: FeedLikeUpsertWithWhereUniqueWithoutFeedItemInput | FeedLikeUpsertWithWhereUniqueWithoutFeedItemInput[]
    createMany?: FeedLikeCreateManyFeedItemInputEnvelope
    set?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    disconnect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    delete?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    connect?: FeedLikeWhereUniqueInput | FeedLikeWhereUniqueInput[]
    update?: FeedLikeUpdateWithWhereUniqueWithoutFeedItemInput | FeedLikeUpdateWithWhereUniqueWithoutFeedItemInput[]
    updateMany?: FeedLikeUpdateManyWithWhereWithoutFeedItemInput | FeedLikeUpdateManyWithWhereWithoutFeedItemInput[]
    deleteMany?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
  }

  export type FeedCommentUncheckedUpdateManyWithoutFeedItemNestedInput = {
    create?: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput> | FeedCommentCreateWithoutFeedItemInput[] | FeedCommentUncheckedCreateWithoutFeedItemInput[]
    connectOrCreate?: FeedCommentCreateOrConnectWithoutFeedItemInput | FeedCommentCreateOrConnectWithoutFeedItemInput[]
    upsert?: FeedCommentUpsertWithWhereUniqueWithoutFeedItemInput | FeedCommentUpsertWithWhereUniqueWithoutFeedItemInput[]
    createMany?: FeedCommentCreateManyFeedItemInputEnvelope
    set?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    disconnect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    delete?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    connect?: FeedCommentWhereUniqueInput | FeedCommentWhereUniqueInput[]
    update?: FeedCommentUpdateWithWhereUniqueWithoutFeedItemInput | FeedCommentUpdateWithWhereUniqueWithoutFeedItemInput[]
    updateMany?: FeedCommentUpdateManyWithWhereWithoutFeedItemInput | FeedCommentUpdateManyWithWhereWithoutFeedItemInput[]
    deleteMany?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
  }

  export type FeedItemCreateNestedOneWithoutLikesInput = {
    create?: XOR<FeedItemCreateWithoutLikesInput, FeedItemUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FeedItemCreateOrConnectWithoutLikesInput
    connect?: FeedItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedLikesInput = {
    create?: XOR<UserCreateWithoutFeedLikesInput, UserUncheckedCreateWithoutFeedLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedLikesInput
    connect?: UserWhereUniqueInput
  }

  export type FeedItemUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FeedItemCreateWithoutLikesInput, FeedItemUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FeedItemCreateOrConnectWithoutLikesInput
    upsert?: FeedItemUpsertWithoutLikesInput
    connect?: FeedItemWhereUniqueInput
    update?: XOR<XOR<FeedItemUpdateToOneWithWhereWithoutLikesInput, FeedItemUpdateWithoutLikesInput>, FeedItemUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutFeedLikesNestedInput = {
    create?: XOR<UserCreateWithoutFeedLikesInput, UserUncheckedCreateWithoutFeedLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedLikesInput
    upsert?: UserUpsertWithoutFeedLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedLikesInput, UserUpdateWithoutFeedLikesInput>, UserUncheckedUpdateWithoutFeedLikesInput>
  }

  export type FeedItemCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FeedItemCreateWithoutCommentsInput, FeedItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FeedItemCreateOrConnectWithoutCommentsInput
    connect?: FeedItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedCommentsInput = {
    create?: XOR<UserCreateWithoutFeedCommentsInput, UserUncheckedCreateWithoutFeedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type FeedItemUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FeedItemCreateWithoutCommentsInput, FeedItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FeedItemCreateOrConnectWithoutCommentsInput
    upsert?: FeedItemUpsertWithoutCommentsInput
    connect?: FeedItemWhereUniqueInput
    update?: XOR<XOR<FeedItemUpdateToOneWithWhereWithoutCommentsInput, FeedItemUpdateWithoutCommentsInput>, FeedItemUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutFeedCommentsNestedInput = {
    create?: XOR<UserCreateWithoutFeedCommentsInput, UserUncheckedCreateWithoutFeedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedCommentsInput
    upsert?: UserUpsertWithoutFeedCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedCommentsInput, UserUpdateWithoutFeedCommentsInput>, UserUncheckedUpdateWithoutFeedCommentsInput>
  }

  export type UserCreateNestedOneWithoutIdentityVerificationsInput = {
    create?: XOR<UserCreateWithoutIdentityVerificationsInput, UserUncheckedCreateWithoutIdentityVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentityVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedVerificationsInput = {
    create?: XOR<UserCreateWithoutReviewedVerificationsInput, UserUncheckedCreateWithoutReviewedVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type UserUpdateOneRequiredWithoutIdentityVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutIdentityVerificationsInput, UserUncheckedCreateWithoutIdentityVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentityVerificationsInput
    upsert?: UserUpsertWithoutIdentityVerificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIdentityVerificationsInput, UserUpdateWithoutIdentityVerificationsInput>, UserUncheckedUpdateWithoutIdentityVerificationsInput>
  }

  export type UserUpdateOneWithoutReviewedVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedVerificationsInput, UserUncheckedCreateWithoutReviewedVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedVerificationsInput
    upsert?: UserUpsertWithoutReviewedVerificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedVerificationsInput, UserUpdateWithoutReviewedVerificationsInput>, UserUncheckedUpdateWithoutReviewedVerificationsInput>
  }

  export type UserCreateNestedOneWithoutPhoneVerificationInput = {
    create?: XOR<UserCreateWithoutPhoneVerificationInput, UserUncheckedCreateWithoutPhoneVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPhoneVerificationNestedInput = {
    create?: XOR<UserCreateWithoutPhoneVerificationInput, UserUncheckedCreateWithoutPhoneVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationInput
    upsert?: UserUpsertWithoutPhoneVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhoneVerificationInput, UserUpdateWithoutPhoneVerificationInput>, UserUncheckedUpdateWithoutPhoneVerificationInput>
  }

  export type UserCreateNestedOneWithoutConsentsInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    upsert?: UserUpsertWithoutConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsentsInput, UserUpdateWithoutConsentsInput>, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserCreateNestedOneWithoutOnboardingProgressInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOnboardingProgressNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    upsert?: UserUpsertWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingProgressInput, UserUpdateWithoutOnboardingProgressInput>, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumClubTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubType | EnumClubTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClubTypeFilter<$PrismaModel> | $Enums.ClubType
  }

  export type NestedEnumClubTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubType | EnumClubTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubType[] | ListEnumClubTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClubTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClubType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClubTypeFilter<$PrismaModel>
    _max?: NestedEnumClubTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumListTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeFilter<$PrismaModel> | $Enums.ListType
  }

  export type NestedEnumListTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListType | EnumListTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListType[] | ListEnumListTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumListTypeWithAggregatesFilter<$PrismaModel> | $Enums.ListType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListTypeFilter<$PrismaModel>
    _max?: NestedEnumListTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerSegmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentFilter<$PrismaModel> | $Enums.CustomerSegment
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel> | $Enums.CustomerSegment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerSegmentFilter<$PrismaModel>
    _max?: NestedEnumCustomerSegmentFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumCreatedViaFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaFilter<$PrismaModel> | $Enums.CreatedVia
  }

  export type NestedEnumEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEntryStatusFilter<$PrismaModel> | $Enums.EntryStatus
  }

  export type NestedEnumBookingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMethod | EnumBookingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingMethodFilter<$PrismaModel> | $Enums.BookingMethod
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel> | $Enums.CreatedVia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedViaFilter<$PrismaModel>
    _max?: NestedEnumCreatedViaFilter<$PrismaModel>
  }

  export type NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntryStatus[] | ListEnumEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumEntryStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMethod | EnumBookingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMethod[] | ListEnumBookingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingMethodWithAggregatesFilter<$PrismaModel> | $Enums.BookingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingMethodFilter<$PrismaModel>
    _max?: NestedEnumBookingMethodFilter<$PrismaModel>
  }

  export type NestedEnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumGateFilter<$PrismaModel = never> = {
    equals?: $Enums.Gate | EnumGateFieldRefInput<$PrismaModel>
    in?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    not?: NestedEnumGateFilter<$PrismaModel> | $Enums.Gate
  }

  export type NestedEnumGateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gate | EnumGateFieldRefInput<$PrismaModel>
    in?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gate[] | ListEnumGateFieldRefInput<$PrismaModel>
    not?: NestedEnumGateWithAggregatesFilter<$PrismaModel> | $Enums.Gate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGateFilter<$PrismaModel>
    _max?: NestedEnumGateFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumArtistTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistType | EnumArtistTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistTypeFilter<$PrismaModel> | $Enums.ArtistType
  }

  export type NestedEnumArtistTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistType | EnumArtistTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistType[] | ListEnumArtistTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtistType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistTypeFilter<$PrismaModel>
    _max?: NestedEnumArtistTypeFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeedItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeFilter<$PrismaModel> | $Enums.FeedItemType
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedItemType | EnumFeedItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedItemType[] | ListEnumFeedItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedItemTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CheckInCreateWithoutScannedByInput = {
    id?: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
    ticket: TicketCreateNestedOneWithoutCheckinsInput
  }

  export type CheckInUncheckedCreateWithoutScannedByInput = {
    id?: string
    ticketId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type CheckInCreateOrConnectWithoutScannedByInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput>
  }

  export type CheckInCreateManyScannedByInputEnvelope = {
    data: CheckInCreateManyScannedByInput | CheckInCreateManyScannedByInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventCreateManyCreatedByInputEnvelope = {
    data: EventCreateManyCreatedByInput | EventCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InviteLinkCreateWithoutCreatedByInput = {
    id?: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutInviteLinksInput
    prProfile?: PRProfileCreateNestedOneWithoutInviteLinksInput
  }

  export type InviteLinkUncheckedCreateWithoutCreatedByInput = {
    id?: string
    eventId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkCreateOrConnectWithoutCreatedByInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput>
  }

  export type InviteLinkCreateManyCreatedByInputEnvelope = {
    data: InviteLinkCreateManyCreatedByInput | InviteLinkCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ListEntryCreateWithoutAddedByInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guest?: GuestCreateNestedOneWithoutListEntriesInput
    list: ListCreateNestedOneWithoutEntriesInput
    tickets?: TicketCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryUncheckedCreateWithoutAddedByInput = {
    id?: string
    listId: string
    guestId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryCreateOrConnectWithoutAddedByInput = {
    where: ListEntryWhereUniqueInput
    create: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput>
  }

  export type ListEntryCreateManyAddedByInputEnvelope = {
    data: ListEntryCreateManyAddedByInput | ListEntryCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type PRProfileCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutPrProfileInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutPrProfileInput
  }

  export type PRProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutPrProfileInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutPrProfileInput
  }

  export type PRProfileCreateOrConnectWithoutUserInput = {
    where: PRProfileWhereUniqueInput
    create: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
  }

  export type SecurityNoteCreateWithoutReportedByInput = {
    id?: string
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
    event?: EventCreateNestedOneWithoutSecurityNotesInput
    guest?: GuestCreateNestedOneWithoutSecurityNotesInput
    ticket?: TicketCreateNestedOneWithoutSecurityNotesInput
  }

  export type SecurityNoteUncheckedCreateWithoutReportedByInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteCreateOrConnectWithoutReportedByInput = {
    where: SecurityNoteWhereUniqueInput
    create: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput>
  }

  export type SecurityNoteCreateManyReportedByInputEnvelope = {
    data: SecurityNoteCreateManyReportedByInput | SecurityNoteCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutIssuedByInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutIssuedByInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutIssuedByInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput>
  }

  export type TicketCreateManyIssuedByInputEnvelope = {
    data: TicketCreateManyIssuedByInput | TicketCreateManyIssuedByInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutUserInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateManyUserInputEnvelope = {
    data: TicketCreateManyUserInput | TicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutOwnerInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    venues?: VenueUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutOwnerInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput>
  }

  export type ClubCreateManyOwnerInputEnvelope = {
    data: ClubCreateManyOwnerInput | ClubCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationProfileCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationProfileUncheckedCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationProfileCreateOrConnectWithoutUserInput = {
    where: OrganizationProfileWhereUniqueInput
    create: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
  }

  export type ArtistProfileCreateWithoutUserInput = {
    id?: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performances?: PerformanceCreateNestedManyWithoutArtistInput
    mediaGallery?: ArtistMediaCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileUncheckedCreateWithoutUserInput = {
    id?: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performances?: PerformanceUncheckedCreateNestedManyWithoutArtistInput
    mediaGallery?: ArtistMediaUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileCreateOrConnectWithoutUserInput = {
    where: ArtistProfileWhereUniqueInput
    create: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    bio?: string | null
    avatar?: string | null
    coverImage?: string | null
    provincia?: string | null
    city?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    interests?: UserProfileCreateinterestsInput | string[]
    favoriteGenres?: UserProfileCreatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileCreatepreferredVenuesInput | string[]
    tiktokHandle?: string | null
    spotifyUrl?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    isPublic?: boolean
    followersCount?: number
    followingCount?: number
    postsCount?: number
    verifiedBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    bio?: string | null
    avatar?: string | null
    coverImage?: string | null
    provincia?: string | null
    city?: string | null
    birthDate?: Date | string | null
    gender?: $Enums.Gender | null
    interests?: UserProfileCreateinterestsInput | string[]
    favoriteGenres?: UserProfileCreatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileCreatepreferredVenuesInput | string[]
    tiktokHandle?: string | null
    spotifyUrl?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    isPublic?: boolean
    followersCount?: number
    followingCount?: number
    postsCount?: number
    verifiedBadge?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type FeedItemCreateWithoutAuthorInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FeedLikeCreateNestedManyWithoutFeedItemInput
    comments?: FeedCommentCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemUncheckedCreateWithoutAuthorInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FeedLikeUncheckedCreateNestedManyWithoutFeedItemInput
    comments?: FeedCommentUncheckedCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemCreateOrConnectWithoutAuthorInput = {
    where: FeedItemWhereUniqueInput
    create: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput>
  }

  export type FeedItemCreateManyAuthorInputEnvelope = {
    data: FeedItemCreateManyAuthorInput | FeedItemCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type FeedLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    feedItem: FeedItemCreateNestedOneWithoutLikesInput
  }

  export type FeedLikeUncheckedCreateWithoutUserInput = {
    id?: string
    feedItemId: string
    createdAt?: Date | string
  }

  export type FeedLikeCreateOrConnectWithoutUserInput = {
    where: FeedLikeWhereUniqueInput
    create: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput>
  }

  export type FeedLikeCreateManyUserInputEnvelope = {
    data: FeedLikeCreateManyUserInput | FeedLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feedItem: FeedItemCreateNestedOneWithoutCommentsInput
  }

  export type FeedCommentUncheckedCreateWithoutUserInput = {
    id?: string
    feedItemId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedCommentCreateOrConnectWithoutUserInput = {
    where: FeedCommentWhereUniqueInput
    create: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput>
  }

  export type FeedCommentCreateManyUserInputEnvelope = {
    data: FeedCommentCreateManyUserInput | FeedCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type UserFollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowCreateManyFollowingInputEnvelope = {
    data: UserFollowCreateManyFollowingInput | UserFollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type UserFollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowCreateManyFollowerInputEnvelope = {
    data: UserFollowCreateManyFollowerInput | UserFollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type IdentityVerificationCreateWithoutUserInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer?: UserCreateNestedOneWithoutReviewedVerificationsInput
  }

  export type IdentityVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityVerificationCreateOrConnectWithoutUserInput = {
    where: IdentityVerificationWhereUniqueInput
    create: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput>
  }

  export type IdentityVerificationCreateManyUserInputEnvelope = {
    data: IdentityVerificationCreateManyUserInput | IdentityVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IdentityVerificationCreateWithoutReviewerInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdentityVerificationsInput
  }

  export type IdentityVerificationUncheckedCreateWithoutReviewerInput = {
    id?: string
    userId: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityVerificationCreateOrConnectWithoutReviewerInput = {
    where: IdentityVerificationWhereUniqueInput
    create: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput>
  }

  export type IdentityVerificationCreateManyReviewerInputEnvelope = {
    data: IdentityVerificationCreateManyReviewerInput | IdentityVerificationCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type UserPhoneCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    phoneVerified?: boolean
    phoneVerifiedAt?: Date | string | null
    otpCode?: string | null
    otpExpiresAt?: Date | string | null
    otpAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneUncheckedCreateWithoutUserInput = {
    id?: string
    phoneNumber: string
    phoneVerified?: boolean
    phoneVerifiedAt?: Date | string | null
    otpCode?: string | null
    otpExpiresAt?: Date | string | null
    otpAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhoneCreateOrConnectWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserConsentCreateWithoutUserInput = {
    id?: string
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyAcceptedAt?: Date | string | null
    marketingOptIn?: boolean
    marketingOptInAt?: Date | string | null
    newsletterOptIn?: boolean
    newsletterOptInAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConsentUncheckedCreateWithoutUserInput = {
    id?: string
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    privacyAccepted?: boolean
    privacyAcceptedAt?: Date | string | null
    marketingOptIn?: boolean
    marketingOptInAt?: Date | string | null
    newsletterOptIn?: boolean
    newsletterOptInAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConsentCreateOrConnectWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type OnboardingProgressCreateWithoutUserInput = {
    id?: string
    currentStep?: number
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUncheckedCreateWithoutUserInput = {
    id?: string
    currentStep?: number
    step1Completed?: boolean
    step2Completed?: boolean
    step3Completed?: boolean
    onboardingComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressCreateOrConnectWithoutUserInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CheckInUpsertWithWhereUniqueWithoutScannedByInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutScannedByInput, CheckInUncheckedUpdateWithoutScannedByInput>
    create: XOR<CheckInCreateWithoutScannedByInput, CheckInUncheckedCreateWithoutScannedByInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutScannedByInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutScannedByInput, CheckInUncheckedUpdateWithoutScannedByInput>
  }

  export type CheckInUpdateManyWithWhereWithoutScannedByInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutScannedByInput>
  }

  export type CheckInScalarWhereInput = {
    AND?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    OR?: CheckInScalarWhereInput[]
    NOT?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    ticketId?: StringFilter<"CheckIn"> | string
    scannedByUserId?: StringFilter<"CheckIn"> | string
    scannedAt?: DateTimeFilter<"CheckIn"> | Date | string
    gate?: EnumGateFilter<"CheckIn"> | $Enums.Gate
    ok?: BoolFilter<"CheckIn"> | boolean
    notes?: StringNullableFilter<"CheckIn"> | string | null
    arrivalTime?: StringNullableFilter<"CheckIn"> | string | null
    groupSize?: IntFilter<"CheckIn"> | number
  }

  export type EventUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatedByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    coverUrl?: StringNullableFilter<"Event"> | string | null
    dateStart?: DateTimeFilter<"Event"> | Date | string
    dateEnd?: DateTimeNullableFilter<"Event"> | Date | string | null
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    minAge?: IntNullableFilter<"Event"> | number | null
    dressCode?: StringNullableFilter<"Event"> | string | null
    venueId?: StringFilter<"Event"> | string
    createdByUserId?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutCreatedByInput, InviteLinkUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InviteLinkCreateWithoutCreatedByInput, InviteLinkUncheckedCreateWithoutCreatedByInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutCreatedByInput, InviteLinkUncheckedUpdateWithoutCreatedByInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutCreatedByInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InviteLinkScalarWhereInput = {
    AND?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
    OR?: InviteLinkScalarWhereInput[]
    NOT?: InviteLinkScalarWhereInput | InviteLinkScalarWhereInput[]
    id?: StringFilter<"InviteLink"> | string
    createdByUserId?: StringFilter<"InviteLink"> | string
    eventId?: StringFilter<"InviteLink"> | string
    prProfileId?: StringNullableFilter<"InviteLink"> | string | null
    slug?: StringFilter<"InviteLink"> | string
    maxUses?: IntNullableFilter<"InviteLink"> | number | null
    uses?: IntFilter<"InviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"InviteLink"> | Date | string | null
    utmSource?: StringNullableFilter<"InviteLink"> | string | null
    utmMedium?: StringNullableFilter<"InviteLink"> | string | null
    utmCampaign?: StringNullableFilter<"InviteLink"> | string | null
    createdAt?: DateTimeFilter<"InviteLink"> | Date | string
    updatedAt?: DateTimeFilter<"InviteLink"> | Date | string
  }

  export type ListEntryUpsertWithWhereUniqueWithoutAddedByInput = {
    where: ListEntryWhereUniqueInput
    update: XOR<ListEntryUpdateWithoutAddedByInput, ListEntryUncheckedUpdateWithoutAddedByInput>
    create: XOR<ListEntryCreateWithoutAddedByInput, ListEntryUncheckedCreateWithoutAddedByInput>
  }

  export type ListEntryUpdateWithWhereUniqueWithoutAddedByInput = {
    where: ListEntryWhereUniqueInput
    data: XOR<ListEntryUpdateWithoutAddedByInput, ListEntryUncheckedUpdateWithoutAddedByInput>
  }

  export type ListEntryUpdateManyWithWhereWithoutAddedByInput = {
    where: ListEntryScalarWhereInput
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyWithoutAddedByInput>
  }

  export type ListEntryScalarWhereInput = {
    AND?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
    OR?: ListEntryScalarWhereInput[]
    NOT?: ListEntryScalarWhereInput | ListEntryScalarWhereInput[]
    id?: StringFilter<"ListEntry"> | string
    listId?: StringFilter<"ListEntry"> | string
    guestId?: StringNullableFilter<"ListEntry"> | string | null
    addedByUserId?: StringFilter<"ListEntry"> | string
    firstName?: StringFilter<"ListEntry"> | string
    lastName?: StringFilter<"ListEntry"> | string
    phone?: StringNullableFilter<"ListEntry"> | string | null
    email?: StringNullableFilter<"ListEntry"> | string | null
    gender?: EnumGenderFilter<"ListEntry"> | $Enums.Gender
    note?: StringNullableFilter<"ListEntry"> | string | null
    createdVia?: EnumCreatedViaFilter<"ListEntry"> | $Enums.CreatedVia
    status?: EnumEntryStatusFilter<"ListEntry"> | $Enums.EntryStatus
    plusOne?: BoolFilter<"ListEntry"> | boolean
    bookingMethod?: EnumBookingMethodFilter<"ListEntry"> | $Enums.BookingMethod
    referralSource?: StringNullableFilter<"ListEntry"> | string | null
    groupSize?: IntFilter<"ListEntry"> | number
    createdAt?: DateTimeFilter<"ListEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ListEntry"> | Date | string
  }

  export type PRProfileUpsertWithoutUserInput = {
    update: XOR<PRProfileUpdateWithoutUserInput, PRProfileUncheckedUpdateWithoutUserInput>
    create: XOR<PRProfileCreateWithoutUserInput, PRProfileUncheckedCreateWithoutUserInput>
    where?: PRProfileWhereInput
  }

  export type PRProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: PRProfileWhereInput
    data: XOR<PRProfileUpdateWithoutUserInput, PRProfileUncheckedUpdateWithoutUserInput>
  }

  export type PRProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutPrProfileNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutPrProfileNestedInput
  }

  export type PRProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutPrProfileNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutPrProfileNestedInput
  }

  export type SecurityNoteUpsertWithWhereUniqueWithoutReportedByInput = {
    where: SecurityNoteWhereUniqueInput
    update: XOR<SecurityNoteUpdateWithoutReportedByInput, SecurityNoteUncheckedUpdateWithoutReportedByInput>
    create: XOR<SecurityNoteCreateWithoutReportedByInput, SecurityNoteUncheckedCreateWithoutReportedByInput>
  }

  export type SecurityNoteUpdateWithWhereUniqueWithoutReportedByInput = {
    where: SecurityNoteWhereUniqueInput
    data: XOR<SecurityNoteUpdateWithoutReportedByInput, SecurityNoteUncheckedUpdateWithoutReportedByInput>
  }

  export type SecurityNoteUpdateManyWithWhereWithoutReportedByInput = {
    where: SecurityNoteScalarWhereInput
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyWithoutReportedByInput>
  }

  export type SecurityNoteScalarWhereInput = {
    AND?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
    OR?: SecurityNoteScalarWhereInput[]
    NOT?: SecurityNoteScalarWhereInput | SecurityNoteScalarWhereInput[]
    id?: StringFilter<"SecurityNote"> | string
    guestId?: StringNullableFilter<"SecurityNote"> | string | null
    eventId?: StringNullableFilter<"SecurityNote"> | string | null
    ticketId?: StringNullableFilter<"SecurityNote"> | string | null
    severity?: StringFilter<"SecurityNote"> | string
    type?: StringFilter<"SecurityNote"> | string
    description?: StringFilter<"SecurityNote"> | string
    reportedByUserId?: StringFilter<"SecurityNote"> | string
    actionTaken?: StringNullableFilter<"SecurityNote"> | string | null
    createdAt?: DateTimeFilter<"SecurityNote"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutIssuedByInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutIssuedByInput, TicketUncheckedUpdateWithoutIssuedByInput>
    create: XOR<TicketCreateWithoutIssuedByInput, TicketUncheckedCreateWithoutIssuedByInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutIssuedByInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutIssuedByInput, TicketUncheckedUpdateWithoutIssuedByInput>
  }

  export type TicketUpdateManyWithWhereWithoutIssuedByInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutIssuedByInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    userId?: StringNullableFilter<"Ticket"> | string | null
    guestId?: StringNullableFilter<"Ticket"> | string | null
    listEntryId?: StringNullableFilter<"Ticket"> | string | null
    issuedByUserId?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    price?: FloatNullableFilter<"Ticket"> | number | null
    currency?: StringNullableFilter<"Ticket"> | string | null
    code?: StringFilter<"Ticket"> | string
    qrData?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    issuedAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUserInput>
  }

  export type ClubUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ClubWhereUniqueInput
    update: XOR<ClubUpdateWithoutOwnerInput, ClubUncheckedUpdateWithoutOwnerInput>
    create: XOR<ClubCreateWithoutOwnerInput, ClubUncheckedCreateWithoutOwnerInput>
  }

  export type ClubUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ClubWhereUniqueInput
    data: XOR<ClubUpdateWithoutOwnerInput, ClubUncheckedUpdateWithoutOwnerInput>
  }

  export type ClubUpdateManyWithWhereWithoutOwnerInput = {
    where: ClubScalarWhereInput
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ClubScalarWhereInput = {
    AND?: ClubScalarWhereInput | ClubScalarWhereInput[]
    OR?: ClubScalarWhereInput[]
    NOT?: ClubScalarWhereInput | ClubScalarWhereInput[]
    id?: StringFilter<"Club"> | string
    name?: StringFilter<"Club"> | string
    type?: EnumClubTypeFilter<"Club"> | $Enums.ClubType
    description?: StringNullableFilter<"Club"> | string | null
    logo?: StringNullableFilter<"Club"> | string | null
    coverImage?: StringNullableFilter<"Club"> | string | null
    gallery?: StringNullableListFilter<"Club">
    website?: StringNullableFilter<"Club"> | string | null
    phone?: StringNullableFilter<"Club"> | string | null
    email?: StringNullableFilter<"Club"> | string | null
    instagram?: StringNullableFilter<"Club"> | string | null
    facebook?: StringNullableFilter<"Club"> | string | null
    openingHours?: StringNullableFilter<"Club"> | string | null
    priceRange?: StringNullableFilter<"Club"> | string | null
    amenities?: StringNullableListFilter<"Club">
    musicGenres?: StringNullableListFilter<"Club">
    ownerId?: StringFilter<"Club"> | string
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
  }

  export type OrganizationProfileUpsertWithoutUserInput = {
    update: XOR<OrganizationProfileUpdateWithoutUserInput, OrganizationProfileUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationProfileCreateWithoutUserInput, OrganizationProfileUncheckedCreateWithoutUserInput>
    where?: OrganizationProfileWhereInput
  }

  export type OrganizationProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: OrganizationProfileWhereInput
    data: XOR<OrganizationProfileUpdateWithoutUserInput, OrganizationProfileUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ArtistProfileUpsertWithoutUserInput = {
    update: XOR<ArtistProfileUpdateWithoutUserInput, ArtistProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ArtistProfileCreateWithoutUserInput, ArtistProfileUncheckedCreateWithoutUserInput>
    where?: ArtistProfileWhereInput
  }

  export type ArtistProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ArtistProfileWhereInput
    data: XOR<ArtistProfileUpdateWithoutUserInput, ArtistProfileUncheckedUpdateWithoutUserInput>
  }

  export type ArtistProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performances?: PerformanceUpdateManyWithoutArtistNestedInput
    mediaGallery?: ArtistMediaUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performances?: PerformanceUncheckedUpdateManyWithoutArtistNestedInput
    mediaGallery?: ArtistMediaUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    interests?: UserProfileUpdateinterestsInput | string[]
    favoriteGenres?: UserProfileUpdatefavoriteGenresInput | string[]
    preferredVenues?: UserProfileUpdatepreferredVenuesInput | string[]
    tiktokHandle?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    verifiedBadge?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUpsertWithWhereUniqueWithoutAuthorInput = {
    where: FeedItemWhereUniqueInput
    update: XOR<FeedItemUpdateWithoutAuthorInput, FeedItemUncheckedUpdateWithoutAuthorInput>
    create: XOR<FeedItemCreateWithoutAuthorInput, FeedItemUncheckedCreateWithoutAuthorInput>
  }

  export type FeedItemUpdateWithWhereUniqueWithoutAuthorInput = {
    where: FeedItemWhereUniqueInput
    data: XOR<FeedItemUpdateWithoutAuthorInput, FeedItemUncheckedUpdateWithoutAuthorInput>
  }

  export type FeedItemUpdateManyWithWhereWithoutAuthorInput = {
    where: FeedItemScalarWhereInput
    data: XOR<FeedItemUpdateManyMutationInput, FeedItemUncheckedUpdateManyWithoutAuthorInput>
  }

  export type FeedItemScalarWhereInput = {
    AND?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
    OR?: FeedItemScalarWhereInput[]
    NOT?: FeedItemScalarWhereInput | FeedItemScalarWhereInput[]
    id?: StringFilter<"FeedItem"> | string
    authorId?: StringFilter<"FeedItem"> | string
    type?: EnumFeedItemTypeFilter<"FeedItem"> | $Enums.FeedItemType
    content?: StringNullableFilter<"FeedItem"> | string | null
    imageUrl?: StringNullableFilter<"FeedItem"> | string | null
    videoUrl?: StringNullableFilter<"FeedItem"> | string | null
    eventId?: StringNullableFilter<"FeedItem"> | string | null
    visibility?: EnumVisibilityFilter<"FeedItem"> | $Enums.Visibility
    likesCount?: IntFilter<"FeedItem"> | number
    commentsCount?: IntFilter<"FeedItem"> | number
    createdAt?: DateTimeFilter<"FeedItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeedItem"> | Date | string
  }

  export type FeedLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedLikeWhereUniqueInput
    update: XOR<FeedLikeUpdateWithoutUserInput, FeedLikeUncheckedUpdateWithoutUserInput>
    create: XOR<FeedLikeCreateWithoutUserInput, FeedLikeUncheckedCreateWithoutUserInput>
  }

  export type FeedLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedLikeWhereUniqueInput
    data: XOR<FeedLikeUpdateWithoutUserInput, FeedLikeUncheckedUpdateWithoutUserInput>
  }

  export type FeedLikeUpdateManyWithWhereWithoutUserInput = {
    where: FeedLikeScalarWhereInput
    data: XOR<FeedLikeUpdateManyMutationInput, FeedLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedLikeScalarWhereInput = {
    AND?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
    OR?: FeedLikeScalarWhereInput[]
    NOT?: FeedLikeScalarWhereInput | FeedLikeScalarWhereInput[]
    id?: StringFilter<"FeedLike"> | string
    feedItemId?: StringFilter<"FeedLike"> | string
    userId?: StringFilter<"FeedLike"> | string
    createdAt?: DateTimeFilter<"FeedLike"> | Date | string
  }

  export type FeedCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedCommentWhereUniqueInput
    update: XOR<FeedCommentUpdateWithoutUserInput, FeedCommentUncheckedUpdateWithoutUserInput>
    create: XOR<FeedCommentCreateWithoutUserInput, FeedCommentUncheckedCreateWithoutUserInput>
  }

  export type FeedCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedCommentWhereUniqueInput
    data: XOR<FeedCommentUpdateWithoutUserInput, FeedCommentUncheckedUpdateWithoutUserInput>
  }

  export type FeedCommentUpdateManyWithWhereWithoutUserInput = {
    where: FeedCommentScalarWhereInput
    data: XOR<FeedCommentUpdateManyMutationInput, FeedCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedCommentScalarWhereInput = {
    AND?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
    OR?: FeedCommentScalarWhereInput[]
    NOT?: FeedCommentScalarWhereInput | FeedCommentScalarWhereInput[]
    id?: StringFilter<"FeedComment"> | string
    feedItemId?: StringFilter<"FeedComment"> | string
    userId?: StringFilter<"FeedComment"> | string
    content?: StringFilter<"FeedComment"> | string
    createdAt?: DateTimeFilter<"FeedComment"> | Date | string
    updatedAt?: DateTimeFilter<"FeedComment"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowingInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type UserFollowScalarWhereInput = {
    AND?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    OR?: UserFollowScalarWhereInput[]
    NOT?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    followerId?: StringFilter<"UserFollow"> | string
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowerInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type IdentityVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: IdentityVerificationWhereUniqueInput
    update: XOR<IdentityVerificationUpdateWithoutUserInput, IdentityVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<IdentityVerificationCreateWithoutUserInput, IdentityVerificationUncheckedCreateWithoutUserInput>
  }

  export type IdentityVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: IdentityVerificationWhereUniqueInput
    data: XOR<IdentityVerificationUpdateWithoutUserInput, IdentityVerificationUncheckedUpdateWithoutUserInput>
  }

  export type IdentityVerificationUpdateManyWithWhereWithoutUserInput = {
    where: IdentityVerificationScalarWhereInput
    data: XOR<IdentityVerificationUpdateManyMutationInput, IdentityVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type IdentityVerificationScalarWhereInput = {
    AND?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
    OR?: IdentityVerificationScalarWhereInput[]
    NOT?: IdentityVerificationScalarWhereInput | IdentityVerificationScalarWhereInput[]
    id?: StringFilter<"IdentityVerification"> | string
    userId?: StringFilter<"IdentityVerification"> | string
    documentType?: EnumDocumentTypeFilter<"IdentityVerification"> | $Enums.DocumentType
    documentNumber?: StringNullableFilter<"IdentityVerification"> | string | null
    documentFrontUrl?: StringFilter<"IdentityVerification"> | string
    documentBackUrl?: StringNullableFilter<"IdentityVerification"> | string | null
    selfieUrl?: StringFilter<"IdentityVerification"> | string
    status?: EnumVerificationStatusFilter<"IdentityVerification"> | $Enums.VerificationStatus
    reviewedBy?: StringNullableFilter<"IdentityVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableFilter<"IdentityVerification"> | string | null
    expiresAt?: DateTimeNullableFilter<"IdentityVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"IdentityVerification"> | Date | string
    updatedAt?: DateTimeFilter<"IdentityVerification"> | Date | string
  }

  export type IdentityVerificationUpsertWithWhereUniqueWithoutReviewerInput = {
    where: IdentityVerificationWhereUniqueInput
    update: XOR<IdentityVerificationUpdateWithoutReviewerInput, IdentityVerificationUncheckedUpdateWithoutReviewerInput>
    create: XOR<IdentityVerificationCreateWithoutReviewerInput, IdentityVerificationUncheckedCreateWithoutReviewerInput>
  }

  export type IdentityVerificationUpdateWithWhereUniqueWithoutReviewerInput = {
    where: IdentityVerificationWhereUniqueInput
    data: XOR<IdentityVerificationUpdateWithoutReviewerInput, IdentityVerificationUncheckedUpdateWithoutReviewerInput>
  }

  export type IdentityVerificationUpdateManyWithWhereWithoutReviewerInput = {
    where: IdentityVerificationScalarWhereInput
    data: XOR<IdentityVerificationUpdateManyMutationInput, IdentityVerificationUncheckedUpdateManyWithoutReviewerInput>
  }

  export type UserPhoneUpsertWithoutUserInput = {
    update: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    where?: UserPhoneWhereInput
  }

  export type UserPhoneUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPhoneWhereInput
    data: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type UserPhoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUpsertWithoutUserInput = {
    update: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
    where?: UserConsentWhereInput
  }

  export type UserConsentUpdateToOneWithWhereWithoutUserInput = {
    where?: UserConsentWhereInput
    data: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    privacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    privacyAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketingOptIn?: BoolFieldUpdateOperationsInput | boolean
    marketingOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean
    newsletterOptInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUpsertWithoutUserInput = {
    update: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    where?: OnboardingProgressWhereInput
  }

  export type OnboardingProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: OnboardingProgressWhereInput
    data: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    step1Completed?: BoolFieldUpdateOperationsInput | boolean
    step2Completed?: BoolFieldUpdateOperationsInput | boolean
    step3Completed?: BoolFieldUpdateOperationsInput | boolean
    onboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutClubsOwnedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClubsOwnedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClubsOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClubsOwnedInput, UserUncheckedCreateWithoutClubsOwnedInput>
  }

  export type VenueCreateWithoutClubInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutClubInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutClubInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput>
  }

  export type VenueCreateManyClubInputEnvelope = {
    data: VenueCreateManyClubInput | VenueCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClubsOwnedInput = {
    update: XOR<UserUpdateWithoutClubsOwnedInput, UserUncheckedUpdateWithoutClubsOwnedInput>
    create: XOR<UserCreateWithoutClubsOwnedInput, UserUncheckedCreateWithoutClubsOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClubsOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClubsOwnedInput, UserUncheckedUpdateWithoutClubsOwnedInput>
  }

  export type UserUpdateWithoutClubsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClubsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VenueUpsertWithWhereUniqueWithoutClubInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutClubInput, VenueUncheckedUpdateWithoutClubInput>
    create: XOR<VenueCreateWithoutClubInput, VenueUncheckedCreateWithoutClubInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutClubInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutClubInput, VenueUncheckedUpdateWithoutClubInput>
  }

  export type VenueUpdateManyWithWhereWithoutClubInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutClubInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    slug?: StringNullableFilter<"Venue"> | string | null
    address?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    capacity?: IntNullableFilter<"Venue"> | number | null
    whatsappNumber?: StringNullableFilter<"Venue"> | string | null
    telegramHandle?: StringNullableFilter<"Venue"> | string | null
    clubId?: StringNullableFilter<"Venue"> | string | null
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
  }

  export type ClubCreateWithoutVenuesInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutClubsOwnedInput
  }

  export type ClubUncheckedCreateWithoutVenuesInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubCreateOrConnectWithoutVenuesInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutVenuesInput, ClubUncheckedCreateWithoutVenuesInput>
  }

  export type EventCreateWithoutVenueInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutVenueInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutVenueInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventCreateManyVenueInputEnvelope = {
    data: EventCreateManyVenueInput | EventCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ClubUpsertWithoutVenuesInput = {
    update: XOR<ClubUpdateWithoutVenuesInput, ClubUncheckedUpdateWithoutVenuesInput>
    create: XOR<ClubCreateWithoutVenuesInput, ClubUncheckedCreateWithoutVenuesInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutVenuesInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutVenuesInput, ClubUncheckedUpdateWithoutVenuesInput>
  }

  export type ClubUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutClubsOwnedNestedInput
  }

  export type ClubUncheckedUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventUpdateWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
  }

  export type EventUpdateManyWithWhereWithoutVenueInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutVenueInput>
  }

  export type AssignmentCreateWithoutEventInput = {
    id?: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prProfile: PRProfileCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutEventInput = {
    id?: string
    prProfileId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutEventInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput>
  }

  export type AssignmentCreateManyEventInputEnvelope = {
    data: AssignmentCreateManyEventInput | AssignmentCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ConsumptionCreateWithoutEventInput = {
    id?: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutConsumptionsInput
  }

  export type ConsumptionUncheckedCreateWithoutEventInput = {
    id?: string
    ticketId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsumptionCreateOrConnectWithoutEventInput = {
    where: ConsumptionWhereUniqueInput
    create: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput>
  }

  export type ConsumptionCreateManyEventInputEnvelope = {
    data: ConsumptionCreateManyEventInput | ConsumptionCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventFeedbackCreateWithoutEventInput = {
    id?: string
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    guest?: GuestCreateNestedOneWithoutFeedbacksInput
    ticket?: TicketCreateNestedOneWithoutFeedbacksInput
  }

  export type EventFeedbackUncheckedCreateWithoutEventInput = {
    id?: string
    ticketId?: string | null
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackCreateOrConnectWithoutEventInput = {
    where: EventFeedbackWhereUniqueInput
    create: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput>
  }

  export type EventFeedbackCreateManyEventInputEnvelope = {
    data: EventFeedbackCreateManyEventInput | EventFeedbackCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEventsCreatedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsCreatedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
  }

  export type VenueCreateWithoutEventsInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    club?: ClubCreateNestedOneWithoutVenuesInput
  }

  export type VenueUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueCreateOrConnectWithoutEventsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
  }

  export type FunnelTrackingCreateWithoutEventInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
  }

  export type FunnelTrackingUncheckedCreateWithoutEventInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
  }

  export type FunnelTrackingCreateOrConnectWithoutEventInput = {
    where: FunnelTrackingWhereUniqueInput
    create: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput>
  }

  export type FunnelTrackingCreateManyEventInputEnvelope = {
    data: FunnelTrackingCreateManyEventInput | FunnelTrackingCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type InviteLinkCreateWithoutEventInput = {
    id?: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutInviteLinksInput
    prProfile?: PRProfileCreateNestedOneWithoutInviteLinksInput
  }

  export type InviteLinkUncheckedCreateWithoutEventInput = {
    id?: string
    createdByUserId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkCreateOrConnectWithoutEventInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput>
  }

  export type InviteLinkCreateManyEventInputEnvelope = {
    data: InviteLinkCreateManyEventInput | InviteLinkCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ListCreateWithoutEventInput = {
    id?: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: ListEntryCreateNestedManyWithoutListInput
  }

  export type ListUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: ListEntryUncheckedCreateNestedManyWithoutListInput
  }

  export type ListCreateOrConnectWithoutEventInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput>
  }

  export type ListCreateManyEventInputEnvelope = {
    data: ListCreateManyEventInput | ListCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type SecurityNoteCreateWithoutEventInput = {
    id?: string
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
    guest?: GuestCreateNestedOneWithoutSecurityNotesInput
    reportedBy: UserCreateNestedOneWithoutSecurityReportsInput
    ticket?: TicketCreateNestedOneWithoutSecurityNotesInput
  }

  export type SecurityNoteUncheckedCreateWithoutEventInput = {
    id?: string
    guestId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteCreateOrConnectWithoutEventInput = {
    where: SecurityNoteWhereUniqueInput
    create: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput>
  }

  export type SecurityNoteCreateManyEventInputEnvelope = {
    data: SecurityNoteCreateManyEventInput | SecurityNoteCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutEventInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutEventInput = {
    id?: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutEventInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketCreateManyEventInputEnvelope = {
    data: TicketCreateManyEventInput | TicketCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutEventInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutEventInput, AssignmentUncheckedUpdateWithoutEventInput>
    create: XOR<AssignmentCreateWithoutEventInput, AssignmentUncheckedCreateWithoutEventInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutEventInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutEventInput, AssignmentUncheckedUpdateWithoutEventInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutEventInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutEventInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    eventId?: StringFilter<"Assignment"> | string
    prProfileId?: StringFilter<"Assignment"> | string
    quotaTotal?: IntNullableFilter<"Assignment"> | number | null
    quotaFemale?: IntNullableFilter<"Assignment"> | number | null
    quotaMale?: IntNullableFilter<"Assignment"> | number | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type ConsumptionUpsertWithWhereUniqueWithoutEventInput = {
    where: ConsumptionWhereUniqueInput
    update: XOR<ConsumptionUpdateWithoutEventInput, ConsumptionUncheckedUpdateWithoutEventInput>
    create: XOR<ConsumptionCreateWithoutEventInput, ConsumptionUncheckedCreateWithoutEventInput>
  }

  export type ConsumptionUpdateWithWhereUniqueWithoutEventInput = {
    where: ConsumptionWhereUniqueInput
    data: XOR<ConsumptionUpdateWithoutEventInput, ConsumptionUncheckedUpdateWithoutEventInput>
  }

  export type ConsumptionUpdateManyWithWhereWithoutEventInput = {
    where: ConsumptionScalarWhereInput
    data: XOR<ConsumptionUpdateManyMutationInput, ConsumptionUncheckedUpdateManyWithoutEventInput>
  }

  export type ConsumptionScalarWhereInput = {
    AND?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
    OR?: ConsumptionScalarWhereInput[]
    NOT?: ConsumptionScalarWhereInput | ConsumptionScalarWhereInput[]
    id?: StringFilter<"Consumption"> | string
    ticketId?: StringFilter<"Consumption"> | string
    eventId?: StringFilter<"Consumption"> | string
    amount?: FloatFilter<"Consumption"> | number
    category?: StringFilter<"Consumption"> | string
    items?: JsonNullableFilter<"Consumption">
    createdAt?: DateTimeFilter<"Consumption"> | Date | string
  }

  export type EventFeedbackUpsertWithWhereUniqueWithoutEventInput = {
    where: EventFeedbackWhereUniqueInput
    update: XOR<EventFeedbackUpdateWithoutEventInput, EventFeedbackUncheckedUpdateWithoutEventInput>
    create: XOR<EventFeedbackCreateWithoutEventInput, EventFeedbackUncheckedCreateWithoutEventInput>
  }

  export type EventFeedbackUpdateWithWhereUniqueWithoutEventInput = {
    where: EventFeedbackWhereUniqueInput
    data: XOR<EventFeedbackUpdateWithoutEventInput, EventFeedbackUncheckedUpdateWithoutEventInput>
  }

  export type EventFeedbackUpdateManyWithWhereWithoutEventInput = {
    where: EventFeedbackScalarWhereInput
    data: XOR<EventFeedbackUpdateManyMutationInput, EventFeedbackUncheckedUpdateManyWithoutEventInput>
  }

  export type EventFeedbackScalarWhereInput = {
    AND?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
    OR?: EventFeedbackScalarWhereInput[]
    NOT?: EventFeedbackScalarWhereInput | EventFeedbackScalarWhereInput[]
    id?: StringFilter<"EventFeedback"> | string
    eventId?: StringFilter<"EventFeedback"> | string
    ticketId?: StringNullableFilter<"EventFeedback"> | string | null
    guestId?: StringNullableFilter<"EventFeedback"> | string | null
    overallRating?: IntFilter<"EventFeedback"> | number
    musicRating?: IntNullableFilter<"EventFeedback"> | number | null
    serviceRating?: IntNullableFilter<"EventFeedback"> | number | null
    venueRating?: IntNullableFilter<"EventFeedback"> | number | null
    comment?: StringNullableFilter<"EventFeedback"> | string | null
    wouldReturn?: BoolNullableFilter<"EventFeedback"> | boolean | null
    interests?: JsonNullableFilter<"EventFeedback">
    createdAt?: DateTimeFilter<"EventFeedback"> | Date | string
  }

  export type UserUpsertWithoutEventsCreatedInput = {
    update: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type UserUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VenueUpsertWithoutEventsInput = {
    update: XOR<VenueUpdateWithoutEventsInput, VenueUncheckedUpdateWithoutEventsInput>
    create: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutEventsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutEventsInput, VenueUncheckedUpdateWithoutEventsInput>
  }

  export type VenueUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneWithoutVenuesNestedInput
  }

  export type VenueUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingUpsertWithWhereUniqueWithoutEventInput = {
    where: FunnelTrackingWhereUniqueInput
    update: XOR<FunnelTrackingUpdateWithoutEventInput, FunnelTrackingUncheckedUpdateWithoutEventInput>
    create: XOR<FunnelTrackingCreateWithoutEventInput, FunnelTrackingUncheckedCreateWithoutEventInput>
  }

  export type FunnelTrackingUpdateWithWhereUniqueWithoutEventInput = {
    where: FunnelTrackingWhereUniqueInput
    data: XOR<FunnelTrackingUpdateWithoutEventInput, FunnelTrackingUncheckedUpdateWithoutEventInput>
  }

  export type FunnelTrackingUpdateManyWithWhereWithoutEventInput = {
    where: FunnelTrackingScalarWhereInput
    data: XOR<FunnelTrackingUpdateManyMutationInput, FunnelTrackingUncheckedUpdateManyWithoutEventInput>
  }

  export type FunnelTrackingScalarWhereInput = {
    AND?: FunnelTrackingScalarWhereInput | FunnelTrackingScalarWhereInput[]
    OR?: FunnelTrackingScalarWhereInput[]
    NOT?: FunnelTrackingScalarWhereInput | FunnelTrackingScalarWhereInput[]
    id?: StringFilter<"FunnelTracking"> | string
    sessionId?: StringFilter<"FunnelTracking"> | string
    guestEmail?: StringNullableFilter<"FunnelTracking"> | string | null
    guestPhone?: StringNullableFilter<"FunnelTracking"> | string | null
    eventId?: StringFilter<"FunnelTracking"> | string
    step?: StringFilter<"FunnelTracking"> | string
    metadata?: JsonNullableFilter<"FunnelTracking">
    userAgent?: StringNullableFilter<"FunnelTracking"> | string | null
    ipAddress?: StringNullableFilter<"FunnelTracking"> | string | null
    referer?: StringNullableFilter<"FunnelTracking"> | string | null
    timestamp?: DateTimeFilter<"FunnelTracking"> | Date | string
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutEventInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutEventInput, InviteLinkUncheckedUpdateWithoutEventInput>
    create: XOR<InviteLinkCreateWithoutEventInput, InviteLinkUncheckedCreateWithoutEventInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutEventInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutEventInput, InviteLinkUncheckedUpdateWithoutEventInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutEventInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutEventInput>
  }

  export type ListUpsertWithWhereUniqueWithoutEventInput = {
    where: ListWhereUniqueInput
    update: XOR<ListUpdateWithoutEventInput, ListUncheckedUpdateWithoutEventInput>
    create: XOR<ListCreateWithoutEventInput, ListUncheckedCreateWithoutEventInput>
  }

  export type ListUpdateWithWhereUniqueWithoutEventInput = {
    where: ListWhereUniqueInput
    data: XOR<ListUpdateWithoutEventInput, ListUncheckedUpdateWithoutEventInput>
  }

  export type ListUpdateManyWithWhereWithoutEventInput = {
    where: ListScalarWhereInput
    data: XOR<ListUpdateManyMutationInput, ListUncheckedUpdateManyWithoutEventInput>
  }

  export type ListScalarWhereInput = {
    AND?: ListScalarWhereInput | ListScalarWhereInput[]
    OR?: ListScalarWhereInput[]
    NOT?: ListScalarWhereInput | ListScalarWhereInput[]
    id?: StringFilter<"List"> | string
    eventId?: StringFilter<"List"> | string
    name?: StringFilter<"List"> | string
    type?: EnumListTypeFilter<"List"> | $Enums.ListType
    quotaTotal?: IntNullableFilter<"List"> | number | null
    quotaFemale?: IntNullableFilter<"List"> | number | null
    quotaMale?: IntNullableFilter<"List"> | number | null
    createdAt?: DateTimeFilter<"List"> | Date | string
    updatedAt?: DateTimeFilter<"List"> | Date | string
  }

  export type SecurityNoteUpsertWithWhereUniqueWithoutEventInput = {
    where: SecurityNoteWhereUniqueInput
    update: XOR<SecurityNoteUpdateWithoutEventInput, SecurityNoteUncheckedUpdateWithoutEventInput>
    create: XOR<SecurityNoteCreateWithoutEventInput, SecurityNoteUncheckedCreateWithoutEventInput>
  }

  export type SecurityNoteUpdateWithWhereUniqueWithoutEventInput = {
    where: SecurityNoteWhereUniqueInput
    data: XOR<SecurityNoteUpdateWithoutEventInput, SecurityNoteUncheckedUpdateWithoutEventInput>
  }

  export type SecurityNoteUpdateManyWithWhereWithoutEventInput = {
    where: SecurityNoteScalarWhereInput
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyWithoutEventInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
  }

  export type TicketUpdateManyWithWhereWithoutEventInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutEventInput>
  }

  export type AssignmentCreateWithoutPrProfileInput = {
    id?: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutPrProfileInput = {
    id?: string
    eventId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutPrProfileInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput>
  }

  export type AssignmentCreateManyPrProfileInputEnvelope = {
    data: AssignmentCreateManyPrProfileInput | AssignmentCreateManyPrProfileInput[]
    skipDuplicates?: boolean
  }

  export type InviteLinkCreateWithoutPrProfileInput = {
    id?: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutInviteLinksInput
    event: EventCreateNestedOneWithoutInviteLinksInput
  }

  export type InviteLinkUncheckedCreateWithoutPrProfileInput = {
    id?: string
    createdByUserId: string
    eventId: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkCreateOrConnectWithoutPrProfileInput = {
    where: InviteLinkWhereUniqueInput
    create: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput>
  }

  export type InviteLinkCreateManyPrProfileInputEnvelope = {
    data: InviteLinkCreateManyPrProfileInput | InviteLinkCreateManyPrProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPrProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrProfileInput, UserUncheckedCreateWithoutPrProfileInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutPrProfileInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutPrProfileInput, AssignmentUncheckedUpdateWithoutPrProfileInput>
    create: XOR<AssignmentCreateWithoutPrProfileInput, AssignmentUncheckedCreateWithoutPrProfileInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutPrProfileInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutPrProfileInput, AssignmentUncheckedUpdateWithoutPrProfileInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutPrProfileInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutPrProfileInput>
  }

  export type InviteLinkUpsertWithWhereUniqueWithoutPrProfileInput = {
    where: InviteLinkWhereUniqueInput
    update: XOR<InviteLinkUpdateWithoutPrProfileInput, InviteLinkUncheckedUpdateWithoutPrProfileInput>
    create: XOR<InviteLinkCreateWithoutPrProfileInput, InviteLinkUncheckedCreateWithoutPrProfileInput>
  }

  export type InviteLinkUpdateWithWhereUniqueWithoutPrProfileInput = {
    where: InviteLinkWhereUniqueInput
    data: XOR<InviteLinkUpdateWithoutPrProfileInput, InviteLinkUncheckedUpdateWithoutPrProfileInput>
  }

  export type InviteLinkUpdateManyWithWhereWithoutPrProfileInput = {
    where: InviteLinkScalarWhereInput
    data: XOR<InviteLinkUpdateManyMutationInput, InviteLinkUncheckedUpdateManyWithoutPrProfileInput>
  }

  export type UserUpsertWithoutPrProfileInput = {
    update: XOR<UserUpdateWithoutPrProfileInput, UserUncheckedUpdateWithoutPrProfileInput>
    create: XOR<UserCreateWithoutPrProfileInput, UserUncheckedCreateWithoutPrProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrProfileInput, UserUncheckedUpdateWithoutPrProfileInput>
  }

  export type UserUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EventCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutAssignmentsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAssignmentsInput, EventUncheckedCreateWithoutAssignmentsInput>
  }

  export type PRProfileCreateWithoutAssignmentsInput = {
    id?: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inviteLinks?: InviteLinkCreateNestedManyWithoutPrProfileInput
    user: UserCreateNestedOneWithoutPrProfileInput
  }

  export type PRProfileUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    userId: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutPrProfileInput
  }

  export type PRProfileCreateOrConnectWithoutAssignmentsInput = {
    where: PRProfileWhereUniqueInput
    create: XOR<PRProfileCreateWithoutAssignmentsInput, PRProfileUncheckedCreateWithoutAssignmentsInput>
  }

  export type EventUpsertWithoutAssignmentsInput = {
    update: XOR<EventUpdateWithoutAssignmentsInput, EventUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<EventCreateWithoutAssignmentsInput, EventUncheckedCreateWithoutAssignmentsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutAssignmentsInput, EventUncheckedUpdateWithoutAssignmentsInput>
  }

  export type EventUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type PRProfileUpsertWithoutAssignmentsInput = {
    update: XOR<PRProfileUpdateWithoutAssignmentsInput, PRProfileUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<PRProfileCreateWithoutAssignmentsInput, PRProfileUncheckedCreateWithoutAssignmentsInput>
    where?: PRProfileWhereInput
  }

  export type PRProfileUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: PRProfileWhereInput
    data: XOR<PRProfileUpdateWithoutAssignmentsInput, PRProfileUncheckedUpdateWithoutAssignmentsInput>
  }

  export type PRProfileUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteLinks?: InviteLinkUpdateManyWithoutPrProfileNestedInput
    user?: UserUpdateOneRequiredWithoutPrProfileNestedInput
  }

  export type PRProfileUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutPrProfileNestedInput
  }

  export type ListEntryCreateWithoutListInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutListEntriesInput
    guest?: GuestCreateNestedOneWithoutListEntriesInput
    tickets?: TicketCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryUncheckedCreateWithoutListInput = {
    id?: string
    guestId?: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryCreateOrConnectWithoutListInput = {
    where: ListEntryWhereUniqueInput
    create: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput>
  }

  export type ListEntryCreateManyListInputEnvelope = {
    data: ListEntryCreateManyListInput | ListEntryCreateManyListInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutListsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutListsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutListsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutListsInput, EventUncheckedCreateWithoutListsInput>
  }

  export type ListEntryUpsertWithWhereUniqueWithoutListInput = {
    where: ListEntryWhereUniqueInput
    update: XOR<ListEntryUpdateWithoutListInput, ListEntryUncheckedUpdateWithoutListInput>
    create: XOR<ListEntryCreateWithoutListInput, ListEntryUncheckedCreateWithoutListInput>
  }

  export type ListEntryUpdateWithWhereUniqueWithoutListInput = {
    where: ListEntryWhereUniqueInput
    data: XOR<ListEntryUpdateWithoutListInput, ListEntryUncheckedUpdateWithoutListInput>
  }

  export type ListEntryUpdateManyWithWhereWithoutListInput = {
    where: ListEntryScalarWhereInput
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyWithoutListInput>
  }

  export type EventUpsertWithoutListsInput = {
    update: XOR<EventUpdateWithoutListsInput, EventUncheckedUpdateWithoutListsInput>
    create: XOR<EventCreateWithoutListsInput, EventUncheckedCreateWithoutListsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutListsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutListsInput, EventUncheckedUpdateWithoutListsInput>
  }

  export type EventUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CustomerPreferencesCreateWithoutGuestInput = {
    id?: string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: number | null
    responseToPromo?: string | null
    socialEngagement?: string | null
    conversionScore?: number | null
    lifetimeValue?: number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type CustomerPreferencesUncheckedCreateWithoutGuestInput = {
    id?: string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: number | null
    responseToPromo?: string | null
    socialEngagement?: string | null
    conversionScore?: number | null
    lifetimeValue?: number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type CustomerPreferencesCreateOrConnectWithoutGuestInput = {
    where: CustomerPreferencesWhereUniqueInput
    create: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
  }

  export type EventFeedbackCreateWithoutGuestInput = {
    id?: string
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutFeedbacksInput
    ticket?: TicketCreateNestedOneWithoutFeedbacksInput
  }

  export type EventFeedbackUncheckedCreateWithoutGuestInput = {
    id?: string
    eventId: string
    ticketId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackCreateOrConnectWithoutGuestInput = {
    where: EventFeedbackWhereUniqueInput
    create: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput>
  }

  export type EventFeedbackCreateManyGuestInputEnvelope = {
    data: EventFeedbackCreateManyGuestInput | EventFeedbackCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type ListEntryCreateWithoutGuestInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutListEntriesInput
    list: ListCreateNestedOneWithoutEntriesInput
    tickets?: TicketCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryUncheckedCreateWithoutGuestInput = {
    id?: string
    listId: string
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutListEntryInput
  }

  export type ListEntryCreateOrConnectWithoutGuestInput = {
    where: ListEntryWhereUniqueInput
    create: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput>
  }

  export type ListEntryCreateManyGuestInputEnvelope = {
    data: ListEntryCreateManyGuestInput | ListEntryCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type SecurityNoteCreateWithoutGuestInput = {
    id?: string
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
    event?: EventCreateNestedOneWithoutSecurityNotesInput
    reportedBy: UserCreateNestedOneWithoutSecurityReportsInput
    ticket?: TicketCreateNestedOneWithoutSecurityNotesInput
  }

  export type SecurityNoteUncheckedCreateWithoutGuestInput = {
    id?: string
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteCreateOrConnectWithoutGuestInput = {
    where: SecurityNoteWhereUniqueInput
    create: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput>
  }

  export type SecurityNoteCreateManyGuestInputEnvelope = {
    data: SecurityNoteCreateManyGuestInput | SecurityNoteCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutGuestInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutGuestInput = {
    id?: string
    eventId: string
    userId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutGuestInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput>
  }

  export type TicketCreateManyGuestInputEnvelope = {
    data: TicketCreateManyGuestInput | TicketCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPreferencesUpsertWithoutGuestInput = {
    update: XOR<CustomerPreferencesUpdateWithoutGuestInput, CustomerPreferencesUncheckedUpdateWithoutGuestInput>
    create: XOR<CustomerPreferencesCreateWithoutGuestInput, CustomerPreferencesUncheckedCreateWithoutGuestInput>
    where?: CustomerPreferencesWhereInput
  }

  export type CustomerPreferencesUpdateToOneWithWhereWithoutGuestInput = {
    where?: CustomerPreferencesWhereInput
    data: XOR<CustomerPreferencesUpdateWithoutGuestInput, CustomerPreferencesUncheckedUpdateWithoutGuestInput>
  }

  export type CustomerPreferencesUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPreferencesUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    musicGenres?: NullableJsonNullValueInput | InputJsonValue
    dressStyle?: NullableStringFieldUpdateOperationsInput | string | null
    drinkPreferences?: NullableJsonNullValueInput | InputJsonValue
    avgSpending?: NullableFloatFieldUpdateOperationsInput | number | null
    responseToPromo?: NullableStringFieldUpdateOperationsInput | string | null
    socialEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    conversionScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lifetimeValue?: NullableFloatFieldUpdateOperationsInput | number | null
    consents?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUpsertWithWhereUniqueWithoutGuestInput = {
    where: EventFeedbackWhereUniqueInput
    update: XOR<EventFeedbackUpdateWithoutGuestInput, EventFeedbackUncheckedUpdateWithoutGuestInput>
    create: XOR<EventFeedbackCreateWithoutGuestInput, EventFeedbackUncheckedCreateWithoutGuestInput>
  }

  export type EventFeedbackUpdateWithWhereUniqueWithoutGuestInput = {
    where: EventFeedbackWhereUniqueInput
    data: XOR<EventFeedbackUpdateWithoutGuestInput, EventFeedbackUncheckedUpdateWithoutGuestInput>
  }

  export type EventFeedbackUpdateManyWithWhereWithoutGuestInput = {
    where: EventFeedbackScalarWhereInput
    data: XOR<EventFeedbackUpdateManyMutationInput, EventFeedbackUncheckedUpdateManyWithoutGuestInput>
  }

  export type ListEntryUpsertWithWhereUniqueWithoutGuestInput = {
    where: ListEntryWhereUniqueInput
    update: XOR<ListEntryUpdateWithoutGuestInput, ListEntryUncheckedUpdateWithoutGuestInput>
    create: XOR<ListEntryCreateWithoutGuestInput, ListEntryUncheckedCreateWithoutGuestInput>
  }

  export type ListEntryUpdateWithWhereUniqueWithoutGuestInput = {
    where: ListEntryWhereUniqueInput
    data: XOR<ListEntryUpdateWithoutGuestInput, ListEntryUncheckedUpdateWithoutGuestInput>
  }

  export type ListEntryUpdateManyWithWhereWithoutGuestInput = {
    where: ListEntryScalarWhereInput
    data: XOR<ListEntryUpdateManyMutationInput, ListEntryUncheckedUpdateManyWithoutGuestInput>
  }

  export type SecurityNoteUpsertWithWhereUniqueWithoutGuestInput = {
    where: SecurityNoteWhereUniqueInput
    update: XOR<SecurityNoteUpdateWithoutGuestInput, SecurityNoteUncheckedUpdateWithoutGuestInput>
    create: XOR<SecurityNoteCreateWithoutGuestInput, SecurityNoteUncheckedCreateWithoutGuestInput>
  }

  export type SecurityNoteUpdateWithWhereUniqueWithoutGuestInput = {
    where: SecurityNoteWhereUniqueInput
    data: XOR<SecurityNoteUpdateWithoutGuestInput, SecurityNoteUncheckedUpdateWithoutGuestInput>
  }

  export type SecurityNoteUpdateManyWithWhereWithoutGuestInput = {
    where: SecurityNoteScalarWhereInput
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyWithoutGuestInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutGuestInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutGuestInput, TicketUncheckedUpdateWithoutGuestInput>
    create: XOR<TicketCreateWithoutGuestInput, TicketUncheckedCreateWithoutGuestInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutGuestInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutGuestInput, TicketUncheckedUpdateWithoutGuestInput>
  }

  export type TicketUpdateManyWithWhereWithoutGuestInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutGuestInput>
  }

  export type UserCreateWithoutListEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListEntriesInput, UserUncheckedCreateWithoutListEntriesInput>
  }

  export type GuestCreateWithoutListEntriesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutGuestInput
    tickets?: TicketCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutListEntriesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutGuestInput
    tickets?: TicketUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutListEntriesInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutListEntriesInput, GuestUncheckedCreateWithoutListEntriesInput>
  }

  export type ListCreateWithoutEntriesInput = {
    id?: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutListsInput
  }

  export type ListUncheckedCreateWithoutEntriesInput = {
    id?: string
    eventId: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListCreateOrConnectWithoutEntriesInput = {
    where: ListWhereUniqueInput
    create: XOR<ListCreateWithoutEntriesInput, ListUncheckedCreateWithoutEntriesInput>
  }

  export type TicketCreateWithoutListEntryInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutListEntryInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutListEntryInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput>
  }

  export type TicketCreateManyListEntryInputEnvelope = {
    data: TicketCreateManyListEntryInput | TicketCreateManyListEntryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutListEntriesInput = {
    update: XOR<UserUpdateWithoutListEntriesInput, UserUncheckedUpdateWithoutListEntriesInput>
    create: XOR<UserCreateWithoutListEntriesInput, UserUncheckedCreateWithoutListEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListEntriesInput, UserUncheckedUpdateWithoutListEntriesInput>
  }

  export type UserUpdateWithoutListEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GuestUpsertWithoutListEntriesInput = {
    update: XOR<GuestUpdateWithoutListEntriesInput, GuestUncheckedUpdateWithoutListEntriesInput>
    create: XOR<GuestCreateWithoutListEntriesInput, GuestUncheckedCreateWithoutListEntriesInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutListEntriesInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutListEntriesInput, GuestUncheckedUpdateWithoutListEntriesInput>
  }

  export type GuestUpdateWithoutListEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutGuestNestedInput
    tickets?: TicketUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutListEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type ListUpsertWithoutEntriesInput = {
    update: XOR<ListUpdateWithoutEntriesInput, ListUncheckedUpdateWithoutEntriesInput>
    create: XOR<ListCreateWithoutEntriesInput, ListUncheckedCreateWithoutEntriesInput>
    where?: ListWhereInput
  }

  export type ListUpdateToOneWithWhereWithoutEntriesInput = {
    where?: ListWhereInput
    data: XOR<ListUpdateWithoutEntriesInput, ListUncheckedUpdateWithoutEntriesInput>
  }

  export type ListUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutListsNestedInput
  }

  export type ListUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutListEntryInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutListEntryInput, TicketUncheckedUpdateWithoutListEntryInput>
    create: XOR<TicketCreateWithoutListEntryInput, TicketUncheckedCreateWithoutListEntryInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutListEntryInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutListEntryInput, TicketUncheckedUpdateWithoutListEntryInput>
  }

  export type TicketUpdateManyWithWhereWithoutListEntryInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutListEntryInput>
  }

  export type CheckInCreateWithoutTicketInput = {
    id?: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
    scannedBy: UserCreateNestedOneWithoutCheckinsInput
  }

  export type CheckInUncheckedCreateWithoutTicketInput = {
    id?: string
    scannedByUserId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type CheckInCreateOrConnectWithoutTicketInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput>
  }

  export type CheckInCreateManyTicketInputEnvelope = {
    data: CheckInCreateManyTicketInput | CheckInCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type ConsumptionCreateWithoutTicketInput = {
    id?: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutConsumptionsInput
  }

  export type ConsumptionUncheckedCreateWithoutTicketInput = {
    id?: string
    eventId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsumptionCreateOrConnectWithoutTicketInput = {
    where: ConsumptionWhereUniqueInput
    create: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput>
  }

  export type ConsumptionCreateManyTicketInputEnvelope = {
    data: ConsumptionCreateManyTicketInput | ConsumptionCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type EventFeedbackCreateWithoutTicketInput = {
    id?: string
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutFeedbacksInput
    guest?: GuestCreateNestedOneWithoutFeedbacksInput
  }

  export type EventFeedbackUncheckedCreateWithoutTicketInput = {
    id?: string
    eventId: string
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackCreateOrConnectWithoutTicketInput = {
    where: EventFeedbackWhereUniqueInput
    create: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput>
  }

  export type EventFeedbackCreateManyTicketInputEnvelope = {
    data: EventFeedbackCreateManyTicketInput | EventFeedbackCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type SecurityNoteCreateWithoutTicketInput = {
    id?: string
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
    event?: EventCreateNestedOneWithoutSecurityNotesInput
    guest?: GuestCreateNestedOneWithoutSecurityNotesInput
    reportedBy: UserCreateNestedOneWithoutSecurityReportsInput
  }

  export type SecurityNoteUncheckedCreateWithoutTicketInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityNoteCreateOrConnectWithoutTicketInput = {
    where: SecurityNoteWhereUniqueInput
    create: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput>
  }

  export type SecurityNoteCreateManyTicketInputEnvelope = {
    data: SecurityNoteCreateManyTicketInput | SecurityNoteCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutTicketsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTicketsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTicketsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
  }

  export type GuestCreateWithoutTicketsInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutTicketsInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutTicketsInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutTicketsInput, GuestUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsIssuedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsIssuedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsIssuedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsIssuedInput, UserUncheckedCreateWithoutTicketsIssuedInput>
  }

  export type ListEntryCreateWithoutTicketsInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutListEntriesInput
    guest?: GuestCreateNestedOneWithoutListEntriesInput
    list: ListCreateNestedOneWithoutEntriesInput
  }

  export type ListEntryUncheckedCreateWithoutTicketsInput = {
    id?: string
    listId: string
    guestId?: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListEntryCreateOrConnectWithoutTicketsInput = {
    where: ListEntryWhereUniqueInput
    create: XOR<ListEntryCreateWithoutTicketsInput, ListEntryUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsOwnedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsOwnedInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsOwnedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsOwnedInput, UserUncheckedCreateWithoutTicketsOwnedInput>
  }

  export type CheckInUpsertWithWhereUniqueWithoutTicketInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutTicketInput, CheckInUncheckedUpdateWithoutTicketInput>
    create: XOR<CheckInCreateWithoutTicketInput, CheckInUncheckedCreateWithoutTicketInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutTicketInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutTicketInput, CheckInUncheckedUpdateWithoutTicketInput>
  }

  export type CheckInUpdateManyWithWhereWithoutTicketInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutTicketInput>
  }

  export type ConsumptionUpsertWithWhereUniqueWithoutTicketInput = {
    where: ConsumptionWhereUniqueInput
    update: XOR<ConsumptionUpdateWithoutTicketInput, ConsumptionUncheckedUpdateWithoutTicketInput>
    create: XOR<ConsumptionCreateWithoutTicketInput, ConsumptionUncheckedCreateWithoutTicketInput>
  }

  export type ConsumptionUpdateWithWhereUniqueWithoutTicketInput = {
    where: ConsumptionWhereUniqueInput
    data: XOR<ConsumptionUpdateWithoutTicketInput, ConsumptionUncheckedUpdateWithoutTicketInput>
  }

  export type ConsumptionUpdateManyWithWhereWithoutTicketInput = {
    where: ConsumptionScalarWhereInput
    data: XOR<ConsumptionUpdateManyMutationInput, ConsumptionUncheckedUpdateManyWithoutTicketInput>
  }

  export type EventFeedbackUpsertWithWhereUniqueWithoutTicketInput = {
    where: EventFeedbackWhereUniqueInput
    update: XOR<EventFeedbackUpdateWithoutTicketInput, EventFeedbackUncheckedUpdateWithoutTicketInput>
    create: XOR<EventFeedbackCreateWithoutTicketInput, EventFeedbackUncheckedCreateWithoutTicketInput>
  }

  export type EventFeedbackUpdateWithWhereUniqueWithoutTicketInput = {
    where: EventFeedbackWhereUniqueInput
    data: XOR<EventFeedbackUpdateWithoutTicketInput, EventFeedbackUncheckedUpdateWithoutTicketInput>
  }

  export type EventFeedbackUpdateManyWithWhereWithoutTicketInput = {
    where: EventFeedbackScalarWhereInput
    data: XOR<EventFeedbackUpdateManyMutationInput, EventFeedbackUncheckedUpdateManyWithoutTicketInput>
  }

  export type SecurityNoteUpsertWithWhereUniqueWithoutTicketInput = {
    where: SecurityNoteWhereUniqueInput
    update: XOR<SecurityNoteUpdateWithoutTicketInput, SecurityNoteUncheckedUpdateWithoutTicketInput>
    create: XOR<SecurityNoteCreateWithoutTicketInput, SecurityNoteUncheckedCreateWithoutTicketInput>
  }

  export type SecurityNoteUpdateWithWhereUniqueWithoutTicketInput = {
    where: SecurityNoteWhereUniqueInput
    data: XOR<SecurityNoteUpdateWithoutTicketInput, SecurityNoteUncheckedUpdateWithoutTicketInput>
  }

  export type SecurityNoteUpdateManyWithWhereWithoutTicketInput = {
    where: SecurityNoteScalarWhereInput
    data: XOR<SecurityNoteUpdateManyMutationInput, SecurityNoteUncheckedUpdateManyWithoutTicketInput>
  }

  export type EventUpsertWithoutTicketsInput = {
    update: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type EventUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type GuestUpsertWithoutTicketsInput = {
    update: XOR<GuestUpdateWithoutTicketsInput, GuestUncheckedUpdateWithoutTicketsInput>
    create: XOR<GuestCreateWithoutTicketsInput, GuestUncheckedCreateWithoutTicketsInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutTicketsInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutTicketsInput, GuestUncheckedUpdateWithoutTicketsInput>
  }

  export type GuestUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type UserUpsertWithoutTicketsIssuedInput = {
    update: XOR<UserUpdateWithoutTicketsIssuedInput, UserUncheckedUpdateWithoutTicketsIssuedInput>
    create: XOR<UserCreateWithoutTicketsIssuedInput, UserUncheckedCreateWithoutTicketsIssuedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsIssuedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsIssuedInput, UserUncheckedUpdateWithoutTicketsIssuedInput>
  }

  export type UserUpdateWithoutTicketsIssuedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsIssuedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ListEntryUpsertWithoutTicketsInput = {
    update: XOR<ListEntryUpdateWithoutTicketsInput, ListEntryUncheckedUpdateWithoutTicketsInput>
    create: XOR<ListEntryCreateWithoutTicketsInput, ListEntryUncheckedCreateWithoutTicketsInput>
    where?: ListEntryWhereInput
  }

  export type ListEntryUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ListEntryWhereInput
    data: XOR<ListEntryUpdateWithoutTicketsInput, ListEntryUncheckedUpdateWithoutTicketsInput>
  }

  export type ListEntryUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutListEntriesNestedInput
    guest?: GuestUpdateOneWithoutListEntriesNestedInput
    list?: ListUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type ListEntryUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTicketsOwnedInput = {
    update: XOR<UserUpdateWithoutTicketsOwnedInput, UserUncheckedUpdateWithoutTicketsOwnedInput>
    create: XOR<UserCreateWithoutTicketsOwnedInput, UserUncheckedCreateWithoutTicketsOwnedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsOwnedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsOwnedInput, UserUncheckedUpdateWithoutTicketsOwnedInput>
  }

  export type UserUpdateWithoutTicketsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutCheckinsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCheckinsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCheckinsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckinsInput, UserUncheckedCreateWithoutCheckinsInput>
  }

  export type TicketCreateWithoutCheckinsInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutCheckinsInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCheckinsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCheckinsInput, TicketUncheckedCreateWithoutCheckinsInput>
  }

  export type UserUpsertWithoutCheckinsInput = {
    update: XOR<UserUpdateWithoutCheckinsInput, UserUncheckedUpdateWithoutCheckinsInput>
    create: XOR<UserCreateWithoutCheckinsInput, UserUncheckedCreateWithoutCheckinsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckinsInput, UserUncheckedUpdateWithoutCheckinsInput>
  }

  export type UserUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketUpsertWithoutCheckinsInput = {
    update: XOR<TicketUpdateWithoutCheckinsInput, TicketUncheckedUpdateWithoutCheckinsInput>
    create: XOR<TicketCreateWithoutCheckinsInput, TicketUncheckedCreateWithoutCheckinsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCheckinsInput, TicketUncheckedUpdateWithoutCheckinsInput>
  }

  export type TicketUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutCheckinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserCreateWithoutInviteLinksInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInviteLinksInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInviteLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInviteLinksInput, UserUncheckedCreateWithoutInviteLinksInput>
  }

  export type EventCreateWithoutInviteLinksInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutInviteLinksInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutInviteLinksInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutInviteLinksInput, EventUncheckedCreateWithoutInviteLinksInput>
  }

  export type PRProfileCreateWithoutInviteLinksInput = {
    id?: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutPrProfileInput
    user: UserCreateNestedOneWithoutPrProfileInput
  }

  export type PRProfileUncheckedCreateWithoutInviteLinksInput = {
    id?: string
    userId: string
    displayName?: string | null
    referralCode: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutPrProfileInput
  }

  export type PRProfileCreateOrConnectWithoutInviteLinksInput = {
    where: PRProfileWhereUniqueInput
    create: XOR<PRProfileCreateWithoutInviteLinksInput, PRProfileUncheckedCreateWithoutInviteLinksInput>
  }

  export type UserUpsertWithoutInviteLinksInput = {
    update: XOR<UserUpdateWithoutInviteLinksInput, UserUncheckedUpdateWithoutInviteLinksInput>
    create: XOR<UserCreateWithoutInviteLinksInput, UserUncheckedCreateWithoutInviteLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInviteLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInviteLinksInput, UserUncheckedUpdateWithoutInviteLinksInput>
  }

  export type UserUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EventUpsertWithoutInviteLinksInput = {
    update: XOR<EventUpdateWithoutInviteLinksInput, EventUncheckedUpdateWithoutInviteLinksInput>
    create: XOR<EventCreateWithoutInviteLinksInput, EventUncheckedCreateWithoutInviteLinksInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutInviteLinksInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutInviteLinksInput, EventUncheckedUpdateWithoutInviteLinksInput>
  }

  export type EventUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type PRProfileUpsertWithoutInviteLinksInput = {
    update: XOR<PRProfileUpdateWithoutInviteLinksInput, PRProfileUncheckedUpdateWithoutInviteLinksInput>
    create: XOR<PRProfileCreateWithoutInviteLinksInput, PRProfileUncheckedCreateWithoutInviteLinksInput>
    where?: PRProfileWhereInput
  }

  export type PRProfileUpdateToOneWithWhereWithoutInviteLinksInput = {
    where?: PRProfileWhereInput
    data: XOR<PRProfileUpdateWithoutInviteLinksInput, PRProfileUncheckedUpdateWithoutInviteLinksInput>
  }

  export type PRProfileUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutPrProfileNestedInput
    user?: UserUpdateOneRequiredWithoutPrProfileNestedInput
  }

  export type PRProfileUncheckedUpdateWithoutInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutPrProfileNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EventCreateWithoutConsumptionsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutConsumptionsInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutConsumptionsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutConsumptionsInput, EventUncheckedCreateWithoutConsumptionsInput>
  }

  export type TicketCreateWithoutConsumptionsInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutConsumptionsInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutConsumptionsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutConsumptionsInput, TicketUncheckedCreateWithoutConsumptionsInput>
  }

  export type EventUpsertWithoutConsumptionsInput = {
    update: XOR<EventUpdateWithoutConsumptionsInput, EventUncheckedUpdateWithoutConsumptionsInput>
    create: XOR<EventCreateWithoutConsumptionsInput, EventUncheckedCreateWithoutConsumptionsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutConsumptionsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutConsumptionsInput, EventUncheckedUpdateWithoutConsumptionsInput>
  }

  export type EventUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type TicketUpsertWithoutConsumptionsInput = {
    update: XOR<TicketUpdateWithoutConsumptionsInput, TicketUncheckedUpdateWithoutConsumptionsInput>
    create: XOR<TicketCreateWithoutConsumptionsInput, TicketUncheckedCreateWithoutConsumptionsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutConsumptionsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutConsumptionsInput, TicketUncheckedUpdateWithoutConsumptionsInput>
  }

  export type TicketUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutConsumptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type EventCreateWithoutFunnelTrackingInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutFunnelTrackingInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutFunnelTrackingInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutFunnelTrackingInput, EventUncheckedCreateWithoutFunnelTrackingInput>
  }

  export type EventUpsertWithoutFunnelTrackingInput = {
    update: XOR<EventUpdateWithoutFunnelTrackingInput, EventUncheckedUpdateWithoutFunnelTrackingInput>
    create: XOR<EventCreateWithoutFunnelTrackingInput, EventUncheckedCreateWithoutFunnelTrackingInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutFunnelTrackingInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutFunnelTrackingInput, EventUncheckedUpdateWithoutFunnelTrackingInput>
  }

  export type EventUpdateWithoutFunnelTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutFunnelTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutFeedbacksInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutFeedbacksInput, EventUncheckedCreateWithoutFeedbacksInput>
  }

  export type GuestCreateWithoutFeedbacksInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesCreateNestedOneWithoutGuestInput
    listEntries?: ListEntryCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutGuestInput
    tickets?: TicketCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutGuestInput
    tickets?: TicketUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutFeedbacksInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutFeedbacksInput, GuestUncheckedCreateWithoutFeedbacksInput>
  }

  export type TicketCreateWithoutFeedbacksInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutFeedbacksInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutFeedbacksInput, TicketUncheckedCreateWithoutFeedbacksInput>
  }

  export type EventUpsertWithoutFeedbacksInput = {
    update: XOR<EventUpdateWithoutFeedbacksInput, EventUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<EventCreateWithoutFeedbacksInput, EventUncheckedCreateWithoutFeedbacksInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutFeedbacksInput, EventUncheckedUpdateWithoutFeedbacksInput>
  }

  export type EventUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type GuestUpsertWithoutFeedbacksInput = {
    update: XOR<GuestUpdateWithoutFeedbacksInput, GuestUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<GuestCreateWithoutFeedbacksInput, GuestUncheckedCreateWithoutFeedbacksInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutFeedbacksInput, GuestUncheckedUpdateWithoutFeedbacksInput>
  }

  export type GuestUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUpdateOneWithoutGuestNestedInput
    listEntries?: ListEntryUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutGuestNestedInput
    tickets?: TicketUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type TicketUpsertWithoutFeedbacksInput = {
    update: XOR<TicketUpdateWithoutFeedbacksInput, TicketUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<TicketCreateWithoutFeedbacksInput, TicketUncheckedCreateWithoutFeedbacksInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutFeedbacksInput, TicketUncheckedUpdateWithoutFeedbacksInput>
  }

  export type TicketUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type EventCreateWithoutSecurityNotesInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    venue: VenueCreateNestedOneWithoutEventsInput
    funnelTracking?: FunnelTrackingCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutEventInput
    lists?: ListCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSecurityNotesInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEventInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutEventInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutEventInput
    funnelTracking?: FunnelTrackingUncheckedCreateNestedManyWithoutEventInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutEventInput
    lists?: ListUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSecurityNotesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSecurityNotesInput, EventUncheckedCreateWithoutSecurityNotesInput>
  }

  export type GuestCreateWithoutSecurityNotesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryCreateNestedManyWithoutGuestInput
    tickets?: TicketCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutSecurityNotesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preferences?: CustomerPreferencesUncheckedCreateNestedOneWithoutGuestInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutGuestInput
    tickets?: TicketUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutSecurityNotesInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutSecurityNotesInput, GuestUncheckedCreateWithoutSecurityNotesInput>
  }

  export type UserCreateWithoutSecurityReportsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSecurityReportsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSecurityReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSecurityReportsInput, UserUncheckedCreateWithoutSecurityReportsInput>
  }

  export type TicketCreateWithoutSecurityNotesInput = {
    id?: string
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackCreateNestedManyWithoutTicketInput
    event: EventCreateNestedOneWithoutTicketsInput
    guest?: GuestCreateNestedOneWithoutTicketsInput
    issuedBy?: UserCreateNestedOneWithoutTicketsIssuedInput
    listEntry?: ListEntryCreateNestedOneWithoutTicketsInput
    user?: UserCreateNestedOneWithoutTicketsOwnedInput
  }

  export type TicketUncheckedCreateWithoutSecurityNotesInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
    checkins?: CheckInUncheckedCreateNestedManyWithoutTicketInput
    consumptions?: ConsumptionUncheckedCreateNestedManyWithoutTicketInput
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutSecurityNotesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSecurityNotesInput, TicketUncheckedCreateWithoutSecurityNotesInput>
  }

  export type EventUpsertWithoutSecurityNotesInput = {
    update: XOR<EventUpdateWithoutSecurityNotesInput, EventUncheckedUpdateWithoutSecurityNotesInput>
    create: XOR<EventCreateWithoutSecurityNotesInput, EventUncheckedCreateWithoutSecurityNotesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutSecurityNotesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutSecurityNotesInput, EventUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type EventUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type GuestUpsertWithoutSecurityNotesInput = {
    update: XOR<GuestUpdateWithoutSecurityNotesInput, GuestUncheckedUpdateWithoutSecurityNotesInput>
    create: XOR<GuestCreateWithoutSecurityNotesInput, GuestUncheckedCreateWithoutSecurityNotesInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutSecurityNotesInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutSecurityNotesInput, GuestUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type GuestUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUpdateManyWithoutGuestNestedInput
    tickets?: TicketUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: CustomerPreferencesUncheckedUpdateOneWithoutGuestNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutGuestNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type UserUpsertWithoutSecurityReportsInput = {
    update: XOR<UserUpdateWithoutSecurityReportsInput, UserUncheckedUpdateWithoutSecurityReportsInput>
    create: XOR<UserCreateWithoutSecurityReportsInput, UserUncheckedCreateWithoutSecurityReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSecurityReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSecurityReportsInput, UserUncheckedUpdateWithoutSecurityReportsInput>
  }

  export type UserUpdateWithoutSecurityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSecurityReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketUpsertWithoutSecurityNotesInput = {
    update: XOR<TicketUpdateWithoutSecurityNotesInput, TicketUncheckedUpdateWithoutSecurityNotesInput>
    create: XOR<TicketCreateWithoutSecurityNotesInput, TicketUncheckedCreateWithoutSecurityNotesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutSecurityNotesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutSecurityNotesInput, TicketUncheckedUpdateWithoutSecurityNotesInput>
  }

  export type TicketUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutSecurityNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type GuestCreateWithoutPreferencesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbacks?: EventFeedbackCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteCreateNestedManyWithoutGuestInput
    tickets?: TicketCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutPreferencesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    nickname?: string | null
    birthDate?: Date | string | null
    city?: string | null
    occupation?: string | null
    instagram?: string | null
    telegramChatId?: string | null
    whatsappPhone?: string | null
    totalEvents?: number
    lastEventDate?: Date | string | null
    customerSegment?: $Enums.CustomerSegment
    preferredDays?: string | null
    averageArrivalTime?: string | null
    prefersTable?: boolean
    averageGroupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbacks?: EventFeedbackUncheckedCreateNestedManyWithoutGuestInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutGuestInput
    securityNotes?: SecurityNoteUncheckedCreateNestedManyWithoutGuestInput
    tickets?: TicketUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutPreferencesInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutPreferencesInput, GuestUncheckedCreateWithoutPreferencesInput>
  }

  export type GuestUpsertWithoutPreferencesInput = {
    update: XOR<GuestUpdateWithoutPreferencesInput, GuestUncheckedUpdateWithoutPreferencesInput>
    create: XOR<GuestCreateWithoutPreferencesInput, GuestUncheckedCreateWithoutPreferencesInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutPreferencesInput, GuestUncheckedUpdateWithoutPreferencesInput>
  }

  export type GuestUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbacks?: EventFeedbackUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutGuestNestedInput
    tickets?: TicketUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegramChatId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    totalEvents?: IntFieldUpdateOperationsInput | number
    lastEventDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerSegment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    preferredDays?: NullableStringFieldUpdateOperationsInput | string | null
    averageArrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    prefersTable?: BoolFieldUpdateOperationsInput | boolean
    averageGroupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutGuestNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutGuestNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutGuestNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type UserCreateWithoutOrganizationProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationProfileInput, UserUncheckedCreateWithoutOrganizationProfileInput>
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrganizationProfileInput = {
    update: XOR<UserUpdateWithoutOrganizationProfileInput, UserUncheckedUpdateWithoutOrganizationProfileInput>
    create: XOR<UserCreateWithoutOrganizationProfileInput, UserUncheckedCreateWithoutOrganizationProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationProfileInput, UserUncheckedUpdateWithoutOrganizationProfileInput>
  }

  export type UserUpdateWithoutOrganizationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    name?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    email?: StringNullableFilter<"OrganizationMember"> | string | null
    phone?: StringNullableFilter<"OrganizationMember"> | string | null
    avatar?: StringNullableFilter<"OrganizationMember"> | string | null
    createdAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
  }

  export type OrganizationProfileCreateWithoutTeamMembersInput = {
    id?: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationProfileInput
  }

  export type OrganizationProfileUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    userId: string
    slug?: string | null
    organizationName: string
    bio?: string | null
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    logo?: string | null
    coverImage?: string | null
    verified?: boolean
    totalEvents?: number
    totalAttendees?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationProfileCreateOrConnectWithoutTeamMembersInput = {
    where: OrganizationProfileWhereUniqueInput
    create: XOR<OrganizationProfileCreateWithoutTeamMembersInput, OrganizationProfileUncheckedCreateWithoutTeamMembersInput>
  }

  export type OrganizationProfileUpsertWithoutTeamMembersInput = {
    update: XOR<OrganizationProfileUpdateWithoutTeamMembersInput, OrganizationProfileUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<OrganizationProfileCreateWithoutTeamMembersInput, OrganizationProfileUncheckedCreateWithoutTeamMembersInput>
    where?: OrganizationProfileWhereInput
  }

  export type OrganizationProfileUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: OrganizationProfileWhereInput
    data: XOR<OrganizationProfileUpdateWithoutTeamMembersInput, OrganizationProfileUncheckedUpdateWithoutTeamMembersInput>
  }

  export type OrganizationProfileUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationProfileNestedInput
  }

  export type OrganizationProfileUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    organizationName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalEvents?: IntFieldUpdateOperationsInput | number
    totalAttendees?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutArtistProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArtistProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArtistProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArtistProfileInput, UserUncheckedCreateWithoutArtistProfileInput>
  }

  export type PerformanceCreateWithoutArtistInput = {
    id?: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceUncheckedCreateWithoutArtistInput = {
    id?: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceCreateOrConnectWithoutArtistInput = {
    where: PerformanceWhereUniqueInput
    create: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput>
  }

  export type PerformanceCreateManyArtistInputEnvelope = {
    data: PerformanceCreateManyArtistInput | PerformanceCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type ArtistMediaCreateWithoutArtistInput = {
    id?: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistMediaUncheckedCreateWithoutArtistInput = {
    id?: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistMediaCreateOrConnectWithoutArtistInput = {
    where: ArtistMediaWhereUniqueInput
    create: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput>
  }

  export type ArtistMediaCreateManyArtistInputEnvelope = {
    data: ArtistMediaCreateManyArtistInput | ArtistMediaCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArtistProfileInput = {
    update: XOR<UserUpdateWithoutArtistProfileInput, UserUncheckedUpdateWithoutArtistProfileInput>
    create: XOR<UserCreateWithoutArtistProfileInput, UserUncheckedCreateWithoutArtistProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArtistProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArtistProfileInput, UserUncheckedUpdateWithoutArtistProfileInput>
  }

  export type UserUpdateWithoutArtistProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArtistProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PerformanceUpsertWithWhereUniqueWithoutArtistInput = {
    where: PerformanceWhereUniqueInput
    update: XOR<PerformanceUpdateWithoutArtistInput, PerformanceUncheckedUpdateWithoutArtistInput>
    create: XOR<PerformanceCreateWithoutArtistInput, PerformanceUncheckedCreateWithoutArtistInput>
  }

  export type PerformanceUpdateWithWhereUniqueWithoutArtistInput = {
    where: PerformanceWhereUniqueInput
    data: XOR<PerformanceUpdateWithoutArtistInput, PerformanceUncheckedUpdateWithoutArtistInput>
  }

  export type PerformanceUpdateManyWithWhereWithoutArtistInput = {
    where: PerformanceScalarWhereInput
    data: XOR<PerformanceUpdateManyMutationInput, PerformanceUncheckedUpdateManyWithoutArtistInput>
  }

  export type PerformanceScalarWhereInput = {
    AND?: PerformanceScalarWhereInput | PerformanceScalarWhereInput[]
    OR?: PerformanceScalarWhereInput[]
    NOT?: PerformanceScalarWhereInput | PerformanceScalarWhereInput[]
    id?: StringFilter<"Performance"> | string
    artistId?: StringFilter<"Performance"> | string
    eventId?: StringNullableFilter<"Performance"> | string | null
    eventName?: StringFilter<"Performance"> | string
    eventDate?: DateTimeFilter<"Performance"> | Date | string
    venueName?: StringFilter<"Performance"> | string
    city?: StringNullableFilter<"Performance"> | string | null
    description?: StringNullableFilter<"Performance"> | string | null
    fee?: FloatNullableFilter<"Performance"> | number | null
    createdAt?: DateTimeFilter<"Performance"> | Date | string
    updatedAt?: DateTimeFilter<"Performance"> | Date | string
  }

  export type ArtistMediaUpsertWithWhereUniqueWithoutArtistInput = {
    where: ArtistMediaWhereUniqueInput
    update: XOR<ArtistMediaUpdateWithoutArtistInput, ArtistMediaUncheckedUpdateWithoutArtistInput>
    create: XOR<ArtistMediaCreateWithoutArtistInput, ArtistMediaUncheckedCreateWithoutArtistInput>
  }

  export type ArtistMediaUpdateWithWhereUniqueWithoutArtistInput = {
    where: ArtistMediaWhereUniqueInput
    data: XOR<ArtistMediaUpdateWithoutArtistInput, ArtistMediaUncheckedUpdateWithoutArtistInput>
  }

  export type ArtistMediaUpdateManyWithWhereWithoutArtistInput = {
    where: ArtistMediaScalarWhereInput
    data: XOR<ArtistMediaUpdateManyMutationInput, ArtistMediaUncheckedUpdateManyWithoutArtistInput>
  }

  export type ArtistMediaScalarWhereInput = {
    AND?: ArtistMediaScalarWhereInput | ArtistMediaScalarWhereInput[]
    OR?: ArtistMediaScalarWhereInput[]
    NOT?: ArtistMediaScalarWhereInput | ArtistMediaScalarWhereInput[]
    id?: StringFilter<"ArtistMedia"> | string
    artistId?: StringFilter<"ArtistMedia"> | string
    type?: EnumMediaTypeFilter<"ArtistMedia"> | $Enums.MediaType
    title?: StringNullableFilter<"ArtistMedia"> | string | null
    description?: StringNullableFilter<"ArtistMedia"> | string | null
    url?: StringFilter<"ArtistMedia"> | string
    thumbnailUrl?: StringNullableFilter<"ArtistMedia"> | string | null
    order?: IntFilter<"ArtistMedia"> | number
    createdAt?: DateTimeFilter<"ArtistMedia"> | Date | string
    updatedAt?: DateTimeFilter<"ArtistMedia"> | Date | string
  }

  export type ArtistProfileCreateWithoutPerformancesInput = {
    id?: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutArtistProfileInput
    mediaGallery?: ArtistMediaCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileUncheckedCreateWithoutPerformancesInput = {
    id?: string
    userId: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaGallery?: ArtistMediaUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileCreateOrConnectWithoutPerformancesInput = {
    where: ArtistProfileWhereUniqueInput
    create: XOR<ArtistProfileCreateWithoutPerformancesInput, ArtistProfileUncheckedCreateWithoutPerformancesInput>
  }

  export type ArtistProfileUpsertWithoutPerformancesInput = {
    update: XOR<ArtistProfileUpdateWithoutPerformancesInput, ArtistProfileUncheckedUpdateWithoutPerformancesInput>
    create: XOR<ArtistProfileCreateWithoutPerformancesInput, ArtistProfileUncheckedCreateWithoutPerformancesInput>
    where?: ArtistProfileWhereInput
  }

  export type ArtistProfileUpdateToOneWithWhereWithoutPerformancesInput = {
    where?: ArtistProfileWhereInput
    data: XOR<ArtistProfileUpdateWithoutPerformancesInput, ArtistProfileUncheckedUpdateWithoutPerformancesInput>
  }

  export type ArtistProfileUpdateWithoutPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutArtistProfileNestedInput
    mediaGallery?: ArtistMediaUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileUncheckedUpdateWithoutPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaGallery?: ArtistMediaUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileCreateWithoutMediaGalleryInput = {
    id?: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutArtistProfileInput
    performances?: PerformanceCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileUncheckedCreateWithoutMediaGalleryInput = {
    id?: string
    userId: string
    artistName: string
    artistType: $Enums.ArtistType
    bio?: string | null
    genres?: ArtistProfileCreategenresInput | string[]
    website?: string | null
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    soundcloud?: string | null
    spotify?: string | null
    youtube?: string | null
    avatar?: string | null
    coverImage?: string | null
    verified?: boolean
    totalGigs?: number
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    performances?: PerformanceUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistProfileCreateOrConnectWithoutMediaGalleryInput = {
    where: ArtistProfileWhereUniqueInput
    create: XOR<ArtistProfileCreateWithoutMediaGalleryInput, ArtistProfileUncheckedCreateWithoutMediaGalleryInput>
  }

  export type ArtistProfileUpsertWithoutMediaGalleryInput = {
    update: XOR<ArtistProfileUpdateWithoutMediaGalleryInput, ArtistProfileUncheckedUpdateWithoutMediaGalleryInput>
    create: XOR<ArtistProfileCreateWithoutMediaGalleryInput, ArtistProfileUncheckedCreateWithoutMediaGalleryInput>
    where?: ArtistProfileWhereInput
  }

  export type ArtistProfileUpdateToOneWithWhereWithoutMediaGalleryInput = {
    where?: ArtistProfileWhereInput
    data: XOR<ArtistProfileUpdateWithoutMediaGalleryInput, ArtistProfileUncheckedUpdateWithoutMediaGalleryInput>
  }

  export type ArtistProfileUpdateWithoutMediaGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutArtistProfileNestedInput
    performances?: PerformanceUpdateManyWithoutArtistNestedInput
  }

  export type ArtistProfileUncheckedUpdateWithoutMediaGalleryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistType?: EnumArtistTypeFieldUpdateOperationsInput | $Enums.ArtistType
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: ArtistProfileUpdategenresInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    soundcloud?: NullableStringFieldUpdateOperationsInput | string | null
    spotify?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    totalGigs?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    performances?: PerformanceUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type UserCreateWithoutUserProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowedByInput = {
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
  }

  export type FeedLikeCreateWithoutFeedItemInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFeedLikesInput
  }

  export type FeedLikeUncheckedCreateWithoutFeedItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FeedLikeCreateOrConnectWithoutFeedItemInput = {
    where: FeedLikeWhereUniqueInput
    create: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput>
  }

  export type FeedLikeCreateManyFeedItemInputEnvelope = {
    data: FeedLikeCreateManyFeedItemInput | FeedLikeCreateManyFeedItemInput[]
    skipDuplicates?: boolean
  }

  export type FeedCommentCreateWithoutFeedItemInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedCommentsInput
  }

  export type FeedCommentUncheckedCreateWithoutFeedItemInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedCommentCreateOrConnectWithoutFeedItemInput = {
    where: FeedCommentWhereUniqueInput
    create: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput>
  }

  export type FeedCommentCreateManyFeedItemInputEnvelope = {
    data: FeedCommentCreateManyFeedItemInput | FeedCommentCreateManyFeedItemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFeedItemsInput = {
    update: XOR<UserUpdateWithoutFeedItemsInput, UserUncheckedUpdateWithoutFeedItemsInput>
    create: XOR<UserCreateWithoutFeedItemsInput, UserUncheckedCreateWithoutFeedItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedItemsInput, UserUncheckedUpdateWithoutFeedItemsInput>
  }

  export type UserUpdateWithoutFeedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type FeedLikeUpsertWithWhereUniqueWithoutFeedItemInput = {
    where: FeedLikeWhereUniqueInput
    update: XOR<FeedLikeUpdateWithoutFeedItemInput, FeedLikeUncheckedUpdateWithoutFeedItemInput>
    create: XOR<FeedLikeCreateWithoutFeedItemInput, FeedLikeUncheckedCreateWithoutFeedItemInput>
  }

  export type FeedLikeUpdateWithWhereUniqueWithoutFeedItemInput = {
    where: FeedLikeWhereUniqueInput
    data: XOR<FeedLikeUpdateWithoutFeedItemInput, FeedLikeUncheckedUpdateWithoutFeedItemInput>
  }

  export type FeedLikeUpdateManyWithWhereWithoutFeedItemInput = {
    where: FeedLikeScalarWhereInput
    data: XOR<FeedLikeUpdateManyMutationInput, FeedLikeUncheckedUpdateManyWithoutFeedItemInput>
  }

  export type FeedCommentUpsertWithWhereUniqueWithoutFeedItemInput = {
    where: FeedCommentWhereUniqueInput
    update: XOR<FeedCommentUpdateWithoutFeedItemInput, FeedCommentUncheckedUpdateWithoutFeedItemInput>
    create: XOR<FeedCommentCreateWithoutFeedItemInput, FeedCommentUncheckedCreateWithoutFeedItemInput>
  }

  export type FeedCommentUpdateWithWhereUniqueWithoutFeedItemInput = {
    where: FeedCommentWhereUniqueInput
    data: XOR<FeedCommentUpdateWithoutFeedItemInput, FeedCommentUncheckedUpdateWithoutFeedItemInput>
  }

  export type FeedCommentUpdateManyWithWhereWithoutFeedItemInput = {
    where: FeedCommentScalarWhereInput
    data: XOR<FeedCommentUpdateManyMutationInput, FeedCommentUncheckedUpdateManyWithoutFeedItemInput>
  }

  export type FeedItemCreateWithoutLikesInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedItemsInput
    comments?: FeedCommentCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemUncheckedCreateWithoutLikesInput = {
    id?: string
    authorId: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: FeedCommentUncheckedCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemCreateOrConnectWithoutLikesInput = {
    where: FeedItemWhereUniqueInput
    create: XOR<FeedItemCreateWithoutLikesInput, FeedItemUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutFeedLikesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedLikesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedLikesInput, UserUncheckedCreateWithoutFeedLikesInput>
  }

  export type FeedItemUpsertWithoutLikesInput = {
    update: XOR<FeedItemUpdateWithoutLikesInput, FeedItemUncheckedUpdateWithoutLikesInput>
    create: XOR<FeedItemCreateWithoutLikesInput, FeedItemUncheckedCreateWithoutLikesInput>
    where?: FeedItemWhereInput
  }

  export type FeedItemUpdateToOneWithWhereWithoutLikesInput = {
    where?: FeedItemWhereInput
    data: XOR<FeedItemUpdateWithoutLikesInput, FeedItemUncheckedUpdateWithoutLikesInput>
  }

  export type FeedItemUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedItemsNestedInput
    comments?: FeedCommentUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: FeedCommentUncheckedUpdateManyWithoutFeedItemNestedInput
  }

  export type UserUpsertWithoutFeedLikesInput = {
    update: XOR<UserUpdateWithoutFeedLikesInput, UserUncheckedUpdateWithoutFeedLikesInput>
    create: XOR<UserCreateWithoutFeedLikesInput, UserUncheckedCreateWithoutFeedLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedLikesInput, UserUncheckedUpdateWithoutFeedLikesInput>
  }

  export type UserUpdateWithoutFeedLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type FeedItemCreateWithoutCommentsInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedItemsInput
    likes?: FeedLikeCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FeedLikeUncheckedCreateNestedManyWithoutFeedItemInput
  }

  export type FeedItemCreateOrConnectWithoutCommentsInput = {
    where: FeedItemWhereUniqueInput
    create: XOR<FeedItemCreateWithoutCommentsInput, FeedItemUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutFeedCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedCommentsInput, UserUncheckedCreateWithoutFeedCommentsInput>
  }

  export type FeedItemUpsertWithoutCommentsInput = {
    update: XOR<FeedItemUpdateWithoutCommentsInput, FeedItemUncheckedUpdateWithoutCommentsInput>
    create: XOR<FeedItemCreateWithoutCommentsInput, FeedItemUncheckedCreateWithoutCommentsInput>
    where?: FeedItemWhereInput
  }

  export type FeedItemUpdateToOneWithWhereWithoutCommentsInput = {
    where?: FeedItemWhereInput
    data: XOR<FeedItemUpdateWithoutCommentsInput, FeedItemUncheckedUpdateWithoutCommentsInput>
  }

  export type FeedItemUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedItemsNestedInput
    likes?: FeedLikeUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FeedLikeUncheckedUpdateManyWithoutFeedItemNestedInput
  }

  export type UserUpsertWithoutFeedCommentsInput = {
    update: XOR<UserUpdateWithoutFeedCommentsInput, UserUncheckedUpdateWithoutFeedCommentsInput>
    create: XOR<UserCreateWithoutFeedCommentsInput, UserUncheckedCreateWithoutFeedCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedCommentsInput, UserUncheckedUpdateWithoutFeedCommentsInput>
  }

  export type UserUpdateWithoutFeedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutIdentityVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdentityVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdentityVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdentityVerificationsInput, UserUncheckedCreateWithoutIdentityVerificationsInput>
  }

  export type UserCreateWithoutReviewedVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedVerificationsInput, UserUncheckedCreateWithoutReviewedVerificationsInput>
  }

  export type UserUpsertWithoutIdentityVerificationsInput = {
    update: XOR<UserUpdateWithoutIdentityVerificationsInput, UserUncheckedUpdateWithoutIdentityVerificationsInput>
    create: XOR<UserCreateWithoutIdentityVerificationsInput, UserUncheckedCreateWithoutIdentityVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIdentityVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIdentityVerificationsInput, UserUncheckedUpdateWithoutIdentityVerificationsInput>
  }

  export type UserUpdateWithoutIdentityVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIdentityVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewedVerificationsInput = {
    update: XOR<UserUpdateWithoutReviewedVerificationsInput, UserUncheckedUpdateWithoutReviewedVerificationsInput>
    create: XOR<UserCreateWithoutReviewedVerificationsInput, UserUncheckedCreateWithoutReviewedVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedVerificationsInput, UserUncheckedUpdateWithoutReviewedVerificationsInput>
  }

  export type UserUpdateWithoutReviewedVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPhoneVerificationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPhoneVerificationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPhoneVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhoneVerificationInput, UserUncheckedCreateWithoutPhoneVerificationInput>
  }

  export type UserUpsertWithoutPhoneVerificationInput = {
    update: XOR<UserUpdateWithoutPhoneVerificationInput, UserUncheckedUpdateWithoutPhoneVerificationInput>
    create: XOR<UserCreateWithoutPhoneVerificationInput, UserUncheckedCreateWithoutPhoneVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhoneVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhoneVerificationInput, UserUncheckedUpdateWithoutPhoneVerificationInput>
  }

  export type UserUpdateWithoutPhoneVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPhoneVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
  }

  export type UserUpsertWithoutConsentsInput = {
    update: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutOnboardingProgressInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    checkins?: CheckInCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketCreateNestedManyWithoutUserInput
    clubsOwned?: ClubCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileCreateNestedOneWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    feedItems?: FeedItemCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentCreateNestedManyWithoutUserInput
    followedBy?: UserFollowCreateNestedManyWithoutFollowingInput
    following?: UserFollowCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneCreateNestedOneWithoutUserInput
    consents?: UserConsentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOnboardingProgressInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    middleName?: string | null
    username?: string | null
    displayName?: string | null
    birthDate?: Date | string | null
    age?: number | null
    ageVerified?: boolean
    ageConsent?: boolean
    identityVerified?: boolean
    identityVerifiedAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    checkins?: CheckInUncheckedCreateNestedManyWithoutScannedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    inviteLinks?: InviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    listEntries?: ListEntryUncheckedCreateNestedManyWithoutAddedByInput
    prProfile?: PRProfileUncheckedCreateNestedOneWithoutUserInput
    securityReports?: SecurityNoteUncheckedCreateNestedManyWithoutReportedByInput
    ticketsIssued?: TicketUncheckedCreateNestedManyWithoutIssuedByInput
    ticketsOwned?: TicketUncheckedCreateNestedManyWithoutUserInput
    clubsOwned?: ClubUncheckedCreateNestedManyWithoutOwnerInput
    organizationProfile?: OrganizationProfileUncheckedCreateNestedOneWithoutUserInput
    artistProfile?: ArtistProfileUncheckedCreateNestedOneWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    feedItems?: FeedItemUncheckedCreateNestedManyWithoutAuthorInput
    feedLikes?: FeedLikeUncheckedCreateNestedManyWithoutUserInput
    feedComments?: FeedCommentUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    identityVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutUserInput
    reviewedVerifications?: IdentityVerificationUncheckedCreateNestedManyWithoutReviewerInput
    phoneVerification?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOnboardingProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
  }

  export type UserUpsertWithoutOnboardingProgressInput = {
    update: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type UserUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    checkins?: CheckInUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUpdateOneWithoutUserNestedInput
    consents?: UserConsentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    ageVerified?: BoolFieldUpdateOperationsInput | boolean
    ageConsent?: BoolFieldUpdateOperationsInput | boolean
    identityVerified?: BoolFieldUpdateOperationsInput | boolean
    identityVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    checkins?: CheckInUncheckedUpdateManyWithoutScannedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    listEntries?: ListEntryUncheckedUpdateManyWithoutAddedByNestedInput
    prProfile?: PRProfileUncheckedUpdateOneWithoutUserNestedInput
    securityReports?: SecurityNoteUncheckedUpdateManyWithoutReportedByNestedInput
    ticketsIssued?: TicketUncheckedUpdateManyWithoutIssuedByNestedInput
    ticketsOwned?: TicketUncheckedUpdateManyWithoutUserNestedInput
    clubsOwned?: ClubUncheckedUpdateManyWithoutOwnerNestedInput
    organizationProfile?: OrganizationProfileUncheckedUpdateOneWithoutUserNestedInput
    artistProfile?: ArtistProfileUncheckedUpdateOneWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    feedItems?: FeedItemUncheckedUpdateManyWithoutAuthorNestedInput
    feedLikes?: FeedLikeUncheckedUpdateManyWithoutUserNestedInput
    feedComments?: FeedCommentUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    identityVerifications?: IdentityVerificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedVerifications?: IdentityVerificationUncheckedUpdateManyWithoutReviewerNestedInput
    phoneVerification?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type CheckInCreateManyScannedByInput = {
    id?: string
    ticketId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type EventCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    venueId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkCreateManyCreatedByInput = {
    id?: string
    eventId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListEntryCreateManyAddedByInput = {
    id?: string
    listId: string
    guestId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityNoteCreateManyReportedByInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type TicketCreateManyIssuedByInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyUserInput = {
    id?: string
    eventId: string
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubCreateManyOwnerInput = {
    id?: string
    name: string
    type: $Enums.ClubType
    description?: string | null
    logo?: string | null
    coverImage?: string | null
    gallery?: ClubCreategalleryInput | string[]
    website?: string | null
    phone?: string | null
    email?: string | null
    instagram?: string | null
    facebook?: string | null
    openingHours?: string | null
    priceRange?: string | null
    amenities?: ClubCreateamenitiesInput | string[]
    musicGenres?: ClubCreatemusicGenresInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedItemCreateManyAuthorInput = {
    id?: string
    type: $Enums.FeedItemType
    content?: string | null
    imageUrl?: string | null
    videoUrl?: string | null
    eventId?: string | null
    visibility?: $Enums.Visibility
    likesCount?: number
    commentsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedLikeCreateManyUserInput = {
    id?: string
    feedItemId: string
    createdAt?: Date | string
  }

  export type FeedCommentCreateManyUserInput = {
    id?: string
    feedItemId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type IdentityVerificationCreateManyUserInput = {
    id?: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdentityVerificationCreateManyReviewerInput = {
    id?: string
    userId: string
    documentType: $Enums.DocumentType
    documentNumber?: string | null
    documentFrontUrl: string
    documentBackUrl?: string | null
    selfieUrl: string
    status?: $Enums.VerificationStatus
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUpdateWithoutScannedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    ticket?: TicketUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type CheckInUncheckedUpdateWithoutScannedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInUncheckedUpdateManyWithoutScannedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type EventUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateOneRequiredWithoutEventsNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutInviteLinksNestedInput
    prProfile?: PRProfileUpdateOneWithoutInviteLinksNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListEntryUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: GuestUpdateOneWithoutListEntriesNestedInput
    list?: ListUpdateOneRequiredWithoutEntriesNestedInput
    tickets?: TicketUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateManyWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneWithoutSecurityNotesNestedInput
    guest?: GuestUpdateOneWithoutSecurityNotesNestedInput
    ticket?: TicketUpdateOneWithoutSecurityNotesNestedInput
  }

  export type SecurityNoteUncheckedUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUncheckedUpdateManyWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutIssuedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venues?: VenueUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumClubTypeFieldUpdateOperationsInput | $Enums.ClubType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: ClubUpdategalleryInput | string[]
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: ClubUpdateamenitiesInput | string[]
    musicGenres?: ClubUpdatemusicGenresInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedItemUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FeedLikeUpdateManyWithoutFeedItemNestedInput
    comments?: FeedCommentUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FeedLikeUncheckedUpdateManyWithoutFeedItemNestedInput
    comments?: FeedCommentUncheckedUpdateManyWithoutFeedItemNestedInput
  }

  export type FeedItemUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedItemTypeFieldUpdateOperationsInput | $Enums.FeedItemType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    likesCount?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedItem?: FeedItemUpdateOneRequiredWithoutLikesNestedInput
  }

  export type FeedLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedItem?: FeedItemUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type FeedCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedItemId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneWithoutReviewedVerificationsNestedInput
  }

  export type IdentityVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdentityVerificationsNestedInput
  }

  export type IdentityVerificationUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityVerificationUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentFrontUrl?: StringFieldUpdateOperationsInput | string
    documentBackUrl?: NullableStringFieldUpdateOperationsInput | string | null
    selfieUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateManyClubInput = {
    id?: string
    name: string
    slug?: string | null
    address: string
    city: string
    capacity?: number | null
    whatsappNumber?: string | null
    telegramHandle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramHandle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyVenueInput = {
    id?: string
    title: string
    description?: string | null
    coverUrl?: string | null
    dateStart: Date | string
    dateEnd?: Date | string | null
    status?: $Enums.EventStatus
    minAge?: number | null
    dressCode?: string | null
    createdByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    funnelTracking?: FunnelTrackingUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUpdateManyWithoutEventNestedInput
    lists?: ListUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutEventNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutEventNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutEventNestedInput
    funnelTracking?: FunnelTrackingUncheckedUpdateManyWithoutEventNestedInput
    inviteLinks?: InviteLinkUncheckedUpdateManyWithoutEventNestedInput
    lists?: ListUncheckedUpdateManyWithoutEventNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    dressCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyEventInput = {
    id?: string
    prProfileId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsumptionCreateManyEventInput = {
    id?: string
    ticketId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackCreateManyEventInput = {
    id?: string
    ticketId?: string | null
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FunnelTrackingCreateManyEventInput = {
    id?: string
    sessionId: string
    guestEmail?: string | null
    guestPhone?: string | null
    step: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    timestamp?: Date | string
  }

  export type InviteLinkCreateManyEventInput = {
    id?: string
    createdByUserId: string
    prProfileId?: string | null
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListCreateManyEventInput = {
    id?: string
    name: string
    type: $Enums.ListType
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityNoteCreateManyEventInput = {
    id?: string
    guestId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type TicketCreateManyEventInput = {
    id?: string
    userId?: string | null
    guestId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prProfile?: PRProfileUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    prProfileId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    prProfileId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutConsumptionsNestedInput
  }

  export type ConsumptionUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: GuestUpdateOneWithoutFeedbacksNestedInput
    ticket?: TicketUpdateOneWithoutFeedbacksNestedInput
  }

  export type EventFeedbackUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelTrackingUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    step?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutInviteLinksNestedInput
    prProfile?: PRProfileUpdateOneWithoutInviteLinksNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    prProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ListEntryUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: ListEntryUncheckedUpdateManyWithoutListNestedInput
  }

  export type ListUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumListTypeFieldUpdateOperationsInput | $Enums.ListType
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: GuestUpdateOneWithoutSecurityNotesNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSecurityReportsNestedInput
    ticket?: TicketUpdateOneWithoutSecurityNotesNestedInput
  }

  export type SecurityNoteUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyPrProfileInput = {
    id?: string
    eventId: string
    quotaTotal?: number | null
    quotaFemale?: number | null
    quotaMale?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteLinkCreateManyPrProfileInput = {
    id?: string
    createdByUserId: string
    eventId: string
    slug: string
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    quotaTotal?: NullableIntFieldUpdateOperationsInput | number | null
    quotaFemale?: NullableIntFieldUpdateOperationsInput | number | null
    quotaMale?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutInviteLinksNestedInput
    event?: EventUpdateOneRequiredWithoutInviteLinksNestedInput
  }

  export type InviteLinkUncheckedUpdateWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteLinkUncheckedUpdateManyWithoutPrProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListEntryCreateManyListInput = {
    id?: string
    guestId?: string | null
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListEntryUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutListEntriesNestedInput
    guest?: GuestUpdateOneWithoutListEntriesNestedInput
    tickets?: TicketUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateManyWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackCreateManyGuestInput = {
    id?: string
    eventId: string
    ticketId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ListEntryCreateManyGuestInput = {
    id?: string
    listId: string
    addedByUserId: string
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    gender?: $Enums.Gender
    note?: string | null
    createdVia?: $Enums.CreatedVia
    status?: $Enums.EntryStatus
    plusOne?: boolean
    bookingMethod?: $Enums.BookingMethod
    referralSource?: string | null
    groupSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SecurityNoteCreateManyGuestInput = {
    id?: string
    eventId?: string | null
    ticketId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type TicketCreateManyGuestInput = {
    id?: string
    eventId: string
    userId?: string | null
    listEntryId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventFeedbackUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutFeedbacksNestedInput
    ticket?: TicketUpdateOneWithoutFeedbacksNestedInput
  }

  export type EventFeedbackUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListEntryUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutListEntriesNestedInput
    list?: ListUpdateOneRequiredWithoutEntriesNestedInput
    tickets?: TicketUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutListEntryNestedInput
  }

  export type ListEntryUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    listId?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    plusOne?: BoolFieldUpdateOperationsInput | boolean
    bookingMethod?: EnumBookingMethodFieldUpdateOperationsInput | $Enums.BookingMethod
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneWithoutSecurityNotesNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSecurityReportsNestedInput
    ticket?: TicketUpdateOneWithoutSecurityNotesNestedInput
  }

  export type SecurityNoteUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    listEntry?: ListEntryUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    listEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyListEntryInput = {
    id?: string
    eventId: string
    userId?: string | null
    guestId?: string | null
    issuedByUserId?: string | null
    type?: $Enums.TicketType
    price?: number | null
    currency?: string | null
    code: string
    qrData: string
    status?: $Enums.TicketStatus
    issuedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateWithoutListEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUpdateManyWithoutTicketNestedInput
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    guest?: GuestUpdateOneWithoutTicketsNestedInput
    issuedBy?: UserUpdateOneWithoutTicketsIssuedNestedInput
    user?: UserUpdateOneWithoutTicketsOwnedNestedInput
  }

  export type TicketUncheckedUpdateWithoutListEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkins?: CheckInUncheckedUpdateManyWithoutTicketNestedInput
    consumptions?: ConsumptionUncheckedUpdateManyWithoutTicketNestedInput
    feedbacks?: EventFeedbackUncheckedUpdateManyWithoutTicketNestedInput
    securityNotes?: SecurityNoteUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutListEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    qrData?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInCreateManyTicketInput = {
    id?: string
    scannedByUserId: string
    scannedAt?: Date | string
    gate?: $Enums.Gate
    ok?: boolean
    notes?: string | null
    arrivalTime?: string | null
    groupSize?: number
  }

  export type ConsumptionCreateManyTicketInput = {
    id?: string
    eventId: string
    amount: number
    category: string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EventFeedbackCreateManyTicketInput = {
    id?: string
    eventId: string
    guestId?: string | null
    overallRating: number
    musicRating?: number | null
    serviceRating?: number | null
    venueRating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SecurityNoteCreateManyTicketInput = {
    id?: string
    guestId?: string | null
    eventId?: string | null
    severity: string
    type: string
    description: string
    reportedByUserId: string
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type CheckInUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
    scannedBy?: UserUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type CheckInUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedByUserId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    scannedByUserId?: StringFieldUpdateOperationsInput | string
    scannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gate?: EnumGateFieldUpdateOperationsInput | $Enums.Gate
    ok?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    arrivalTime?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: IntFieldUpdateOperationsInput | number
  }

  export type ConsumptionUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutConsumptionsNestedInput
  }

  export type ConsumptionUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    items?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutFeedbacksNestedInput
    guest?: GuestUpdateOneWithoutFeedbacksNestedInput
  }

  export type EventFeedbackUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventFeedbackUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    overallRating?: IntFieldUpdateOperationsInput | number
    musicRating?: NullableIntFieldUpdateOperationsInput | number | null
    serviceRating?: NullableIntFieldUpdateOperationsInput | number | null
    venueRating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    interests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneWithoutSecurityNotesNestedInput
    guest?: GuestUpdateOneWithoutSecurityNotesNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutSecurityReportsNestedInput
  }

  export type SecurityNoteUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityNoteUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedByUserId?: StringFieldUpdateOperationsInput | string
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCreateManyArtistInput = {
    id?: string
    eventId?: string | null
    eventName: string
    eventDate: Date | string
    venueName: string
    city?: string | null
    description?: string | null
    fee?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistMediaCreateManyArtistInput = {
    id?: string
    type: $Enums.MediaType
    title?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venueName?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistMediaUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeCreateManyFeedItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FeedCommentCreateManyFeedItemInput = {
    id?: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedLikeUpdateWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedLikesNestedInput
  }

  export type FeedLikeUncheckedUpdateWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedLikeUncheckedUpdateManyWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentUpdateWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedCommentsNestedInput
  }

  export type FeedCommentUncheckedUpdateWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedCommentUncheckedUpdateManyWithoutFeedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}